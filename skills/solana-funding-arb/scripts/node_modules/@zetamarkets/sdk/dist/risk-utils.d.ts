import { types, constants } from ".";
import { Asset } from "./constants";
import { CrossMarginAccount, MarginAccount } from "./program-types";
/**
 * Assemble a collected risk state Map<Asset, types.AssetRiskState>, describing important values on a per-asset basis.
 * This is used getCrossMarginAccountState() and you probably don't need to be accessing it directly.
 * @param imMap Initial margins map
 * @param imSCMap Initial margins (skip concession) map
 * @param mmMap Maintenance margins map
 * @param mmioMap Maintenance margins (including orders) map
 * @param upnlMap Unrealised PnL map
 * @param unpaidFundingMap Unpaid funding map
 * @returns map of AssetRiskStates for each asset
 */
export declare function collectRiskMaps(imMap: Map<Asset, Number>, imSCMap: Map<Asset, Number>, mmMap: Map<Asset, Number>, mmioMap: Map<Asset, Number>, upnlMap: Map<Asset, Number>, unpaidFundingMap: Map<Asset, Number>, potentialOrderLossMap: Map<Asset, Number>): Map<Asset, types.AssetRiskState>;
/**
 * Calculates the margin requirement for a given market.
 * @param asset         underlying asset (SOL, BTC, etc.)
 * @param spotPrice     price of the spot, in decimal USDC
 * @returns Margin in decimal USDC
 */
export declare function calculateProductMargin(asset: Asset, spotPrice: number): types.MarginRequirement;
/**
 * Calculates the margin requirement for a given market.
 * @param asset         underlying asset (SOL, BTC, etc.)
 * @param spotPrice     price of the spot, in decimal USDC
 * @returns Margin in decimal USDC
 */
export declare function calculatePerpMargin(asset: Asset, spotPrice: number): types.MarginRequirement;
/**
 * Checks whether a given account has enough maintenance margin. If not, it may be liquidated.
 * @param marginAccount The MarginAccount itself.
 * @returns Whether the account has enough maintenance margin.
 */
export declare function checkMarginAccountMarginRequirement(marginAccount: MarginAccount): boolean;
/**
 * Simulate adding an extra position/order into an existing CrossMarginAccount.
 * This will change the account! Therefore do a deep clone first if you want a new account to simulate.
 * @param marginAccount The CrossMarginAccount itself
 * @param isTaker Whether or not the order crosses the orderbook in full and becomes a position
 * @param asset The market on which we're trading
 * @param side Bid or ask
 * @param price The trade price, in decimal USDC
 * @param size The trade size, in decimal USDC (absolute value, so it must be > 0)
 */
export declare function addFakeTradeToAccount(marginAccount: CrossMarginAccount, isTaker: boolean, asset: constants.Asset, side: types.Side, price: number, size: number): void;
/**
 * Simulate adding an extra position/order into an existing CrossMarginAccount, but deep copy the account first and return that deep copied account
 * @param marginAccount the CrossMarginAccount itself, untouched if clone = true
 * @param clone Whether to deep-copy the marginAccount as part of the function. You can speed up execution by providing your own already deep-copied marginAccount if calling this multiple times.
 * @param executionInfo A hypothetical trade. Object containing: asset (Asset), price (decimal USDC), size (signed decimal), isTaker (whether or not it trades for full size)
 * @returns The edited CrossMarginAccount with an added trade/order
 */
export declare function fakeTrade(marginAccount: CrossMarginAccount, clone: boolean, executionInfo: types.ExecutionInfo): CrossMarginAccount;
export declare function addFakeCancelToAccount(marginAccount: CrossMarginAccount, order: types.Order): void;
