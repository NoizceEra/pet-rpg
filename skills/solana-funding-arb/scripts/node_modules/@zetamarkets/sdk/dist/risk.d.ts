import * as types from "./types";
import * as constants from "./constants";
import { CrossMarginAccount, MarginAccount } from "./program-types";
import { Asset } from "./constants";
export declare class RiskCalculator {
    private _marginRequirements;
    private _perpMarginRequirements;
    constructor(assets: Asset[]);
    /**
     * Get the internal margin requirements for a perp market
     * @param asset underlying asset type.
     * @returns MarginRequirement object with initial and maintenance margin requirements. Values are decimals, for 1 lot.
     */
    getPerpMarginRequirements(asset: Asset): types.MarginRequirement;
    /**
     * Update the internal margin requirements for a perp market
     * @param asset underlying asset type.
     */
    updateMarginRequirements(asset: Asset): void;
    /**
     * Returns the margin requirement for a given market and size.
     * @param asset          underlying asset type.
     * @param size           signed size for margin requirements (short orders should be negative), in decimal USDC lots.
     * @param marginType     type of margin calculation.
     */
    getPerpMarginRequirement(asset: Asset, size: number, marginType: types.MarginType): number;
    private calculateMarginRequirement;
    /**
     * Returns the size of an order that would be considered "opening", when applied to margin requirements.
     * Total intended trade size = closing size + opening size. All arguments must use the same precision.
     * @param size           signed number of size for margin requirements (short orders should be negative)
     * @param position       signed number the user's current position for that product (0 if none).
     * @param closingSize    unsigned number of the user's current closing order quantity for that product (0 if none)
     *
     */
    calculateOpeningSize(size: number, position: number, closingSize: number): number;
    /**
     * Returns the unpaid funding for a given margin or crossmargin account.
     * @param account The MarginAccount itself
     * @param accountType MarginAccount or CrossMarginAccount
     */
    calculateUnpaidFunding(account: MarginAccount, accountType: types.ProgramAccountType): number;
    /**
     * Returns the unpaid funding for a given margin or crossmargin account.
     * @param account The CrossMarginAccount itself
     * @param accountType MarginAccount or CrossMarginAccount
     */
    calculateUnpaidFunding(account: CrossMarginAccount, accountType: types.ProgramAccountType): Map<Asset, number>;
    /**
     * Calculates the estimated realized PnL of the position by passing in an execution price and using taker fees
     * @param account The MarginAccount or CrossMarginAccount itself
     * @param accountType MarginAccount or CrossMarginAccount
     * @param executionInfo Information about how the PnL is hypothetically realised. asset (Asset), price (in decimal), size (in fixed POSITION_PRECISION, signed in the same direction as the existing position you're exiting), addTakerFees (bool)
     */
    estimateRealizedPnl(account: any, accountType: types.ProgramAccountType, executionInfo: types.ExecutionInfo): number;
    /**
     * Calculates the unrealised PnL of the account, marking all positions to the markPrice
     * @param account The MarginAccount itself
     * @param accountType MarginAccount or CrossMarginAccount
     */
    calculateUnrealizedPnl(account: MarginAccount, accountType: types.ProgramAccountType): number;
    /**
     * Calculates the unrealised PnL of the account, marking all positions to the markPrice
     * @param account The CrossMarginAccount itself
     * @param accountType MarginAccount or CrossMarginAccount
     */
    calculateUnrealizedPnl(account: CrossMarginAccount, accountType: types.ProgramAccountType): Map<Asset, number>;
    private calculatePnl;
    getPotentialOrderLoss(account: CrossMarginAccount): Map<Asset, number>;
    /**
     * Returns the total initial margin requirement for a given account.
     * This includes initial margin on positions which is used for
     * Place order, withdrawal and force cancels
     * @param account The MarginAccount itself.
     * @param accountType MarginAccount or CrossMarginAccount
     * @param skipConcession Whether to skip margin concessions or not
     */
    calculateTotalInitialMargin(account: MarginAccount, accountType: types.ProgramAccountType, skipConcession: boolean): number;
    /**
     * Returns the total initial margin requirement for a given account.
     * This includes initial margin on positions which is used for
     * Place order, withdrawal and force cancels
     * @param account The CrossMarginAccount itself.
     * @param accountType MarginAccount or CrossMarginAccount
     * @param skipConcession Whether to skip margin concessions or not
     */
    calculateTotalInitialMargin(account: CrossMarginAccount, accountType: types.ProgramAccountType, skipConcession: boolean): Map<Asset, number>;
    /**
     * Returns the total maintenance margin requirement for a given account.
     * This only uses maintenance margin on positions and is used for
     * liquidations.
     * @param account The MarginAccount itself.
     * @param accountType MarginAccount or CrossMarginAccount
     */
    calculateTotalMaintenanceMargin(account: MarginAccount, accountType: types.ProgramAccountType): number;
    /**
     * Returns the total maintenance margin requirement for a given account.
     * This only uses maintenance margin on positions and is used for
     * liquidations.
     * @param account The CrossMarginAccount itself.
     * @param accountType MarginAccount or CrossMarginAccount
     */
    calculateTotalMaintenanceMargin(account: CrossMarginAccount, accountType: types.ProgramAccountType): Map<Asset, number>;
    /**
     * Returns the total maintenance margin requirement for a given account including orders.
     * This calculates maintenance margin across all positions and orders.
     * This value is used to determine margin when sending a closing order only.
     * @param account The MarginAccount itself.
     * @param accountType MarginAccount or CrossMarginAccount
     */
    calculateTotalMaintenanceMarginIncludingOrders(account: MarginAccount, accountType: types.ProgramAccountType): number;
    /**
     * Returns the total maintenance margin requirement for a given account including orders.
     * This calculates maintenance margin across all positions and orders.
     * This value is used to determine margin when sending a closing order only.
     * @param account The CrossMarginAccount itself.
     * @param accountType MarginAccount or CrossMarginAccount
     */
    calculateTotalMaintenanceMarginIncludingOrders(account: CrossMarginAccount, accountType: types.ProgramAccountType): Map<Asset, number>;
    /**
     * Returns the aggregate margin account state.
     * @param marginAccount   the user's CrossMarginAccount.
     */
    getCrossMarginAccountState(marginAccount: CrossMarginAccount): types.CrossMarginAccountState;
    /**
     * Returns the aggregate margin account state.
     * @param marginAccount   the user's MarginAccount.
     */
    getMarginAccountState(marginAccount: MarginAccount): types.MarginAccountState;
    /**
     * Find the maximum size a user is allowed to trade, given the position they're currently in.
     * This function uses a binary search to approximate the largest size the user can trade.
     * The arguments 'thresholdPercent', 'bufferPercent' and 'maxIterations' can be changed to get the right tradeoff between precision and speed.
     * @param marginAccount The user's CrossMarginAccount itself
     * @param tradeAsset The asset being traded
     * @param tradeSide The side (bid/ask) being traded
     * @param tradePrice The price the user wishes to execute at, in decimal USDC. If tradePrice is <= 0, getMaxTradeSize returns undefined.
     * @param isTaker Whether the full size is expected to trade or not. Only set this to true if the orderbook is deep enough as it may result in less conservative values.
     * @param thresholdPercent The ratio of availableBalanceInitial/balance at which we decide a size is close enough to the maximum and can return
     * @param bufferPercent An added buffer on top of the final result, so that quick price movements don't immediately make you hit leverage limits
     * @param maxIterations The maximum amount of iterations for the binary search when finding a good size
     * @returns size in decimal, strictly >= 0. If tradePrice is <= 0, this returns undefined.
     */
    getMaxTradeSize(marginAccount: CrossMarginAccount, tradeAsset: constants.Asset, tradeSide: types.Side, tradePrice: number, maxLeverage?: number, isTaker?: boolean, fakeCancel?: types.Order, thresholdPercent?: number, bufferPercent?: number, maxIterations?: number): number | undefined;
    /**
     * Find the price at which a given position will be subject to liquidation.
     * (under the assumption that the prices of other assets stays static)
     * @param asset The asset being traded
     * @param marginAccount The CrossMarginAccount itself.
     * @returns Liquidation price, in decimal USDC
     */
    getEstimatedLiquidationPrice(asset: Asset, marginAccount: CrossMarginAccount, executionInfo?: types.ExecutionInfo, clone?: boolean): number;
    /**
     * Get an account's equity, which is the balance including unrealized PnL and unpaid funding.
     * You can optionally provide executionInfo to mimick a fake order/trade, which will return the account's equity after that order/trade occurs.
     * @param marginAccount The CrossMarginAccount itself, edited in-place if executionInfo is provided
     * @param executionInfo (Optional) A hypothetical trade. Object containing: asset (Asset), price (decimal USDC), size (signed decimal), isTaker (whether or not it trades for full size)
     * @param clone Whether to deep-copy the marginAccount as part of the function. You can speed up execution by providing your own already deep-copied marginAccount if calling multiple risk.ts functions.
     * @returns A decimal USDC representing the account equity
     */
    getEquity(marginAccount: CrossMarginAccount, executionInfo?: types.ExecutionInfo, clone?: boolean): number;
    /**
     * Get an account's buying power, which is the position size you can get additional exposure to.
     * You can optionally provide executionInfo to mimick a fake order/trade, which will return the account's buying power after that order/trade occurs.
     * @param marginAccount The CrossMarginAccount itself, edited in-place if executionInfo is provided
     * @param asset The underlying for which we're estimating buying power
     * @param executionInfo (Optional) A hypothetical trade. Object containing: asset (Asset), price (decimal USDC), size (signed decimal), isTaker (whether or not it trades for full size)
     * @param clone Whether to deep-copy the marginAccount as part of the function. You can speed up execution by providing your own already deep-copied marginAccount if calling multiple risk.ts functions.
     * @returns A decimal USDC representing the buying power
     */
    getBuyingPower(marginAccount: CrossMarginAccount, asset: Asset, executionInfo?: types.ExecutionInfo, clone?: boolean): number;
    /**
     * Get an account's margin usage, which is a decimal percentage from 0 to 100 representing the percentage of equity used in maintenance margin.
     * You can optionally provide executionInfo to mimick a fake order/trade, which will return the account's margin usage after that order/trade occurs.
     * @param marginAccount The CrossMarginAccount itself, edited in-place if executionInfo is provided
     * @param executionInfo (Optional) A hypothetical trade. Object containing: asset (Asset), price (decimal USDC), size (signed decimal), isTaker (whether or not it trades for full size)
     * @param clone Whether to deep-copy the marginAccount as part of the function. You can speed up execution by providing your own already deep-copied marginAccount if calling multiple risk.ts functions.
     * @returns A decimal percentage representing margin usage.
     */
    getMarginUsagePercent(marginAccount: CrossMarginAccount, executionInfo?: types.ExecutionInfo, clone?: boolean): number;
    /**
     * Get an account's free collateral, which is the amount of available collateral the account has for trading. Equivalent to 'availableBalanceInitial'
     * You can optionally provide executionInfo to mimick a fake order/trade, which will return the account's free collateral after that order/trade occurs.
     * @param marginAccount The CrossMarginAccount itself, edited in-place if executionInfo is provided
     * @param executionInfo (Optional) A hypothetical trade. Object containing: asset (Asset), price (decimal USDC), size (signed decimal), isTaker (whether or not it trades for full size)
     * @param clone Whether to deep-copy the marginAccount as part of the function. You can speed up execution by providing your own already deep-copied marginAccount if calling multiple risk.ts functions.
     * @returns A decimal USDC representing the available collateral.
     */
    getFreeCollateral(marginAccount: CrossMarginAccount, executionInfo?: types.ExecutionInfo, clone?: boolean): number;
    /**
     * Get an account's current leverage
     * You can optionally provide executionInfo to mimick a fake order/trade, which will return the account's current leverage after that order/trade occurs.
     * @param marginAccount The CrossMarginAccount itself, edited in-place if executionInfo is provided
     * @param executionInfo (Optional) A hypothetical trade. Object containing: asset (Asset), price (decimal USDC), size (signed decimal), isTaker (whether or not it trades for full size)
     * @param clone Whether to deep-copy the marginAccount as part of the function. You can speed up execution by providing your own already deep-copied marginAccount if calling multiple risk.ts functions.
     * @param overrideEquity whether to override the equity part of the calc, using the unchanged equity
     * @param useExecutionInfoPrice whether to override the mark price with the executionInfo price
     * @returns A decimal value representing the current leverage.
     */
    getLeverage(marginAccount: CrossMarginAccount, executionInfo?: types.ExecutionInfo, clone?: boolean, overrideEquity?: boolean, useExecutionInfoPrice?: boolean): number;
}
