/// <reference types="node" />
import * as anchor from "@zetamarkets/anchor";
import { PublicKey, ConfirmOptions, AccountMeta, AccountInfo } from "@solana/web3.js";
import { PerpSyncQueue } from "./program-types";
import { Market, ZetaGroupMarkets } from "./market";
import { Asset } from "./constants";
import * as instructions from "./program-instructions";
import * as types from "./types";
export declare class SubExchange {
    /**
     * Whether the object has been set up (in .initialize()).
     */
    get isSetup(): boolean;
    private _isSetup;
    /**
     * Whether the object has been initialized (in .load()).
     */
    get isInitialized(): boolean;
    private _isInitialized;
    /**
     * The asset loaded to the this.
     */
    get asset(): Asset;
    private _asset;
    /**
     * Address of zeta group account.
     */
    get zetaGroupAddress(): PublicKey;
    private _zetaGroupAddress;
    /**
     * Address of greeks account.
     */
    get greeksAddress(): PublicKey;
    private _greeksAddress;
    /**
     * Returns the markets object.
     */
    get markets(): ZetaGroupMarkets;
    private _markets;
    private _eventEmitters;
    /**
     * Account storing the queue which synchronises taker/maker perp funding payments.
     * You shouldn't need to read from this, it's mainly for our integration tests
     */
    get perpSyncQueue(): PerpSyncQueue;
    private _perpSyncQueue;
    get perpSyncQueueAddress(): PublicKey;
    private _perpSyncQueueAddress;
    get halted(): boolean;
    initialize(asset: Asset): Promise<void>;
    /**
     * Loads a fresh instance of the subExchange object using on chain state.
     * @param throttleMs    Whether to sleep on market loading for rate limit reasons.
     */
    load(asset: Asset, opts: ConfirmOptions, perpSyncQueue: PerpSyncQueue, decodedSrmMarket: any, bidAccInfo: AccountInfo<Buffer>, askAccInfo: AccountInfo<Buffer>, clockData: types.ClockData): Promise<void>;
    /**
     * Refreshes serum markets cache
     */
    updateSerumMarkets(): Promise<void>;
    /**
     * Checks only if the perp serum markets are stale and refreshes it if so
     */
    updatePerpSerumMarketIfNeeded(epochDelay: number): Promise<void>;
    /**
     * Update the margin parameters for a zeta group.
     */
    updateMarginParameters(args: instructions.UpdateMarginParametersArgs): Promise<void>;
    /**
     * Update the perp parameters for a zeta group.
     */
    updatePerpParameters(args: instructions.UpdatePerpParametersArgs): Promise<void>;
    initializeZetaMarketsTIFEpochCycle(cycleLengthSecs: number): Promise<void>;
    initializePerpSyncQueue(): Promise<void>;
    initializeUnderlying(flexUnderlying: boolean): Promise<void>;
    /**
     * Update pricing for an expiry index.
     */
    updatePricing(): Promise<void>;
    updatePricingV3(price: anchor.BN, timestamp: anchor.BN): Promise<void>;
    assertInitialized(): void;
    private subscribePerpSyncQueue;
    /**
     * @param index   market index to get mark price.
     */
    getMarkPrice(): number;
    /**
     * Returns all perp & nonperk markets in a single list
     */
    getMarket(): Market;
    /**
     * @param user user pubkey to be whitelisted for uncapped deposit
     */
    whitelistUserForDeposit(user: PublicKey): Promise<void>;
    /**
     * @param user user pubkey to be whitelisted for our insurance vault
     */
    whitelistUserForInsuranceVault(user: PublicKey): Promise<void>;
    /**
     * @param user user pubkey to be whitelisted for trading fees
     */
    whitelistUserForTradingFees(user: PublicKey): Promise<void>;
    /**
     * Halt zeta group functionality.
     */
    assertHalted(): void;
    halt(): Promise<void>;
    unhalt(): Promise<void>;
    updateHaltState(timestamp: anchor.BN, spotPrice: anchor.BN): Promise<void>;
    settlePositionsHalted(marginAccounts: AccountMeta[]): Promise<void>;
    cancelAllOrdersHalted(): Promise<void>;
    cleanZetaMarketHalted(): Promise<void>;
    /**
     * Close the websockets.
     */
    close(): Promise<void>;
}
