"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.exchange = exports.Exchange = void 0;
const anchor = __importStar(require("@zetamarkets/anchor"));
const web3_js_1 = require("@solana/web3.js");
const utils = __importStar(require("./utils"));
const constants = __importStar(require("./constants"));
const assets = __importStar(require("./assets"));
const risk_1 = require("./risk");
const events_1 = require("./events");
const network_1 = require("./network");
const oracle_1 = require("./oracle");
const zeta_json_1 = __importDefault(require("./idl/zeta.json"));
const types = __importStar(require("./types"));
const assets_1 = require("./assets");
const subexchange_1 = require("./subexchange");
const instructions = __importStar(require("./program-instructions"));
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const generate_decoded_1 = require("./serum/generate-decoded");
const market_1 = require("./serum/market");
const blockhash_cache_1 = require("./blockhash-cache");
class Exchange {
    constructor() {
        this._isSetup = false;
        this._isInitialized = false;
        this._subExchanges = new Map();
        this._clockTimestamp = undefined;
        /**
         * The subscription id for the pricing account.
         */
        this._pricingSubscriptionId = undefined;
        /**
         * The subscription id for the state account.
         */
        this._stateSubscriptionId = undefined;
        this._pollInterval = constants.DEFAULT_EXCHANGE_POLL_INTERVAL;
        this.maxRpcRetries = undefined;
        this.skipRpcConfirmation = undefined;
        this._zetaGroupPubkeyToAsset = new Map();
        this._useLedger = false;
        this._programSubscriptionIds = [];
        this._eventEmitters = [];
        this._priorityFee = 0;
        this._useJitoBundle = false;
        this._jitoTip = 0;
        this._doubleDownConnections = [];
        this._useAutoPriorityFee = false;
        this._autoPriorityFeeOffset = 0;
        this._autoPriorityFeeMultiplier = 1;
        this._autoPriorityFeeUseMax = false;
        this._tipMultiplier = 1;
        this._postSignCallback = undefined;
        this._autoPriorityFeeUpperLimit = constants.PRIO_FEE_UPPER_LIMIT;
        this._blockhashCommitment = "confirmed";
    }
    /**
     * Whether the object has been set up (in .initialize()).
     */
    get isSetup() {
        return this._isSetup;
    }
    /**
     * Whether the object has been initialized (in .load()).
     */
    get isInitialized() {
        return this._isInitialized;
    }
    /**
     * Account storing zeta state.
     */
    get state() {
        return this._state;
    }
    /**
     * Account storing zeta pricing.
     */
    get pricing() {
        return this._pricing;
    }
    /**
     * The solana network being used.
     */
    get network() {
        return this._network;
    }
    /**
     * Anchor program instance.
     */
    get program() {
        return this._program;
    }
    get programId() {
        return this._program.programId;
    }
    /**
     * Anchor provider instance.
     */
    get provider() {
        return this._provider;
    }
    get connection() {
        return this._provider.connection;
    }
    get httpProvider() {
        return this._httpProvider;
    }
    /**
     * Separate connection used for orderbook subscriptions.
     * For example you might use a connection with Whirligig and low commitment for faster results
     */
    get orderbookConnection() {
        return this._orderbookConnection;
    }
    /**
     * Public key used as the stable coin mint.
     */
    get usdcMintAddress() {
        return this._usdcMintAddress;
    }
    /**
     * ConfirmOptions, stored so we don't need it again when making a SerumMarket.
     */
    get opts() {
        return this._opts;
    }
    /*
     * One SubExchange per underlying.
     */
    get subExchanges() {
        return this._subExchanges;
    }
    /**
     * The assets being used
     */
    get assets() {
        return this._assets;
    }
    /*
     * Oracle object that holds all oracle prices.
     */
    get oracle() {
        return this._oracle;
    }
    /**
     * Risk calculator that holds all margin requirements.
     */
    get riskCalculator() {
        return this._riskCalculator;
    }
    /**
     * Zeta PDA for serum market authority
     */
    get serumAuthority() {
        return this._serumAuthority;
    }
    /**
     * Zeta PDA for minting serum mints
     */
    get mintAuthority() {
        return this._mintAuthority;
    }
    /**
     * Address of state account.
     */
    get stateAddress() {
        return this._stateAddress;
    }
    /**
     * Address of zeta pricing account.
     */
    get pricingAddress() {
        return this._pricingAddress;
    }
    /**
     * Public key for treasury wallet.
     */
    get treasuryWalletAddress() {
        return this._treasuryWalletAddress;
    }
    /**
     * Public key for referral rewards wallet.
     */
    get referralsRewardsWalletAddress() {
        return this._referralsRewardsWalletAddress;
    }
    /**
     * Public key for combined insurance fund.
     */
    get combinedInsuranceVaultAddress() {
        return this._combinedInsuranceVaultAddress;
    }
    /**
     * Public key for combined deposit vault.
     */
    get combinedVaultAddress() {
        return this._combinedVaultAddress;
    }
    /**
     * Public key for combined socialized loss account.
     */
    get combinedSocializedLossAccountAddress() {
        return this._combinedSocializedLossAccountAddress;
    }
    /**
     * Stores the latest timestamp received by websocket subscription
     * to the system clock account.
     */
    get clockTimestamp() {
        return this._clockTimestamp;
    }
    /**
     * Stores the latest clock slot from clock subscription.
     */
    get clockSlot() {
        return this._clockSlot;
    }
    /**
     * @param interval   How often to poll zeta group and state in seconds.
     */
    get pollInterval() {
        return this._pollInterval;
    }
    set pollInterval(interval) {
        if (interval < 0) {
            throw Error("Invalid polling interval");
        }
        this._pollInterval = interval;
    }
    get ledgerWallet() {
        return this._ledgerWallet;
    }
    get useLedger() {
        return this._useLedger;
    }
    setLedgerWallet(wallet) {
        this._useLedger = true;
        this._ledgerWallet = wallet;
    }
    // Handy map to grab zetagroup asset by pubkey without an RPC fetch
    // or having to manually filter all zetaGroups
    zetaGroupPubkeyToAsset(key) {
        return this._zetaGroupPubkeyToAsset.get(key);
    }
    // Micro lamports per CU of fees.
    get priorityFee() {
        return this._priorityFee;
    }
    // toggle to use jito bundles
    get useJitoBundle() {
        return this._useJitoBundle;
    }
    // jito tip
    get jitoTip() {
        return this._jitoTip;
    }
    // extra connection objects to send transactions down
    get doubleDownConnections() {
        return this._doubleDownConnections;
    }
    addDoubleDownConnection(connection) {
        this._doubleDownConnections.push(connection);
    }
    get useAutoPriorityFee() {
        return this._useAutoPriorityFee;
    }
    get tipMultiplier() {
        return this._tipMultiplier;
    }
    get postSignCallback() {
        return this._postSignCallback;
    }
    set postSignCallback(callback) {
        this._postSignCallback = callback;
    }
    // Micro lamports per CU of fees.
    get autoPriorityFeeUpperLimit() {
        return this._autoPriorityFeeUpperLimit;
    }
    get blockhashCommitment() {
        return this._blockhashCommitment;
    }
    async getCachedBlockhash() {
        try {
            return this._blockhashCache.get();
        }
        catch (e) {
            if (this.network != network_1.Network.LOCALNET) {
                console.log(e);
            }
            return await this.provider.connection.getLatestBlockhash(this.blockhashCommitment);
        }
    }
    setUseAutoPriorityFee(useAutoPriorityFee) {
        this._useAutoPriorityFee = useAutoPriorityFee;
    }
    toggleAutoPriorityFee() {
        this._useAutoPriorityFee = !this._useAutoPriorityFee;
    }
    setAutoPriorityFeeScaling(offset = 0, multiplier = 1) {
        this._autoPriorityFeeMultiplier = multiplier;
        this._autoPriorityFeeOffset = offset;
    }
    toggleAutoPriorityFeeUseMax() {
        this._autoPriorityFeeUseMax = !this._autoPriorityFeeUseMax;
    }
    setAutoPriorityFeeUseMax(useMax) {
        this._autoPriorityFeeUseMax = useMax;
    }
    setTipMultiplier(multiplier) {
        this._tipMultiplier = multiplier;
    }
    updatePriorityFee(microLamportsPerCU) {
        this._priorityFee = microLamportsPerCU;
    }
    setUseJitoBundle(option) {
        this._useJitoBundle = option;
    }
    updateJitoTip(tipAmountInLamports) {
        this._jitoTip = tipAmountInLamports;
    }
    updateAutoPriorityFeeUpperLimit(microLamportsPerCU) {
        this._autoPriorityFeeUpperLimit = microLamportsPerCU;
    }
    updateBlockhashCommitment(commitment) {
        this._blockhashCommitment = commitment;
    }
    initialize(loadConfig, wallet = new types.DummyWallet()) {
        if (this.isSetup) {
            throw Error("Exchange already setup");
        }
        // https://docs.triton.one/chains/solana/web3js-socket-connection-issues
        if (typeof window === "undefined") {
            Promise.resolve().then(() => __importStar(require("undici"))).then((undici) => {
                undici.setGlobalDispatcher(new undici.Agent({
                    connections: 100,
                }));
            });
        }
        this._blockhashCache = new blockhash_cache_1.BlockhashCache(loadConfig.blockhashCacheTimeoutSeconds
            ? loadConfig.blockhashCacheTimeoutSeconds
            : 50);
        if (loadConfig.loadAssets) {
            this._assets = loadConfig.loadAssets;
        }
        else {
            this._assets = assets.allAssets(loadConfig.network);
        }
        this._provider = new anchor.AnchorProvider(loadConfig.connection, wallet instanceof types.DummyWallet ? null : wallet, loadConfig.opts ||
            utils.commitmentConfig(loadConfig.connection.commitment));
        if (loadConfig.orderbookConnection) {
            this._orderbookConnection =
                loadConfig.orderbookConnection;
        }
        this._opts = loadConfig.opts;
        this._network = loadConfig.network;
        this._program = new anchor.Program(zeta_json_1.default, constants.ZETA_PID[loadConfig.network], this._provider);
        for (var asset of this._assets) {
            this.addSubExchange(asset, new subexchange_1.SubExchange());
            this.getSubExchange(asset).initialize(asset);
        }
        this._combinedVaultAddress = utils.getCombinedVault(this.programId)[0];
        this._combinedInsuranceVaultAddress = utils.getZetaCombinedInsuranceVault(this.programId)[0];
        this._combinedSocializedLossAccountAddress =
            utils.getCombinedSocializedLossAccount(this.programId)[0];
        this._isSetup = true;
    }
    async initializeCombinedInsuranceVault() {
        let tx = new web3_js_1.Transaction().add(instructions.initializeCombinedInsuranceVaultIx());
        try {
            await utils.processTransaction(this._provider, tx);
        }
        catch (e) {
            console.error(`initializeCombinedInsuranceVault failed: ${e}`);
        }
        let [insuranceVault, _insuranceVaultNonce] = utils.getZetaCombinedInsuranceVault(this.programId);
        this._combinedInsuranceVaultAddress = insuranceVault;
    }
    async initializeCombinedVault() {
        let tx = new web3_js_1.Transaction().add(instructions.initializeCombinedVaultIx());
        try {
            await utils.processTransaction(this._provider, tx);
        }
        catch (e) {
            console.error(`initializeCombinedVault failed: ${e}`);
        }
        let [vault, _vaultNonce] = utils.getCombinedVault(this.programId);
        this._combinedVaultAddress = vault;
    }
    async initializeCombinedSocializedLossAccount() {
        let tx = new web3_js_1.Transaction().add(instructions.initializeCombinedSocializedLossAccountIx());
        try {
            await utils.processTransaction(this._provider, tx);
        }
        catch (e) {
            console.error(`initializeCombinedSocializedLossAccount failed: ${e}`);
        }
        let [account, _accountNonce] = utils.getCombinedSocializedLossAccount(this.programId);
        this._combinedSocializedLossAccountAddress = account;
    }
    async updateTreasurySplitTokenAccount(treasurySplitTokenAccount, treasurySplitPercentage, admin) {
        let tx = new web3_js_1.Transaction().add(instructions.updateTreasurySplitTokenAccountIx(treasurySplitTokenAccount, treasurySplitPercentage, admin));
        try {
            await utils.processTransaction(this._provider, tx);
        }
        catch (e) {
            console.error(`updateTreasurySplitTokenAccount failed: ${e}`);
        }
    }
    async initializeZetaState(params, referralAdmin, secondaryAdmin) {
        const [mintAuthority, mintAuthorityNonce] = utils.getMintAuthority(this.programId);
        const [state, stateNonce] = utils.getState(this.programId);
        const [pricing, _pricingNonce] = utils.getPricing(this.programId);
        const [serumAuthority, serumNonce] = utils.getSerumAuthority(this.programId);
        this._usdcMintAddress = constants.USDC_MINT_ADDRESS[this.network];
        const [treasuryWallet, _treasuryWalletNonce] = utils.getZetaTreasuryWallet(this.programId, this._usdcMintAddress);
        const [referralRewardsWallet, _referralRewardsWalletNonce] = utils.getZetaReferralsRewardsWallet(this.programId, this._usdcMintAddress);
        let tx = new web3_js_1.Transaction().add(instructions.initializeZetaStateIx(state, stateNonce, serumAuthority, treasuryWallet, referralAdmin, referralRewardsWallet, serumNonce, mintAuthority, mintAuthorityNonce, params, secondaryAdmin));
        try {
            await utils.processTransaction(this._provider, tx);
        }
        catch (e) {
            console.error(`Initialize zeta state failed: ${e}`);
        }
        this._mintAuthority = mintAuthority;
        this._stateAddress = state;
        this._pricingAddress = pricing;
        this._serumAuthority = serumAuthority;
        this._treasuryWalletAddress = treasuryWallet;
        this._referralsRewardsWalletAddress = referralRewardsWallet;
        await this.updateState();
    }
    async initializeZetaPricing(perpArgs, marginArgs) {
        let tx = new web3_js_1.Transaction().add(instructions.initializeZetaPricingIx(perpArgs, marginArgs));
        try {
            await utils.processTransaction(this._provider, tx, [], utils.defaultCommitment(), this.useLedger);
        }
        catch (e) {
            console.error(`Initialize zeta pricing failed: ${e}`);
            console.log(e);
        }
        await this.updateZetaPricing();
    }
    async load(loadConfig, wallet = new types.DummyWallet(), callback, postSignCallback, bloxrouteHttpProvider) {
        if (this.isInitialized) {
            throw Error("Exchange already loaded");
        }
        if (loadConfig.network == network_1.Network.LOCALNET && loadConfig.loadFromStore) {
            throw Error("Cannot load localnet from store");
        }
        if (!this.isSetup) {
            this.initialize(loadConfig, wallet);
        }
        if (bloxrouteHttpProvider) {
            this._httpProvider = bloxrouteHttpProvider;
        }
        if (loadConfig.doubleDownConnections) {
            for (var con of loadConfig.doubleDownConnections) {
                this.addDoubleDownConnection(con);
            }
        }
        this._riskCalculator = new risk_1.RiskCalculator(this.assets);
        // Load variables from state.
        this._mintAuthority = utils.getMintAuthority(this.programId)[0];
        this._stateAddress = utils.getState(this.programId)[0];
        this._pricingAddress = utils.getPricing(this.programId)[0];
        this._serumAuthority = utils.getSerumAuthority(this.programId)[0];
        this._usdcMintAddress = constants.USDC_MINT_ADDRESS[loadConfig.network];
        this._treasuryWalletAddress = utils.getZetaTreasuryWallet(this.programId, this._usdcMintAddress)[0];
        this._referralsRewardsWalletAddress = utils.getZetaReferralsRewardsWallet(this.programId, this._usdcMintAddress)[0];
        this._lastPollTimestamp = 0;
        await this.updateZetaPricing();
        this._oracle = new oracle_1.Oracle(this.network, this.connection);
        const srmMarketAddresses = this.assets.map((a) => {
            return this.pricing.products[(0, assets_1.assetToIndex)(a)].market;
        });
        const perpSyncQueueAddresses = this.assets
            .map((a) => {
            const se = this.getSubExchange(a);
            return [se.perpSyncQueueAddress];
        })
            .flat();
        const allAddrsToFetch = perpSyncQueueAddresses;
        let srmBidAddrs = [];
        let srmAskAddrs = [];
        let decodedSrmMarkets = [];
        if (!loadConfig.loadFromStore) {
            allAddrsToFetch.push(...srmMarketAddresses);
        }
        if (this.network != network_1.Network.LOCALNET) {
            this.assets.forEach((a) => {
                let decodedSrmMarket = (0, generate_decoded_1.getDecodedMarket)(this.network, a, constants.PERP_INDEX);
                decodedSrmMarkets.push(decodedSrmMarket);
                srmBidAddrs.push(decodedSrmMarket.bids);
                srmAskAddrs.push(decodedSrmMarket.asks);
            });
        }
        allAddrsToFetch.push(...srmBidAddrs);
        allAddrsToFetch.push(...srmAskAddrs);
        allAddrsToFetch.push(web3_js_1.SYSVAR_CLOCK_PUBKEY);
        const accFetchPromise = this.connection.getMultipleAccountsInfo(allAddrsToFetch);
        const allPromises = [accFetchPromise].concat([
            this.subscribeOracle(this.assets, callback),
        ]);
        const accFetches = (await Promise.all(allPromises))[0];
        // First 0 to Assets.length-1 will always be PerpSyncQueues
        const perpSyncQueueAccs = accFetches
            .slice(0, this.assets.length)
            .map((accInfo) => {
            return this.program.account.perpSyncQueue.coder.accounts.decode(types.ProgramAccountType.PerpSyncQueue, accInfo.data);
        });
        const clockData = utils.getClockData(accFetches.at(-1));
        // Assets.length to Assets.length + Assets.length-1 will sometimes be SerumMarket data
        await Promise.all(this.assets.map(async (asset, i) => {
            let decodedSrmMarket = undefined;
            let bidAccInfo = undefined;
            let askAccInfo = undefined;
            if (this.network != network_1.Network.LOCALNET) {
                if (loadConfig.loadFromStore) {
                    decodedSrmMarket = decodedSrmMarkets[i];
                    bidAccInfo = accFetches[this.assets.length + i];
                    askAccInfo = accFetches[this.assets.length * 2 + i];
                }
                else {
                    decodedSrmMarket = market_1.MARKET_STATE_LAYOUT_V3.decode(accFetches[this.assets.length + i].data);
                    bidAccInfo = accFetches[this.assets.length * 2 + i];
                    askAccInfo = accFetches[this.assets.length * 3 + i];
                }
            }
            else {
                decodedSrmMarket = market_1.MARKET_STATE_LAYOUT_V3.decode(accFetches[this.assets.length + i].data);
            }
            return this.getSubExchange(asset).load(asset, this.opts, perpSyncQueueAccs[i], decodedSrmMarket, bidAccInfo, askAccInfo, clockData);
        }));
        for (var se of this.getAllSubExchanges()) {
            // Only subscribe to the orderbook for assets provided in the override
            // Useful for FE because we only want one asset at a time
            // If no override is provided, subscribe to all assets
            if (!loadConfig.orderbookAssetSubscriptionOverride ||
                (loadConfig.orderbookAssetSubscriptionOverride &&
                    loadConfig.orderbookAssetSubscriptionOverride.includes(se.asset))) {
                // Optionally provide a buffer for when orders are not shown due to TIF
                // Useful for slow internet connections on FE because it doesn't have to be exactly precise
                if (loadConfig.TIFBufferSeconds) {
                    se.markets.market.TIFBufferSeconds = loadConfig.TIFBufferSeconds;
                }
                se.markets.market.subscribeOrderbook(callback);
            }
            this._zetaGroupPubkeyToAsset.set(se.zetaGroupAddress, se.asset);
        }
        this.subscribeClock(clockData, callback);
        this.subscribePricing(callback);
        this.subscribeState(callback);
        if (postSignCallback) {
            this._postSignCallback = postSignCallback;
        }
        await this.updateCachedBlockhash();
        await this.updateExchangeState();
        this._isInitialized = true;
        // An extra log because the throttleMs path is slower and logs more along the way
        if (loadConfig.throttleMs > 0) {
            console.log("Exchange load complete");
        }
    }
    addSubExchange(asset, subExchange) {
        this._subExchanges.set(asset, subExchange);
    }
    getSubExchange(asset) {
        const subExchange = this._subExchanges.get(asset);
        if (subExchange === undefined) {
            throw new Error(`Failed to get subExchange for asset=${asset}, have you called Exchange.load()?`);
        }
        return subExchange;
    }
    getAllSubExchanges() {
        return [...this._subExchanges.values()];
    }
    // Public so you can call it as often as you want. By default gets called in the clock interval
    async updateAutoFee() {
        let accountList = [];
        // Query the most written-to accounts
        // Note: getRecentPrioritizationFees() will account for global fees too if no one is writing to our accs
        for (var asset of this.assets) {
            let sub = this.getSubExchange(asset);
            accountList.push(sub.perpSyncQueueAddress.toString());
            accountList.push(sub.greeksAddress.toString());
        }
        try {
            let data = await (0, cross_fetch_1.default)(this.provider.connection.rpcEndpoint, {
                method: "post",
                body: `{"jsonrpc":"2.0", "id":1, "method":"getRecentPrioritizationFees", "params":[["${accountList.join(`","`)}"]]}`,
                headers: { "Content-Type": "application/json" },
            });
            let fees = (await data.json()).result
                .sort((a, b) => b.slot - a.slot) // Sort descending
                .slice(0, 20) // Grab the latest 20
                .map((obj) => obj.prioritizationFee); // Take a list of prioritizationFee values only
            let num = this._autoPriorityFeeUseMax
                ? Math.max(...fees)
                : utils.median(fees);
            let numScaled = this._autoPriorityFeeOffset + num * this._autoPriorityFeeMultiplier;
            this._priorityFee = Math.round(Math.min(numScaled, this._autoPriorityFeeUpperLimit));
            console.log(`AutoUpdate priority fee. New fee = ${this._priorityFee} microlamports per compute unit`);
        }
        catch (e) {
            console.log(`updateAutoFee failed ${e}`);
        }
    }
    async subscribeOracle(assets, callback) {
        return this._oracle.subscribePriceFeeds(assets, (asset, price, slot) => {
            if (this.isInitialized) {
                this._riskCalculator.updateMarginRequirements(asset);
            }
            if (callback !== undefined) {
                callback(asset, events_1.EventType.ORACLE, slot, price);
            }
        });
    }
    setClockData(data) {
        this._clockTimestamp = data.timestamp;
        this._clockSlot = data.slot;
    }
    subscribeClock(clockData, callback) {
        if (this._clockSubscriptionId !== undefined) {
            throw Error("Clock already subscribed to.");
        }
        this._clockSubscriptionId = this.provider.connection.onAccountChange(web3_js_1.SYSVAR_CLOCK_PUBKEY, async (accountInfo, context) => {
            this.setClockData(utils.getClockData(accountInfo));
            await Promise.all(this._assets.map((a) => {
                return this.updatePerpSerumMarketIfNeeded(a, 0);
            }));
            if (callback !== undefined) {
                callback(null, events_1.EventType.CLOCK, context.slot, null);
            }
            try {
                if (this._clockTimestamp >
                    this._lastPollTimestamp + this._pollInterval &&
                    this.isInitialized) {
                    this._lastPollTimestamp = this._clockTimestamp;
                    await this.updateCachedBlockhash();
                    if (this._useAutoPriorityFee == true) {
                        await this.updateAutoFee();
                    }
                }
            }
            catch (e) {
                console.log(`SubExchange polling failed. Error: ${e}`);
            }
        }, this.provider.connection.commitment, "base64+zstd");
        this.setClockData(clockData);
    }
    addProgramSubscriptionId(id) {
        this._programSubscriptionIds.push(id);
    }
    async updateExchangeState() {
        let accInfos = await this.connection.getMultipleAccountsInfo([
            this.stateAddress,
            this.pricingAddress,
        ]);
        this._state = this.program.account.state.coder.accounts.decode(types.ProgramAccountType.State, accInfos[0].data);
        this._pricing = this.program.account.pricing.coder.accounts.decode(types.ProgramAccountType.Pricing, accInfos[1].data);
    }
    /**
     * Polls the on chain account to update state.
     */
    async updateState() {
        this._state = (await this.program.account.state.fetch(this.stateAddress));
    }
    // TODO add subscription to this account
    /**
     * Polls the on chain account to update mark prices
     */
    async updateZetaPricing() {
        this._pricing = (await this.program.account.pricing.fetch(this.pricingAddress));
    }
    /**
     * Update the expiry state variables for the program.
     */
    async updateZetaState(params) {
        let tx = new web3_js_1.Transaction().add(instructions.updateZetaStateIx(params, this.provider.wallet.publicKey));
        await utils.processTransaction(this.provider, tx);
        await this.updateState();
    }
    subscribeState(callback) {
        this._stateSubscriptionId = this.connection.onAccountChange(this._stateAddress, async (accountInfo, context) => {
            this._state = this.program.coder.accounts.decode("State", accountInfo.data);
            if (callback !== undefined) {
                callback(null, events_1.EventType.EXCHANGE, context.slot, null);
            }
        }, this.provider.connection.commitment, "base64+zstd");
    }
    // Not actually a websocket subscription, this polls for a recent blockhash every N seconds and stores it in a cache
    // Ideally you should use slightly stale blockhashes to be able to deterministically fail a tx faster instead of waiting ~90s
    async updateCachedBlockhash() {
        let latestBlockhash = await this.provider.connection.getLatestBlockhash(this.blockhashCommitment);
        this._blockhashCache.set(latestBlockhash, Date.now() / 1000);
    }
    subscribePricing(callback) {
        this._pricingSubscriptionId = this.connection.onAccountChange(this._pricingAddress, async (accountInfo, context) => {
            this._pricing = this.program.coder.accounts.decode(types.ProgramAccountType.Pricing, accountInfo.data);
            const assetsToMarkPrices = {};
            for (const asset of this.assets) {
                const markPrice = this.subExchanges.get(asset).getMarkPrice();
                assetsToMarkPrices[asset] = markPrice;
            }
            if (callback !== undefined) {
                callback(null, events_1.EventType.PRICING, context.slot, assetsToMarkPrices);
            }
        }, this.provider.connection.commitment, "base64+zstd");
    }
    getZetaGroupMarkets(asset) {
        return this.getSubExchange(asset).markets;
    }
    getPerpMarket(asset) {
        return this.getSubExchange(asset).markets.market;
    }
    getZetaGroupAddress(asset) {
        return this.getSubExchange(asset).zetaGroupAddress;
    }
    getPerpSyncQueue(asset) {
        return this.getSubExchange(asset).perpSyncQueue;
    }
    getOrderbook(asset) {
        return this.getPerpMarket(asset).orderbook;
    }
    getMarkPrice(asset) {
        return this.getSubExchange(asset).getMarkPrice();
    }
    getInsuranceVaultAddress() {
        return this._combinedInsuranceVaultAddress;
    }
    getVaultAddress() {
        return this._combinedVaultAddress;
    }
    getSocializedLossAccountAddress() {
        return this._combinedSocializedLossAccountAddress;
    }
    async updateMarginParameters(asset, args) {
        await this.getSubExchange(asset).updateMarginParameters(args);
    }
    async updatePerpParameters(asset, args) {
        await this.getSubExchange(asset).updatePerpParameters(args);
    }
    async updateSerumMarkets(asset) {
        await this.getSubExchange(asset).updateSerumMarkets();
    }
    async updatePerpSerumMarketIfNeeded(asset, epochDelay) {
        await this.getSubExchange(asset).updatePerpSerumMarketIfNeeded(epochDelay);
    }
    async initializeZetaMarkets(asset, zetaGroupAddress) {
        await utils.initializeZetaMarkets(asset, zetaGroupAddress);
    }
    async initializeZetaMarketsTIFEpochCycle(asset, cycleLengthSecs) {
        await this.getSubExchange(asset).initializeZetaMarketsTIFEpochCycle(cycleLengthSecs);
    }
    async initializePerpSyncQueue(asset) {
        await this.getSubExchange(asset).initializePerpSyncQueue();
    }
    async initializeUnderlying(asset, flexUnderlying) {
        await this.getSubExchange(asset).initializeUnderlying(flexUnderlying);
    }
    async updatePricing(asset) {
        await this.getSubExchange(asset).updatePricing();
    }
    async updatePricingV3(asset, price, timestamp) {
        await this.getSubExchange(asset).updatePricingV3(price, timestamp);
    }
    async updatePricingPubkeys(asset, oracle, market, perpSyncQueue, zetaGroupKey) {
        let tx = new web3_js_1.Transaction().add(instructions.updateZetaPricingPubkeysIx({
            asset: (0, assets_1.toProgramAsset)(asset),
            oracle,
            market,
            perpSyncQueue,
            zetaGroupKey,
            resetOracle: false,
        }));
        await utils.processTransaction(this.provider, tx);
        await this.updateZetaPricing();
    }
    async whitelistUserForDeposit(asset, user) {
        await this.getSubExchange(asset).whitelistUserForDeposit(user);
    }
    async whitelistUserForInsuranceVault(asset, user) {
        await this.getSubExchange(asset).whitelistUserForInsuranceVault(user);
    }
    async whitelistUserForTradingFees(asset, user) {
        await this.getSubExchange(asset).whitelistUserForTradingFees(user);
    }
    async treasuryMovement(treasuryMovementType, amount) {
        let tx = new web3_js_1.Transaction().add(instructions.treasuryMovementIx(treasuryMovementType, amount));
        await utils.processTransaction(this._provider, tx);
    }
    async rebalanceInsuranceVault(marginAccounts) {
        let txs = [];
        for (var i = 0; i < marginAccounts.length; i += constants.MAX_REBALANCE_ACCOUNTS) {
            let tx = new web3_js_1.Transaction();
            let slice = marginAccounts.slice(i, i + constants.MAX_REBALANCE_ACCOUNTS);
            tx.add(instructions.rebalanceInsuranceVaultIx(slice));
            txs.push(tx);
        }
        try {
            await Promise.all(txs.map(async (tx) => {
                let txSig = await utils.processTransaction(this._provider, tx);
                console.log(`[REBALANCE INSURANCE VAULT]: ${txSig}`);
            }));
        }
        catch (e) {
            console.log(`Error in rebalancing the insurance vault ${e}`);
        }
    }
    async adminCancelTriggerOrder(orderIndex, crossMarginAccount, enforceTpslConditions = true) {
        let triggerAccount = utils.getTriggerOrder(this.programId, crossMarginAccount, new Uint8Array([orderIndex]))[0];
        let tx = new web3_js_1.Transaction().add(instructions.forceCancelTriggerOrderIx(orderIndex, this._provider.wallet.publicKey, triggerAccount, crossMarginAccount, enforceTpslConditions));
        return await utils.processTransaction(this._provider, tx);
    }
    async halt(asset) {
        await this.getSubExchange(asset).halt();
    }
    async unhalt(asset) {
        await this.getSubExchange(asset).unhalt();
    }
    async updateHaltState(asset, timestamp, spotPrice) {
        await this.getSubExchange(asset).updateHaltState(timestamp, spotPrice);
    }
    async settlePositionsHalted(asset, marginAccounts) {
        await this.getSubExchange(asset).settlePositionsHalted(marginAccounts);
    }
    async cancelAllOrdersHalted(asset) {
        await this.getSubExchange(asset).cancelAllOrdersHalted();
    }
    async cleanZetaMarketHalted(asset) {
        await this.getSubExchange(asset).cleanZetaMarketHalted();
    }
    isHalted(asset) {
        return this.getSubExchange(asset).halted;
    }
    async close() {
        this._isInitialized = false;
        this._isSetup = false;
        await Promise.all(this.getAllSubExchanges().map(async (subExchange) => {
            await subExchange.close();
        }));
        await this._oracle.close();
        if (this._clockSubscriptionId !== undefined) {
            await this.connection.removeAccountChangeListener(this._clockSubscriptionId);
            this._clockSubscriptionId = undefined;
        }
        if (this._pricingSubscriptionId !== undefined) {
            await this._provider.connection.removeAccountChangeListener(this._pricingSubscriptionId);
            this._pricingSubscriptionId = undefined;
        }
        if (this._stateSubscriptionId !== undefined) {
            await this._provider.connection.removeAccountChangeListener(this._stateSubscriptionId);
            this._stateSubscriptionId = undefined;
        }
        for (var i = 0; i < this._programSubscriptionIds.length; i++) {
            await this.connection.removeProgramAccountChangeListener(this._programSubscriptionIds[i]);
        }
        this._programSubscriptionIds = [];
        for (var i = 0; i < this._eventEmitters.length; i++) {
            this._eventEmitters[i].removeListener("change");
        }
        this._eventEmitters = [];
    }
}
exports.Exchange = Exchange;
// Exchange singleton.
exports.exchange = new Exchange();
