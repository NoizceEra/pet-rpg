"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addFakeCancelToAccount = exports.fakeTrade = exports.addFakeTradeToAccount = exports.checkMarginAccountMarginRequirement = exports.calculatePerpMargin = exports.calculateProductMargin = exports.collectRiskMaps = void 0;
const _1 = require(".");
const utils_1 = require("./utils");
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const anchor = __importStar(require("@zetamarkets/anchor"));
/**
 * Assemble a collected risk state Map<Asset, types.AssetRiskState>, describing important values on a per-asset basis.
 * This is used getCrossMarginAccountState() and you probably don't need to be accessing it directly.
 * @param imMap Initial margins map
 * @param imSCMap Initial margins (skip concession) map
 * @param mmMap Maintenance margins map
 * @param mmioMap Maintenance margins (including orders) map
 * @param upnlMap Unrealised PnL map
 * @param unpaidFundingMap Unpaid funding map
 * @returns map of AssetRiskStates for each asset
 */
function collectRiskMaps(imMap, imSCMap, mmMap, mmioMap, upnlMap, unpaidFundingMap, potentialOrderLossMap) {
    let allAssets = _1.assets.allAssets();
    let collectedRiskState = new Map();
    for (let a of allAssets) {
        collectedRiskState.set(a, {
            initialMargin: imMap.get(a),
            initialMarginSkipConcession: imSCMap.get(a),
            maintenanceMargin: mmMap.get(a),
            maintenanceMarginIncludingOrders: mmioMap.get(a),
            unrealizedPnl: upnlMap.get(a),
            unpaidFunding: unpaidFundingMap.get(a),
            potentialOrderLoss: potentialOrderLossMap.get(a),
        });
    }
    return collectedRiskState;
}
exports.collectRiskMaps = collectRiskMaps;
/**
 * Calculates the margin requirement for a given market.
 * @param asset         underlying asset (SOL, BTC, etc.)
 * @param spotPrice     price of the spot, in decimal USDC
 * @returns Margin in decimal USDC
 */
function calculateProductMargin(asset, spotPrice) {
    let market = _1.Exchange.getPerpMarket(asset);
    if (market.strike == null) {
        return null;
    }
    return calculatePerpMargin(asset, spotPrice);
}
exports.calculateProductMargin = calculateProductMargin;
/**
 * Calculates the margin requirement for a given market.
 * @param asset         underlying asset (SOL, BTC, etc.)
 * @param spotPrice     price of the spot, in decimal USDC
 * @returns Margin in decimal USDC
 */
function calculatePerpMargin(asset, spotPrice) {
    let assetIndex = _1.assets.assetToIndex(asset);
    let initial = spotPrice *
        (0, utils_1.convertNativeBNToDecimal)(_1.Exchange.pricing.marginParameters[assetIndex].futureMarginInitial, _1.constants.MARGIN_PRECISION);
    let maintenance = spotPrice *
        (0, utils_1.convertNativeBNToDecimal)(_1.Exchange.pricing.marginParameters[assetIndex].futureMarginMaintenance, _1.constants.MARGIN_PRECISION);
    return {
        initialLong: initial,
        initialShort: initial,
        maintenanceLong: maintenance,
        maintenanceShort: maintenance,
    };
}
exports.calculatePerpMargin = calculatePerpMargin;
/**
 * Checks whether a given account has enough maintenance margin. If not, it may be liquidated.
 * @param marginAccount The MarginAccount itself.
 * @returns Whether the account has enough maintenance margin.
 */
function checkMarginAccountMarginRequirement(marginAccount) {
    let pnl = _1.Exchange.riskCalculator.calculateUnrealizedPnl(marginAccount, _1.types.ProgramAccountType.MarginAccount);
    let totalMaintenanceMargin = _1.Exchange.riskCalculator.calculateTotalMaintenanceMargin(marginAccount, _1.types.ProgramAccountType.MarginAccount);
    let buffer = marginAccount.balance.toNumber() + pnl - totalMaintenanceMargin;
    return buffer > 0;
}
exports.checkMarginAccountMarginRequirement = checkMarginAccountMarginRequirement;
/**
 * Simulate adding an extra position/order into an existing CrossMarginAccount.
 * This will change the account! Therefore do a deep clone first if you want a new account to simulate.
 * @param marginAccount The CrossMarginAccount itself
 * @param isTaker Whether or not the order crosses the orderbook in full and becomes a position
 * @param asset The market on which we're trading
 * @param side Bid or ask
 * @param price The trade price, in decimal USDC
 * @param size The trade size, in decimal USDC (absolute value, so it must be > 0)
 */
function addFakeTradeToAccount(marginAccount, isTaker, asset, side, price, size) {
    let assetIndex = _1.assets.assetToIndex(asset);
    let editedPosition = marginAccount.productLedgers[assetIndex].position;
    let editedOrderState = marginAccount.productLedgers[assetIndex].orderState;
    let markPrice = _1.Exchange.getMarkPrice(asset);
    let fee = ((0, utils_1.getFeeBps)(isTaker, marginAccount.accountType) / 10000) * price;
    let sizeNative = (0, utils_1.convertDecimalToNativeLotSize)(size);
    let currentSizeBN = editedPosition.size;
    let currentSize = currentSizeBN.toNumber();
    // Fake the new position, moving both editedPosition and editedOrderState
    if (isTaker) {
        editedPosition.size = editedPosition.size.add(new anchor.BN(side == _1.types.Side.BID ? sizeNative : -sizeNative));
        marginAccount.balance = marginAccount.balance.sub(new anchor.BN((0, utils_1.convertDecimalToNativeInteger)(fee * size, 1)));
        // If we're just adding to costOfTrades
        if ((side == _1.types.Side.BID && currentSize > 0) ||
            (side == _1.types.Side.ASK && currentSize < 0)) {
            editedPosition.costOfTrades = editedPosition.costOfTrades.add(new anchor.BN(size * (0, utils_1.convertDecimalToNativeInteger)(price, 1)));
            let openIndex = side == _1.types.Side.BID ? 1 : 0;
            let diff = anchor.BN.min(editedOrderState.openingOrders[openIndex], new anchor.BN(sizeNative));
            editedOrderState.closingOrders = editedOrderState.closingOrders.add(diff);
            editedOrderState.openingOrders[openIndex] =
                editedOrderState.openingOrders[openIndex].sub(diff);
        }
        // If we're just reducing the current position
        else if (sizeNative < Math.abs(currentSize)) {
            let entryPrice = new anchor.BN(editedPosition.costOfTrades.toNumber() /
                (0, utils_1.convertNativeLotSizeToDecimal)(Math.abs(currentSize)));
            let priceDiff = entryPrice.sub(new anchor.BN((0, utils_1.convertDecimalToNativeInteger)(price, 1)));
            let sizeMul = side == _1.types.Side.BID ? size : -1 * size;
            marginAccount.balance = marginAccount.balance.add(new anchor.BN(sizeMul * priceDiff.toNumber()));
            editedPosition.costOfTrades = editedPosition.costOfTrades.sub(editedPosition.costOfTrades
                .mul(new anchor.BN(sizeNative))
                .div(currentSizeBN.abs()));
            let openIndex = side == _1.types.Side.BID ? 0 : 1;
            let diff = anchor.BN.min(editedOrderState.closingOrders, new anchor.BN(sizeNative));
            editedOrderState.closingOrders = editedOrderState.closingOrders.sub(diff);
            editedOrderState.openingOrders[openIndex] =
                editedOrderState.openingOrders[openIndex].add(diff);
        }
        // If we're zeroing out the current position and opening a position on the other side
        else {
            if (Math.abs(currentSize) > 0) {
                let entryPrice = new anchor.BN(editedPosition.costOfTrades.toNumber() /
                    (0, utils_1.convertNativeLotSizeToDecimal)(Math.abs(currentSize)));
                let priceDiff = entryPrice.sub(new anchor.BN((0, utils_1.convertDecimalToNativeInteger)(price, 1)));
                marginAccount.balance = marginAccount.balance.add(new anchor.BN(side == _1.types.Side.BID
                    ? (0, utils_1.convertNativeLotSizeToDecimal)(currentSizeBN.abs())
                    : -(0, utils_1.convertNativeLotSizeToDecimal)(currentSizeBN.abs())).mul(priceDiff));
            }
            editedPosition.costOfTrades = new anchor.BN((0, utils_1.convertNativeLotSizeToDecimal)(Math.abs(editedPosition.size.toNumber())) * (0, utils_1.convertDecimalToNativeInteger)(price, 1));
            let sameSide = side == _1.types.Side.BID ? 0 : 1;
            let otherSide = side == _1.types.Side.BID ? 1 : 0;
            editedOrderState.openingOrders[sameSide] = editedOrderState.openingOrders[sameSide].add(editedOrderState.closingOrders);
            editedOrderState.closingOrders = anchor.BN.max(editedOrderState.openingOrders[otherSide].sub(editedPosition.size.abs()), new anchor.BN(0));
            editedOrderState.openingOrders[otherSide] =
                editedOrderState.openingOrders[otherSide].sub(editedOrderState.closingOrders);
        }
    }
    // Fake the new order. editedPosition is untouched
    else {
        // Any non-filled trades have an extra PnL adjustment
        // Only negative PnL is used
        let pnlAdjustment = size * (markPrice - price);
        pnlAdjustment = Math.min(0, side == _1.types.Side.BID ? pnlAdjustment : -pnlAdjustment);
        marginAccount.balance = marginAccount.balance.add(new anchor.BN((0, utils_1.convertDecimalToNativeInteger)(pnlAdjustment, 1)));
        // If we're just adding an extra order on the same side as the existing position
        if ((side == _1.types.Side.BID && currentSize > 0) ||
            (side == _1.types.Side.ASK && currentSize < 0)) {
            let i = side == _1.types.Side.BID ? 0 : 1;
            editedOrderState.openingOrders[i] = editedOrderState.openingOrders[i].add(new anchor.BN(sizeNative));
        }
        // If we're adding to the opposite side then both openingOrders and closingOrders change
        else {
            let i = side == _1.types.Side.BID ? 0 : 1;
            let newOrderSize = editedOrderState.closingOrders
                .add(editedOrderState.openingOrders[i])
                .add(new anchor.BN(sizeNative));
            editedOrderState.closingOrders = anchor.BN.min(newOrderSize, editedPosition.size.abs());
            editedOrderState.openingOrders[i] = newOrderSize.sub(editedOrderState.closingOrders);
        }
    }
    marginAccount.productLedgers[assetIndex].orderState = editedOrderState;
    marginAccount.productLedgers[assetIndex].position = editedPosition;
    marginAccount.lastFundingDeltas[assetIndex] =
        _1.Exchange.pricing.fundingDeltas[assetIndex];
}
exports.addFakeTradeToAccount = addFakeTradeToAccount;
/**
 * Simulate adding an extra position/order into an existing CrossMarginAccount, but deep copy the account first and return that deep copied account
 * @param marginAccount the CrossMarginAccount itself, untouched if clone = true
 * @param clone Whether to deep-copy the marginAccount as part of the function. You can speed up execution by providing your own already deep-copied marginAccount if calling this multiple times.
 * @param executionInfo A hypothetical trade. Object containing: asset (Asset), price (decimal USDC), size (signed decimal), isTaker (whether or not it trades for full size)
 * @returns The edited CrossMarginAccount with an added trade/order
 */
function fakeTrade(marginAccount, clone, executionInfo) {
    let account = clone
        ? (0, lodash_clonedeep_1.default)(marginAccount)
        : marginAccount;
    addFakeTradeToAccount(account, executionInfo.isTaker, executionInfo.asset, executionInfo.size > 0 ? _1.types.Side.BID : _1.types.Side.ASK, executionInfo.price, Math.abs(executionInfo.size));
    return account;
}
exports.fakeTrade = fakeTrade;
function addFakeCancelToAccount(marginAccount, order) {
    const assetIndex = _1.assets.assetToIndex(order.asset);
    const bidAskIndex = order.side == _1.types.Side.BID ? 0 : 1;
    const nativeOrderSize = (0, utils_1.convertDecimalToNativeLotSize)(order.size);
    let totalOrders = marginAccount.productLedgers[assetIndex].orderState.closingOrders +
        marginAccount.productLedgers[assetIndex].orderState.openingOrders[0] +
        marginAccount.productLedgers[assetIndex].orderState.openingOrders[1];
    if (totalOrders == nativeOrderSize) {
        marginAccount.potentialOrderLoss[assetIndex] = new anchor.BN(0);
    }
    else {
        let totalMaxLoss = marginAccount.potentialOrderLoss[assetIndex];
        let maxLossPerLot = totalMaxLoss / totalOrders;
        let averageMaxLoss = maxLossPerLot * nativeOrderSize;
        marginAccount.potentialOrderLoss[assetIndex].sub(new anchor.BN(averageMaxLoss));
    }
    const cancelOpening = Math.min(marginAccount.productLedgers[assetIndex].orderState.openingOrders[bidAskIndex].toNumber(), nativeOrderSize);
    const cancelClosing = nativeOrderSize - cancelOpening;
    marginAccount.productLedgers[assetIndex].orderState.openingOrders[bidAskIndex] = new anchor.BN(marginAccount.productLedgers[assetIndex].orderState.openingOrders[bidAskIndex].toNumber() - cancelOpening);
    marginAccount.productLedgers[assetIndex].orderState.closingOrders =
        new anchor.BN(marginAccount.productLedgers[assetIndex].orderState.closingOrders -
            cancelClosing);
}
exports.addFakeCancelToAccount = addFakeCancelToAccount;
