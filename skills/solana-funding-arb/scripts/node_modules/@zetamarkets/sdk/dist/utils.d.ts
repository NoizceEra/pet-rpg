/// <reference types="node" />
import * as anchor from "@zetamarkets/anchor";
import { Commitment, Keypair, ConfirmOptions, PublicKey, Connection, Signer, Transaction, TransactionInstruction, TransactionSignature, AccountInfo, VersionedTransaction, AddressLookupTableAccount } from "@solana/web3.js";
import { Asset } from "./constants";
import * as constants from "./constants";
import { Market } from "./market";
import { TriggerOrder, MarginAccount, TradeEventV3, CrossMarginAccount } from "./program-types";
import * as types from "./types";
import * as instructions from "./program-instructions";
import { HttpProvider } from "@bloxroute/solana-trader-client-ts";
export declare function getNativeTickSize(asset: Asset): number;
export declare function getDecimalMinLotSize(asset: Asset): number;
export declare function getNativeMinLotSize(asset: Asset): number;
export declare function getState(programId: PublicKey): [PublicKey, number];
export declare function getMarketNode(programId: PublicKey, zetaGroup: PublicKey, marketIndex: number): [PublicKey, number];
export declare function getSettlement(programId: PublicKey, underlyingMint: PublicKey, expirationTs: anchor.BN): [PublicKey, number];
export declare function getCrossOpenOrders(programId: PublicKey, market: PublicKey, account: PublicKey): [PublicKey, number];
export declare function getOpenOrders(programId: PublicKey, market: PublicKey, userKey: PublicKey): [PublicKey, number];
export declare function createOpenOrdersAddress(programId: PublicKey, market: PublicKey, userKey: PublicKey, nonce: number): PublicKey;
export declare function createCrossOpenOrdersAddress(programId: PublicKey, market: PublicKey, userKey: PublicKey, nonce: number): PublicKey;
export declare function getCrossOpenOrdersMap(programId: PublicKey, openOrders: PublicKey): [PublicKey, number];
export declare function getOpenOrdersMap(programId: PublicKey, openOrders: PublicKey): [PublicKey, number];
export declare function getSerumAuthority(programId: PublicKey): [PublicKey, number];
export declare function getMintAuthority(programId: PublicKey): [PublicKey, number];
export declare function getVault(programId: PublicKey, zetaGroup: PublicKey): [PublicKey, number];
export declare function getCombinedVault(programId: PublicKey): [PublicKey, number];
export declare function getSerumVault(programId: PublicKey, mint: PublicKey): [PublicKey, number];
export declare function getZetaVault(programId: PublicKey, mint: PublicKey): [PublicKey, number];
export declare function getZetaInsuranceVault(programId: PublicKey, zetaGroup: PublicKey): [PublicKey, number];
export declare function getZetaCombinedInsuranceVault(programId: PublicKey): [PublicKey, number];
export declare function getZetaTreasuryWallet(programId: PublicKey, mint: PublicKey): [PublicKey, number];
export declare function getZetaReferralsRewardsWallet(programId: PublicKey, mint: PublicKey): [PublicKey, number];
export declare function getUserInsuranceDepositAccount(programId: PublicKey, userKey: PublicKey): [PublicKey, number];
export declare function getUserWhitelistDepositAccount(programId: PublicKey, userKey: PublicKey): [PublicKey, number];
export declare function getUserWhitelistInsuranceAccount(programId: PublicKey, userKey: PublicKey): [PublicKey, number];
export declare function getUserWhitelistTradingFeesAccount(programId: PublicKey, userKey: PublicKey): [PublicKey, number];
export declare function getZetaGroup(programId: PublicKey, mint: PublicKey): [PublicKey, number];
export declare function getPricing(programId: PublicKey): [PublicKey, number];
export declare function getUnderlying(programId: PublicKey, underlyingIndex: number): [PublicKey, number];
export declare function getFlexUnderlying(programId: PublicKey, underlyingIndex: number): [PublicKey, number];
export declare function getFlexUnderlyingMint(programId: PublicKey, underlyingIndex: number): [PublicKey, number];
export declare function getGreeks(programId: PublicKey, zetaGroup: PublicKey): [PublicKey, number];
export declare function getPerpSyncQueue(programId: PublicKey, zetaGroup: PublicKey): [PublicKey, number];
export declare function getMarketIndexes(programId: PublicKey, zetaGroup: PublicKey): [PublicKey, number];
export declare function getBaseMint(programId: PublicKey, market: PublicKey): [PublicKey, number];
export declare function getQuoteMint(programId: PublicKey, market: PublicKey): [PublicKey, number];
export declare function getReferrerIdAccount(programId: PublicKey, id: string): [PublicKey, number];
export declare function getReferrerPubkeyAccount(programId: PublicKey, userKey: PublicKey): [PublicKey, number];
export declare function getCrossMarginAccountManager(programId: PublicKey, userKey: PublicKey): [PublicKey, number];
export declare function getCrossMarginAccount(programId: PublicKey, userKey: PublicKey, seedNumber: Uint8Array): [PublicKey, number];
export declare function getMarginAccount(programId: PublicKey, zetaGroup: PublicKey, userKey: PublicKey): [PublicKey, number];
export declare function getSpreadAccount(programId: PublicKey, zetaGroup: PublicKey, userKey: PublicKey): [PublicKey, number];
export declare function getTriggerOrder(programId: PublicKey, marginAccount: PublicKey, triggerOrderBit: Uint8Array): [PublicKey, number];
export declare function getMarketUninitialized(programId: PublicKey, zetaGroup: PublicKey, marketIndex: number): [PublicKey, number];
export declare function getSocializedLossAccount(programId: PublicKey, zetaGroup: PublicKey): [PublicKey, number];
export declare function getCombinedSocializedLossAccount(programId: PublicKey): [PublicKey, number];
export declare function getReferrerAccountAddress(programId: PublicKey, referrer: PublicKey): [PublicKey, number];
export declare function getReferralAccountAddress(programId: PublicKey, user: PublicKey): [PublicKey, number];
export declare function getReferrerAliasAddress(programId: PublicKey, alias: string): [PublicKey, number];
/**
 * Returns the expected PDA by serum to own the serum vault
 * Serum uses a u64 as nonce which is not the same as
 * normal solana PDA convention and goes 0 -> 255
 */
export declare function getSerumVaultOwnerAndNonce(market: PublicKey, dexPid: PublicKey): [PublicKey, anchor.BN];
/**
 * Serum interprets publickeys as [u64; 4]
 * Which requires swap64 sorting.
 */
export declare function sortOpenOrderKeys(keys: PublicKey[]): PublicKey[];
/**
 * Normal sorting of keys
 */
export declare function sortMarketKeys(keys: PublicKey[]): PublicKey[];
/**
 * Converts a decimal number to native fixed point integer of precision 6.
 * roundingFactor argument will round the result to the nearest <roundingFactor>. Default is 100.
 */
export declare function convertDecimalToNativeInteger(amount: number, roundingFactor?: number): number;
/**
 * Returns the trade event price. This may return a number that
 * does not divide perfectly by tick size (0.0001) if your order traded
 * against orders at different prices.
 */
export declare function getTradeEventPrice(event: TradeEventV3): number;
/**
 * Converts a native fixed point integer of precision 6 to decimal.
 */
export declare function convertNativeIntegerToDecimal(amount: number): number;
/**
 * Converts a program BN to a decimal number.
 * @param pricing   whether the BN you are converting is a pricing BN - defaults to false.
 */
export declare function convertNativeBNToDecimal(number: anchor.BN, precision?: number): number;
/**
 * Converts a native lot size where 1 unit = 0.001 lots to human readable decimal
 * @param amount
 */
export declare function convertNativeLotSizeToDecimal(amount: number): number;
/**
 * Converts a human readable decimal to a native lot size where 1 unit = 0.001 lots
 * @param amount
 */
export declare function convertDecimalToNativeLotSize(amount: number, roundingFactor?: number): number;
export declare function getTokenMint(connection: Connection, key: PublicKey): Promise<PublicKey>;
/**
 * Copied from @solana/spl-token but their version requires you to
 * construct a Token object which is completely unnecessary
 */
export declare function getTokenAccountInfo(connection: Connection, key: PublicKey): Promise<any>;
export declare function getAssociatedTokenAddress(mint: PublicKey, owner: PublicKey): PublicKey;
export declare function defaultCommitment(): ConfirmOptions;
export declare function commitmentConfig(commitment: Commitment): ConfirmOptions;
export declare function getTradeEventsFromTx(txId: string, marginAccountFilter?: PublicKey): Promise<TradeEventV3[]>;
export declare function simulateTransaction(provider: anchor.AnchorProvider, tx: Transaction): Promise<{
    events: Generator<anchor.Event<import("@zetamarkets/anchor/dist/cjs/idl").IdlEvent, Record<string, never>>, void, unknown>;
    raw: any;
}>;
export declare function processTransactionBloxroute(httpProvider: HttpProvider, anchorProvider: anchor.AnchorProvider, tx: Transaction, tip: number, blockhash?: {
    blockhash: string;
    lastValidBlockHeight: number;
}, retries?: number, skipConfirmation?: boolean): Promise<TransactionSignature>;
export declare function processVersionedTransactionJito(provider: anchor.AnchorProvider, tx: VersionedTransaction, signers?: Array<Signer>, opts?: ConfirmOptions, blockhash?: {
    blockhash: string;
    lastValidBlockHeight: number;
}): Promise<TransactionSignature>;
export declare function processTransactionJito(provider: anchor.AnchorProvider, tx: Transaction, signers?: Array<Signer>, opts?: ConfirmOptions, lutAccs?: AddressLookupTableAccount[], blockhash?: {
    blockhash: string;
    lastValidBlockHeight: number;
}): Promise<TransactionSignature>;
export declare function sendRawTransactionCaught(con: Connection, rawTx: any): Promise<string>;
export declare function sendJitoTxCaught(payload: any): Promise<any>;
export declare function processVersionedTransaction(provider: anchor.AnchorProvider, tx: VersionedTransaction, signers?: Array<Signer>, opts?: ConfirmOptions, blockhash?: {
    blockhash: string;
    lastValidBlockHeight: number;
}, retries?: number): Promise<TransactionSignature>;
export declare function processTransaction(provider: anchor.AnchorProvider, tx: Transaction, signers?: Array<Signer>, opts?: ConfirmOptions, useLedger?: boolean, lutAccs?: AddressLookupTableAccount[], blockhash?: {
    blockhash: string;
    lastValidBlockHeight: number;
}, retries?: number): Promise<TransactionSignature>;
export declare function parseError(err: any): any;
export declare function readBigInt64LE(buffer: Buffer, offset?: number): bigint;
export declare function getClockData(accountInfo: AccountInfo<Buffer>): types.ClockData;
export declare function getPriceFromSerumOrderKey(key: anchor.BN): anchor.BN;
export declare function getSeqNumFromSerumOrderKey(key: anchor.BN, isBid: boolean): anchor.BN;
export declare function splitIxsIntoTx(ixs: TransactionInstruction[], ixsPerTx: number): Transaction[];
export declare function sleep(ms: number): Promise<void>;
/**
 * Given a market index, return the index to access the greeks.productGreeks.
 */
export declare function getGreeksIndex(marketIndex: number): number;
export declare function displayState(): void;
export declare function getAccountFromOpenOrders(openOrders: PublicKey, asset: Asset): Promise<anchor.web3.PublicKey>;
export declare function getCrossMarginFromOpenOrders(openOrders: PublicKey): Promise<anchor.web3.PublicKey>;
export declare function getMarginFromOpenOrders(asset: Asset, openOrders: PublicKey, market: Market): Promise<anchor.web3.PublicKey>;
export declare function cleanZetaMarkets(asset: Asset, marketAccountTuples: any[]): Promise<void>;
export declare function cleanZetaMarketHalted(asset: Asset): Promise<void>;
export declare function crankMarket(asset: Asset, openOrdersToMargin?: Map<string, PublicKey>, crankLimit?: number): Promise<boolean>;
export declare function createCrankMarketIx(asset: Asset, openOrdersToMargin?: Map<string, PublicKey>, crankLimit?: number): Promise<TransactionInstruction | null>;
export declare function pruneExpiredTIFOrders(asset: Asset): Promise<string>;
export declare function pruneExpiredTIFOrdersV2(asset: Asset, limit: number): Promise<string>;
export declare function getMutMarketAccounts(asset: Asset): Object[];
export declare function getCancelAllIxs(asset: Asset, orders: any[], _expiration: boolean): Promise<TransactionInstruction[]>;
export declare function writeKeypair(filename: string, keypair: Keypair): void;
export declare function getAllProgramAccountAddresses(accountType: types.ProgramAccountType, asset?: Asset): Promise<PublicKey[]>;
export declare function getAllOpenOrdersAccounts(asset: Asset, accountLimit?: number): Promise<PublicKey[]>;
export declare function settleAndBurnVaultTokens(asset: Asset, provider: anchor.AnchorProvider, accountLimit?: number): Promise<void>;
export declare function burnVaultTokens(asset: Asset, provider: anchor.AnchorProvider): Promise<void>;
/**
 * Calculates the total movement fees for a set of movements.
 * @param movements   list of position movements.
 * @param spotPrice   spot price in decimal
 * @param feeBps      fees charged in bps
 * @param decimal     whether to return fees in decimal or native integer (defaults to native integer)
 */
export declare function calculateMovementFees(movements: instructions.PositionMovementArg[], spotPrice: number, feeBps: number, decimal?: boolean): number;
export declare function getOrCreateKeypair(filename: string): Keypair;
export declare function toAssets(assetsStr: string[]): Asset[];
export declare function objectEquals(a: any, b: any): boolean;
export declare function convertBufferToTrimmedString(buffer: number[]): string;
export declare function fetchReferralId(user: PublicKey): Promise<string>;
export declare function applyPerpFunding(asset: Asset, keys: PublicKey[]): Promise<void>;
export declare function executeTriggerOrder(asset: Asset, side: types.Side, triggerOrderBit: number, triggerOrder: PublicKey, marginAccount: PublicKey, openOrders: PublicKey, payer: PublicKey): Promise<void>;
export declare function getProductLedger(marginAccount: MarginAccount, index: number): import("./program-types").ProductLedger;
export declare function getTIFOffset(marketInfo: Market, tifOptions: types.TIFOptions): any;
export declare function isOrderExpired(orderTIFOffset: number, orderSeqNum: anchor.BN, epochStartTs: number, startEpochSeqNum: anchor.BN, TIFBufferSeconds: number): boolean;
export declare function getZetaLutArr(): AddressLookupTableAccount[];
export declare function getUnderlyingMint(asset: Asset): any;
export declare function isFlexUnderlying(asset: Asset): boolean;
export declare function median(arr: number[]): number | undefined;
export declare function isAffiliateCodeAvailable(code: string): Promise<boolean>;
export declare const checkLiquidity: (size: number, asset: Asset, side: types.Side, slippage?: number, orderbook?: types.DepthOrderbook) => types.LiquidityCheckInfo;
export declare function deepCloneCrossMarginAccount(marginAccount: CrossMarginAccount): CrossMarginAccount;
/**
 * Initializes the zeta markets for a zeta group.
 */
export declare function initializeZetaMarkets(asset: Asset, zetaGroupAddress: PublicKey): Promise<void>;
export declare function calculateTakeTriggerOrderExecutionPrice(triggerOrder: TriggerOrder): any;
export declare function getFeeTier(accountType: constants.MarginAccountType): number;
export declare function getFeeBps(isTaker: boolean, accountType: constants.MarginAccountType): number;
