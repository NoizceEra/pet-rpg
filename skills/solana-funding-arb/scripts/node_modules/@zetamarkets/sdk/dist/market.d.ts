/// <reference types="node" />
import { Orderbook, Market as SerumMarket } from "./serum/market";
import { AccountInfo, ConfirmOptions, PublicKey } from "@solana/web3.js";
import * as types from "./types";
import { EventType } from "./events";
import { Asset } from "./constants";
export declare class ZetaGroupMarkets {
    /**
     * The underlying asset this set of markets belong to.
     */
    get asset(): Asset;
    private _asset;
    /**
     * The list of markets in the same ordering as the zeta group account
     * They are in sorted order by market address.
     */
    get market(): Market;
    private _market;
    set pollInterval(interval: number);
    get pollInterval(): number;
    private _pollInterval;
    private _lastPollTimestamp;
    private constructor();
    /**
     * Will load a new instance of ZetaGroupMarkets
     * Should not be called outside of SubExchange.
     */
    static load(asset: Asset, opts: ConfirmOptions, decodedSrmMarket: any, bidAccInfo: AccountInfo<Buffer> | undefined, askAccInfo: AccountInfo<Buffer> | undefined, clockData: types.ClockData): Promise<ZetaGroupMarkets>;
    /**
     * Returns the market object for a given index.
     */
    getMarket(): Market;
    /**
     * Returns the market index for a given market address.
     */
    getMarketIndex(market: PublicKey): number;
}
/**
 * Wrapper class for a zeta market on serum.
 */
export declare class Market {
    /**
     * The underlying asset this set of markets belong to.
     */
    get asset(): Asset;
    private _asset;
    /**
     * The serum market address.
     */
    get address(): PublicKey;
    private _address;
    /**
     * The zeta group this market belongs to.
     * TODO currently there exists only one zeta group.
     */
    get zetaGroup(): PublicKey;
    private _zetaGroup;
    /**
     * The zeta vault for the quote mint.
     */
    get quoteVault(): PublicKey;
    private _quoteVault;
    /**
     * The zeta vault for the base mint.
     */
    get baseVault(): PublicKey;
    private _baseVault;
    /**
     * The serum Market object from @project-serum/ts
     */
    get serumMarket(): SerumMarket;
    private _serumMarket;
    set bids(bids: Orderbook);
    private _bids;
    set asks(asks: Orderbook);
    private _asks;
    get bidsSlot(): number;
    private _bidsSlot;
    get asksSlot(): number;
    private _asksSlot;
    private _bidsSubscriptionId;
    private _asksSubscriptionId;
    /**
     * Returns the best N levels for bids and asks
     */
    get orderbook(): types.DepthOrderbook;
    private _orderbook;
    /**
     * The strike of this option, modified on new expiry.
     */
    get strike(): number;
    private _strike;
    set TIFBufferSeconds(buffer: number);
    get TIFBufferSeconds(): number;
    private _TIFBufferSeconds;
    constructor(asset: Asset, address: PublicKey, zetaGroup: PublicKey, quoteVault: PublicKey, baseVault: PublicKey, serumMarket: SerumMarket);
    updateStrike(): void;
    subscribeOrderbook(callback?: (asset: Asset, type: EventType, slot: number, data: any) => void): void;
    unsubscribeOrderbook(wipeState?: boolean): Promise<void>;
    forceFetchOrderbook(): Promise<void>;
    updateOrderbook(): void;
    getTopLevel(): types.TopLevel;
    static convertOrder(market: Market, order: any): types.Order;
    getOrdersForAccount(openOrdersAddress: PublicKey): types.Order[];
    getMarketOrders(): types.Order[];
    getBidOrders(): types.Order[];
    getAskOrders(): types.Order[];
    cancelAllOrdersHalted(): Promise<void>;
}
