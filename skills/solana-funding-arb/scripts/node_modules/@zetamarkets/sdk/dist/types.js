"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AirdropCommunity = exports.defaultLoadExchangeConfig = exports.defaultOrderOptions = exports.defaultTriggerOrderOptions = exports.getDefaultTriggerDirection = exports.fromProgramOrderCompleteType = exports.OrderCompleteType = exports.isMarketMaker = exports.toProgramMarginAccountType = exports.fromProgramMarginAccountType = exports.toProgramTreasuryMovementType = exports.TreasuryMovementType = exports.toProgramMovementType = exports.MovementType = exports.ProgramAccountType = exports.MarginType = exports.positionEquals = exports.orderEquals = exports.toProductKind = exports.Kind = exports.fromProgramTriggerDirection = exports.toProgramTriggerDirection = exports.fromProgramSide = exports.toProgramSide = exports.UserCallbackType = exports.TriggerDirection = exports.Side = exports.toProgramSelfTradeBehavior = exports.SelfTradeBehavior = exports.fromProgramOrderType = exports.toProgramOrderType = exports.OrderType = exports.PythDummyWallet = exports.DummyWallet = void 0;
const web3_js_1 = require("@solana/web3.js");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const _1 = require(".");
const constants = __importStar(require("./constants"));
class DummyWallet {
    constructor() { }
    async signTransaction(_tx) {
        throw Error("Not supported by dummy wallet!");
    }
    async signAllTransactions(_txs) {
        throw Error("Not supported by dummy wallet!");
    }
    get publicKey() {
        throw Error("Not supported by dummy wallet!");
    }
}
exports.DummyWallet = DummyWallet;
class PythDummyWallet {
    constructor() { }
    async signTransaction(_tx) {
        throw Error("Not supported by dummy wallet!");
    }
    async signAllTransactions(txs) {
        throw Error("Not supported by dummy wallet!");
    }
    get publicKey() {
        return web3_js_1.PublicKey.default;
    }
}
exports.PythDummyWallet = PythDummyWallet;
var OrderType;
(function (OrderType) {
    OrderType[OrderType["LIMIT"] = 0] = "LIMIT";
    OrderType[OrderType["POSTONLY"] = 1] = "POSTONLY";
    OrderType[OrderType["FILLORKILL"] = 2] = "FILLORKILL";
    OrderType[OrderType["IMMEDIATEORCANCEL"] = 3] = "IMMEDIATEORCANCEL";
    OrderType[OrderType["POSTONLYSLIDE"] = 4] = "POSTONLYSLIDE";
    OrderType[OrderType["POSTONLYFRONT"] = 5] = "POSTONLYFRONT";
})(OrderType = exports.OrderType || (exports.OrderType = {}));
function toProgramOrderType(orderType) {
    if (orderType == OrderType.LIMIT)
        return { limit: {} };
    if (orderType == OrderType.POSTONLY)
        return { postOnly: {} };
    if (orderType == OrderType.FILLORKILL)
        return { fillOrKill: {} };
    if (orderType == OrderType.IMMEDIATEORCANCEL)
        return { immediateOrCancel: {} };
    if (orderType == OrderType.POSTONLYSLIDE)
        return { postOnlySlide: {} };
    if (orderType == OrderType.POSTONLYFRONT)
        return { postOnlyFront: {} };
}
exports.toProgramOrderType = toProgramOrderType;
function fromProgramOrderType(orderType) {
    if ((0, utils_1.objectEquals)(orderType, { limit: {} }))
        return OrderType.LIMIT;
    if ((0, utils_1.objectEquals)(orderType, { postOnly: {} }))
        return OrderType.POSTONLY;
    if ((0, utils_1.objectEquals)(orderType, { fillOrKill: {} }))
        return OrderType.FILLORKILL;
    if ((0, utils_1.objectEquals)(orderType, { immediateOrCancel: {} }))
        return OrderType.IMMEDIATEORCANCEL;
    if ((0, utils_1.objectEquals)(orderType, { postOnlySlide: {} }))
        return OrderType.POSTONLYSLIDE;
    if ((0, utils_1.objectEquals)(orderType, { postOnlyFront: {} }))
        return OrderType.POSTONLYFRONT;
}
exports.fromProgramOrderType = fromProgramOrderType;
var SelfTradeBehavior;
(function (SelfTradeBehavior) {
    SelfTradeBehavior[SelfTradeBehavior["CANCELPROVIDE"] = 0] = "CANCELPROVIDE";
    SelfTradeBehavior[SelfTradeBehavior["ABORTTRANSACTION"] = 1] = "ABORTTRANSACTION";
})(SelfTradeBehavior = exports.SelfTradeBehavior || (exports.SelfTradeBehavior = {}));
function toProgramSelfTradeBehavior(behavior) {
    if (behavior == SelfTradeBehavior.CANCELPROVIDE)
        return { cancelProvide: {} };
    if (behavior == SelfTradeBehavior.ABORTTRANSACTION)
        return { abortTransaction: {} };
}
exports.toProgramSelfTradeBehavior = toProgramSelfTradeBehavior;
var Side;
(function (Side) {
    Side[Side["BID"] = 0] = "BID";
    Side[Side["ASK"] = 1] = "ASK";
})(Side = exports.Side || (exports.Side = {}));
var TriggerDirection;
(function (TriggerDirection) {
    TriggerDirection[TriggerDirection["UNINITIALIZED"] = 0] = "UNINITIALIZED";
    TriggerDirection[TriggerDirection["LESSTHANOREQUAL"] = 1] = "LESSTHANOREQUAL";
    TriggerDirection[TriggerDirection["GREATERTHANOREQUAL"] = 2] = "GREATERTHANOREQUAL";
})(TriggerDirection = exports.TriggerDirection || (exports.TriggerDirection = {}));
var UserCallbackType;
(function (UserCallbackType) {
    UserCallbackType[UserCallbackType["POLLUPDATE"] = 0] = "POLLUPDATE";
    UserCallbackType[UserCallbackType["MARGINACCOUNTCHANGE"] = 1] = "MARGINACCOUNTCHANGE";
    UserCallbackType[UserCallbackType["SPREADACCOUNTCHANGE"] = 2] = "SPREADACCOUNTCHANGE";
    UserCallbackType[UserCallbackType["CROSSMARGINACCOUNTCHANGE"] = 3] = "CROSSMARGINACCOUNTCHANGE";
})(UserCallbackType = exports.UserCallbackType || (exports.UserCallbackType = {}));
function toProgramSide(side) {
    if (side == Side.BID)
        return { bid: {} };
    if (side == Side.ASK)
        return { ask: {} };
    throw Error("Invalid side");
}
exports.toProgramSide = toProgramSide;
function fromProgramSide(side) {
    if ((0, utils_1.objectEquals)(side, { bid: {} })) {
        return Side.BID;
    }
    if ((0, utils_1.objectEquals)(side, { ask: {} })) {
        return Side.ASK;
    }
    throw Error("Invalid program side!");
}
exports.fromProgramSide = fromProgramSide;
function toProgramTriggerDirection(triggerDirection) {
    if (triggerDirection == TriggerDirection.UNINITIALIZED)
        return { uninitialized: {} };
    if (triggerDirection == TriggerDirection.LESSTHANOREQUAL)
        return { lessThanOrEqual: {} };
    if (triggerDirection == TriggerDirection.GREATERTHANOREQUAL)
        return { greaterThanOrEqual: {} };
    throw Error("Invalid triggerDirection");
}
exports.toProgramTriggerDirection = toProgramTriggerDirection;
function fromProgramTriggerDirection(triggerDirection) {
    if ((0, utils_1.objectEquals)(triggerDirection, { uninitialized: {} })) {
        return TriggerDirection.UNINITIALIZED;
    }
    if ((0, utils_1.objectEquals)(triggerDirection, { lessThanOrEqual: {} })) {
        return TriggerDirection.LESSTHANOREQUAL;
    }
    if ((0, utils_1.objectEquals)(triggerDirection, { greaterThanOrEqual: {} })) {
        return TriggerDirection.GREATERTHANOREQUAL;
    }
    throw Error("Invalid program triggerDirection!");
}
exports.fromProgramTriggerDirection = fromProgramTriggerDirection;
var Kind;
(function (Kind) {
    Kind["UNINITIALIZED"] = "uninitialized";
    Kind["CALL"] = "call";
    Kind["PUT"] = "put";
    Kind["FUTURE"] = "future";
    Kind["PERP"] = "perp";
})(Kind = exports.Kind || (exports.Kind = {}));
function toProductKind(kind) {
    if (Object.keys(kind).includes(Kind.CALL))
        return Kind.CALL;
    if (Object.keys(kind).includes(Kind.PUT))
        return Kind.PUT;
    if (Object.keys(kind).includes(Kind.FUTURE))
        return Kind.FUTURE;
    if (Object.keys(kind).includes(Kind.PERP))
        return Kind.PERP;
    // We don't expect uninitialized.
    throw Error("Invalid product type");
}
exports.toProductKind = toProductKind;
function orderEquals(a, b, cmpOrderId = false) {
    let orderIdMatch = true;
    if (cmpOrderId) {
        orderIdMatch = a.orderId.eq(b.orderId);
    }
    return (a.marketIndex === b.marketIndex &&
        a.market.equals(b.market) &&
        a.price === b.price &&
        a.size === b.size &&
        a.side === b.side &&
        a.tifOffset === b.tifOffset &&
        a.asset === b.asset &&
        orderIdMatch);
}
exports.orderEquals = orderEquals;
function positionEquals(a, b) {
    return (a.marketIndex === b.marketIndex &&
        a.market.equals(b.market) &&
        a.size === b.size &&
        a.costOfTrades === b.costOfTrades);
}
exports.positionEquals = positionEquals;
var MarginType;
(function (MarginType) {
    /**
     * Margin for orders.
     */
    MarginType["INITIAL"] = "initial";
    /**
     * Margin for positions.
     */
    MarginType["MAINTENANCE"] = "maintenance";
})(MarginType = exports.MarginType || (exports.MarginType = {}));
var ProgramAccountType;
(function (ProgramAccountType) {
    ProgramAccountType["CrossMarginAccountManager"] = "CrossMarginAccountManager";
    ProgramAccountType["CrossMarginAccount"] = "CrossMarginAccount";
    ProgramAccountType["MarginAccount"] = "MarginAccount";
    ProgramAccountType["SpreadAccount"] = "SpreadAccount";
    ProgramAccountType["ZetaGroup"] = "ZetaGroup";
    ProgramAccountType["Greeks"] = "Greeks";
    ProgramAccountType["PerpSyncQueue"] = "PerpSyncQueue";
    ProgramAccountType["State"] = "State";
    ProgramAccountType["Pricing"] = "Pricing";
})(ProgramAccountType = exports.ProgramAccountType || (exports.ProgramAccountType = {}));
var MovementType;
(function (MovementType) {
    MovementType[MovementType["LOCK"] = 1] = "LOCK";
    MovementType[MovementType["UNLOCK"] = 2] = "UNLOCK";
})(MovementType = exports.MovementType || (exports.MovementType = {}));
function toProgramMovementType(movementType) {
    if (movementType == MovementType.LOCK)
        return { lock: {} };
    if (movementType == MovementType.UNLOCK)
        return { unlock: {} };
    throw Error("Invalid movement type");
}
exports.toProgramMovementType = toProgramMovementType;
var TreasuryMovementType;
(function (TreasuryMovementType) {
    TreasuryMovementType[TreasuryMovementType["TO_TREASURY_FROM_INSURANCE"] = 1] = "TO_TREASURY_FROM_INSURANCE";
    TreasuryMovementType[TreasuryMovementType["TO_INSURANCE_FROM_TREASURY"] = 2] = "TO_INSURANCE_FROM_TREASURY";
    TreasuryMovementType[TreasuryMovementType["TO_TREASURY_FROM_REFERRALS_REWARDS"] = 3] = "TO_TREASURY_FROM_REFERRALS_REWARDS";
    TreasuryMovementType[TreasuryMovementType["TO_REFERRALS_REWARDS_FROM_TREASURY"] = 4] = "TO_REFERRALS_REWARDS_FROM_TREASURY";
})(TreasuryMovementType = exports.TreasuryMovementType || (exports.TreasuryMovementType = {}));
function toProgramTreasuryMovementType(treasuryMovementType) {
    if (treasuryMovementType == TreasuryMovementType.TO_TREASURY_FROM_INSURANCE)
        return { toTreasuryFromInsurance: {} };
    if (treasuryMovementType == TreasuryMovementType.TO_INSURANCE_FROM_TREASURY)
        return { toInsuranceFromTreasury: {} };
    if (treasuryMovementType ==
        TreasuryMovementType.TO_TREASURY_FROM_REFERRALS_REWARDS)
        return { toTreasuryFromReferralsRewards: {} };
    if (treasuryMovementType ==
        TreasuryMovementType.TO_REFERRALS_REWARDS_FROM_TREASURY)
        return { toReferralsRewardsFromTreasury: {} };
    throw Error("Invalid treasury movement type");
}
exports.toProgramTreasuryMovementType = toProgramTreasuryMovementType;
function fromProgramMarginAccountType(accountType) {
    if ((0, utils_1.objectEquals)(accountType, { normal: {} })) {
        return constants_1.MarginAccountType.NORMAL;
    }
    if ((0, utils_1.objectEquals)(accountType, { marketMaker: {} })) {
        return constants_1.MarginAccountType.MARKET_MAKER;
    }
    if ((0, utils_1.objectEquals)(accountType, { marketMakerT0: {} })) {
        return constants_1.MarginAccountType.MARKET_MAKER_T0;
    }
    if ((0, utils_1.objectEquals)(accountType, { marketMakerT1: {} })) {
        return constants_1.MarginAccountType.MARKET_MAKER_T1;
    }
    if ((0, utils_1.objectEquals)(accountType, { marketMakerT2: {} })) {
        return constants_1.MarginAccountType.MARKET_MAKER_T2;
    }
    if ((0, utils_1.objectEquals)(accountType, { marketMakerT3: {} })) {
        return constants_1.MarginAccountType.MARKET_MAKER_T3;
    }
    if ((0, utils_1.objectEquals)(accountType, { marketMakerT4: {} })) {
        return constants_1.MarginAccountType.MARKET_MAKER_T4;
    }
    if ((0, utils_1.objectEquals)(accountType, { marketMakerT5: {} })) {
        return constants_1.MarginAccountType.MARKET_MAKER_T5;
    }
    if ((0, utils_1.objectEquals)(accountType, { marketMakerT6: {} })) {
        return constants_1.MarginAccountType.MARKET_MAKER_T6;
    }
    if ((0, utils_1.objectEquals)(accountType, { marketMakerT7: {} })) {
        return constants_1.MarginAccountType.MARKET_MAKER_T7;
    }
    if ((0, utils_1.objectEquals)(accountType, { marketMakerT8: {} })) {
        return constants_1.MarginAccountType.MARKET_MAKER_T8;
    }
    if ((0, utils_1.objectEquals)(accountType, { marketMakerT9: {} })) {
        return constants_1.MarginAccountType.MARKET_MAKER_T9;
    }
    if ((0, utils_1.objectEquals)(accountType, { normalT1: {} })) {
        return constants_1.MarginAccountType.NORMAL_T1;
    }
    if ((0, utils_1.objectEquals)(accountType, { normalT2: {} })) {
        return constants_1.MarginAccountType.NORMAL_T2;
    }
    if ((0, utils_1.objectEquals)(accountType, { normalT3: {} })) {
        return constants_1.MarginAccountType.NORMAL_T3;
    }
    if ((0, utils_1.objectEquals)(accountType, { normalT4: {} })) {
        return constants_1.MarginAccountType.NORMAL_T4;
    }
    if ((0, utils_1.objectEquals)(accountType, { normalT5: {} })) {
        return constants_1.MarginAccountType.NORMAL_T5;
    }
    if ((0, utils_1.objectEquals)(accountType, { normalT6: {} })) {
        return constants_1.MarginAccountType.NORMAL_T6;
    }
    if ((0, utils_1.objectEquals)(accountType, { normalT7: {} })) {
        return constants_1.MarginAccountType.NORMAL_T7;
    }
    if ((0, utils_1.objectEquals)(accountType, { normalT8: {} })) {
        return constants_1.MarginAccountType.NORMAL_T8;
    }
    if ((0, utils_1.objectEquals)(accountType, { normalT9: {} })) {
        return constants_1.MarginAccountType.NORMAL_T9;
    }
    if ((0, utils_1.objectEquals)(accountType, { withdrawOnly: {} })) {
        return constants_1.MarginAccountType.WITHDRAW_ONLY;
    }
    throw Error("Invalid margin account type");
}
exports.fromProgramMarginAccountType = fromProgramMarginAccountType;
function toProgramMarginAccountType(accountType) {
    if (accountType == constants_1.MarginAccountType.NORMAL) {
        return { normal: {} };
    }
    if (accountType == constants_1.MarginAccountType.MARKET_MAKER) {
        return { marketMaker: {} };
    }
    if (accountType == constants_1.MarginAccountType.MARKET_MAKER_T0) {
        return { marketMakerT0: {} };
    }
    if (accountType == constants_1.MarginAccountType.MARKET_MAKER_T1) {
        return { marketMakerT1: {} };
    }
    if (accountType == constants_1.MarginAccountType.MARKET_MAKER_T2) {
        return { marketMakerT2: {} };
    }
    if (accountType == constants_1.MarginAccountType.MARKET_MAKER_T3) {
        return { marketMakerT3: {} };
    }
    if (accountType == constants_1.MarginAccountType.MARKET_MAKER_T4) {
        return { marketMakerT4: {} };
    }
    if (accountType == constants_1.MarginAccountType.MARKET_MAKER_T5) {
        return { marketMakerT5: {} };
    }
    if (accountType == constants_1.MarginAccountType.MARKET_MAKER_T6) {
        return { marketMakerT6: {} };
    }
    if (accountType == constants_1.MarginAccountType.MARKET_MAKER_T7) {
        return { marketMakerT7: {} };
    }
    if (accountType == constants_1.MarginAccountType.MARKET_MAKER_T8) {
        return { marketMakerT8: {} };
    }
    if (accountType == constants_1.MarginAccountType.MARKET_MAKER_T9) {
        return { marketMakerT9: {} };
    }
    if (accountType == constants_1.MarginAccountType.NORMAL_T1) {
        return { normalT1: {} };
    }
    if (accountType == constants_1.MarginAccountType.NORMAL_T2) {
        return { normalT2: {} };
    }
    if (accountType == constants_1.MarginAccountType.NORMAL_T3) {
        return { normalT3: {} };
    }
    if (accountType == constants_1.MarginAccountType.NORMAL_T4) {
        return { normalT4: {} };
    }
    if (accountType == constants_1.MarginAccountType.NORMAL_T5) {
        return { normalT5: {} };
    }
    if (accountType == constants_1.MarginAccountType.NORMAL_T6) {
        return { normalT6: {} };
    }
    if (accountType == constants_1.MarginAccountType.NORMAL_T7) {
        return { normalT7: {} };
    }
    if (accountType == constants_1.MarginAccountType.NORMAL_T8) {
        return { normalT8: {} };
    }
    if (accountType == constants_1.MarginAccountType.NORMAL_T9) {
        return { normalT9: {} };
    }
    if (accountType == constants_1.MarginAccountType.WITHDRAW_ONLY) {
        return { withdrawOnly: {} };
    }
    throw Error("Invalid margin account type");
}
exports.toProgramMarginAccountType = toProgramMarginAccountType;
function isMarketMaker(account) {
    try {
        return (fromProgramMarginAccountType(account.accountType) ==
            constants_1.MarginAccountType.MARKET_MAKER ||
            fromProgramMarginAccountType(account.accountType) ==
                constants_1.MarginAccountType.MARKET_MAKER_T0 ||
            fromProgramMarginAccountType(account.accountType) ==
                constants_1.MarginAccountType.MARKET_MAKER_T1 ||
            fromProgramMarginAccountType(account.accountType) ==
                constants_1.MarginAccountType.MARKET_MAKER_T2 ||
            fromProgramMarginAccountType(account.accountType) ==
                constants_1.MarginAccountType.MARKET_MAKER_T3 ||
            fromProgramMarginAccountType(account.accountType) ==
                constants_1.MarginAccountType.MARKET_MAKER_T4 ||
            fromProgramMarginAccountType(account.accountType) ==
                constants_1.MarginAccountType.MARKET_MAKER_T5 ||
            fromProgramMarginAccountType(account.accountType) ==
                constants_1.MarginAccountType.MARKET_MAKER_T6 ||
            fromProgramMarginAccountType(account.accountType) ==
                constants_1.MarginAccountType.MARKET_MAKER_T7 ||
            fromProgramMarginAccountType(account.accountType) ==
                constants_1.MarginAccountType.MARKET_MAKER_T8 ||
            fromProgramMarginAccountType(account.accountType) ==
                constants_1.MarginAccountType.MARKET_MAKER_T9);
    }
    catch (e) {
        return false;
    }
}
exports.isMarketMaker = isMarketMaker;
var OrderCompleteType;
(function (OrderCompleteType) {
    OrderCompleteType[OrderCompleteType["CANCEL"] = 0] = "CANCEL";
    OrderCompleteType[OrderCompleteType["FILL"] = 1] = "FILL";
    OrderCompleteType[OrderCompleteType["BOOTED"] = 2] = "BOOTED";
})(OrderCompleteType = exports.OrderCompleteType || (exports.OrderCompleteType = {}));
function fromProgramOrderCompleteType(orderCompleteType) {
    if ((0, utils_1.objectEquals)(orderCompleteType, { cancel: {} })) {
        return OrderCompleteType.CANCEL;
    }
    if ((0, utils_1.objectEquals)(orderCompleteType, { fill: {} })) {
        return OrderCompleteType.FILL;
    }
    if ((0, utils_1.objectEquals)(orderCompleteType, { booted: {} })) {
        return OrderCompleteType.BOOTED;
    }
    throw Error("Invalid order complete type");
}
exports.fromProgramOrderCompleteType = fromProgramOrderCompleteType;
function getDefaultTriggerDirection(side) {
    return side == Side.BID
        ? TriggerDirection.LESSTHANOREQUAL
        : TriggerDirection.GREATERTHANOREQUAL;
}
exports.getDefaultTriggerDirection = getDefaultTriggerDirection;
function defaultTriggerOrderOptions() {
    return {
        reduceOnly: true,
        tag: constants.DEFAULT_ORDER_TAG,
        blockhash: undefined,
    };
}
exports.defaultTriggerOrderOptions = defaultTriggerOrderOptions;
function defaultOrderOptions() {
    return {
        tifOptions: {
            expiryOffset: undefined,
            expiryTs: undefined,
        },
        orderType: OrderType.LIMIT,
        reduceOnly: false,
        clientOrderId: 0,
        tag: constants.DEFAULT_ORDER_TAG,
        blockhash: undefined,
    };
}
exports.defaultOrderOptions = defaultOrderOptions;
function defaultLoadExchangeConfig(network, connection, opts = _1.utils.defaultCommitment(), throttleMs = 0, loadFromStore = false, orderbookConnection = undefined, orderbookAssetSubscriptionOverride = undefined, TIFBufferSeconds = undefined, loadAssets = undefined) {
    return {
        network,
        connection,
        orderbookConnection,
        orderbookAssetSubscriptionOverride,
        opts,
        throttleMs,
        loadFromStore,
        TIFBufferSeconds,
        loadAssets,
    };
}
exports.defaultLoadExchangeConfig = defaultLoadExchangeConfig;
var AirdropCommunity;
(function (AirdropCommunity) {
    AirdropCommunity[AirdropCommunity["UNASSIGNED"] = 0] = "UNASSIGNED";
    AirdropCommunity[AirdropCommunity["JUP"] = 1] = "JUP";
    AirdropCommunity[AirdropCommunity["PYTH"] = 2] = "PYTH";
    AirdropCommunity[AirdropCommunity["DEBRIDGE"] = 3] = "DEBRIDGE";
    AirdropCommunity[AirdropCommunity["SUPERTEAM"] = 4] = "SUPERTEAM";
    AirdropCommunity[AirdropCommunity["MADLADS"] = 5] = "MADLADS";
    AirdropCommunity[AirdropCommunity["TENSORIANS"] = 6] = "TENSORIANS";
    AirdropCommunity[AirdropCommunity["ASSETDASH"] = 7] = "ASSETDASH";
})(AirdropCommunity = exports.AirdropCommunity || (exports.AirdropCommunity = {}));
