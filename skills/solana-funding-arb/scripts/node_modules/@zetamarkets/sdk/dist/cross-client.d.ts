import * as anchor from "@zetamarkets/anchor";
import { BN } from "@zetamarkets/anchor";
import { Asset } from "./constants";
import { CrossMarginAccount, CrossMarginAccountManager, ProductLedger } from "./program-types";
import { PublicKey, TransactionSignature, Connection, TransactionInstruction, ConfirmOptions } from "@solana/web3.js";
import * as types from "./types";
import { EventType } from "./events";
import { programTypes } from ".";
export declare class CrossClient {
    /**
     * Anchor provider instance.
     */
    get provider(): anchor.AnchorProvider;
    get connection(): Connection;
    private _provider;
    /**
     * Client margin account address.
     */
    get publicKey(): PublicKey;
    /**
     * Timer id from SetInterval.
     */
    private _pollIntervalId;
    get delegatorKey(): PublicKey;
    private _delegatorKey;
    get useVersionedTxs(): boolean;
    private _useVersionedTxs;
    get txRetryAmount(): number;
    private _txRetryAmount;
    /**
     * Client usdc account address.
     */
    get usdcAccountAddress(): PublicKey;
    private _usdcAccountAddress;
    /**
     * whitelist deposit account.
     */
    get whitelistDepositAddress(): PublicKey | undefined;
    private _whitelistDepositAddress;
    /**
     * whitelist trading fees account.
     */
    get whitelistTradingFeesAddress(): PublicKey | undefined;
    private _whitelistTradingFeesAddress;
    /**
     * The listener for trade v3 events.
     */
    private _tradeEventV3Listener;
    /**
     * The listener for OrderComplete events.
     */
    private _orderCompleteEventListener;
    /**
     * Stores the user margin account state.
     */
    get account(): CrossMarginAccount | null;
    private _account;
    /**
     * CrossClient margin account address.
     */
    get accountAddress(): PublicKey;
    private _accountAddress;
    /**
     * Stores the user margin account manager state.
     */
    get accountManager(): CrossMarginAccountManager | null;
    private _accountManager;
    /**
     * CrossClient margin account manager address.
     */
    get accountManagerAddress(): PublicKey;
    private _accountManagerAddress;
    /**
     * User open order addresses.
     * If a user hasn't initialized it, it is set to PublicKey.default
     */
    get openOrdersAccounts(): PublicKey[];
    private _openOrdersAccounts;
    /**
     * Returns a list of the user's current orders, not including trigger orders
     */
    get orders(): Map<Asset, types.Order[]>;
    private _orders;
    /**
     * Returns a list of the user's current trigger orders.
     */
    get triggerOrders(): Map<Asset, types.TriggerOrder[]>;
    private _triggerOrders;
    /**
     * Returns a list of user current margin account positions.
     */
    get positions(): Map<Asset, types.Position[]>;
    private _positions;
    /**
     * Index in CrossMarginAccountManager
     */
    get subaccountIndex(): number;
    private _subaccountIndex;
    /**
     * The subscription id for the margin account subscription.
     */
    private _accountSubscriptionId;
    /**
     * The subscription id for the margin account manager subscription.
     */
    private _accountManagerSubscriptionId;
    /**
     * Last update timestamp.
     */
    private _lastUpdateTimestamp;
    /**
     * Pending update.
     */
    private _pendingUpdate;
    /**
     * The context slot of the pending update.
     */
    private _pendingUpdateSlot;
    /**
     * Polling interval.
     */
    get pollInterval(): number;
    set pollInterval(interval: number);
    private _pollInterval;
    /**
     * User passed callback on load, stored for polling.
     */
    private _callback;
    private _updatingState;
    private _updatingStateTimestamp;
    private constructor();
    /**
     * Returns a new instance of CrossClient, based off state in the Exchange singleton.
     * Requires the Exchange to be in a valid state to succeed.
     *
     * @param throttle    Defaults to false.
     *                    If set to false, margin account callbacks will also call
     *                    `updateState` instead of waiting for the poll.
     */
    static load(connection: Connection, wallet: types.Wallet, opts?: ConfirmOptions, callback?: (asset: Asset, type: EventType, slot: number, data: any) => void, throttle?: boolean, delegator?: PublicKey, useVersionedTxs?: boolean, txRetryAmount?: number, subaccountIndex?: number): Promise<CrossClient>;
    pollUpdate(): Promise<void>;
    private toggleUpdateState;
    private checkResetUpdatingState;
    /**
     * Polls the margin account for the latest state.
     */
    updateState(fetch?: boolean, force?: boolean): Promise<number>;
    setUseVersionedTxs(useVersionedTxs: boolean): void;
    setTxRetryAmount(txRetryAmount: number): void;
    /**
     * @param timerInterval   desired interval for client polling.
     */
    private setPolling;
    private usdcAccountCheck;
    findUserMarginAccounts(): Promise<{
        addresses: PublicKey[];
        accounts: programTypes.MarginAccount[];
    }>;
    cleanupMarginAccounts(): Promise<TransactionSignature[]>;
    initializeReferrerAccount(id: string): Promise<TransactionSignature>;
    migrateToCrossMarginAccount(referrer?: PublicKey): Promise<TransactionSignature[]>;
    initializeAccounts(referrerId?: string): Promise<TransactionSignature>;
    /**
     * @param amount  the native amount to deposit (6 decimals fixed point)
     * @param referrerId the referrer's ID to use in initializeCrossMarginAccountManager (only used when creating a new account)
     */
    deposit(amount: number, referrerId?: string): Promise<TransactionSignature>;
    getAccountState(): types.CrossMarginAccountState;
    /**
     * Closes a CrossClient's account
     */
    closeAccount(): Promise<TransactionSignature>;
    /**
     * Closes a CrossClient's account
     */
    closeAccountManager(): Promise<TransactionSignature>;
    /**
     * Closes the CrossMarginAccount and CrossMarginAccountManager in one transaction
     */
    closeAccountAndManager(): Promise<TransactionSignature>;
    /**
     * @param amount  the native amount to withdraw (6 dp)
     */
    withdraw(amount: number): Promise<TransactionSignature>;
    /**
     * Withdraws the entirety of the CrossClient's margin account and then closes it.
     * Useful for only closing one subaccount.
     */
    withdrawAndCloseAccount(): Promise<TransactionSignature>;
    /**
     * Withdraws the entirety of the CrossClient's margin account and then closes it.
     * Useful for closing the main account and everything
     */
    withdrawAndCloseAccountAndCloseManager(): Promise<TransactionSignature>;
    hasReferrerAccounts(): Promise<boolean>;
    remakeReferrerAccounts(id: string): Promise<TransactionSignature>;
    closeReferrerAccounts(): Promise<TransactionSignature>;
    /**
     * Places an order on a zeta perp market.
     * @param price           the native price of the order (6 d.p as integer)
     * @param size            the quantity of the order (3 d.p)
     * @param side            the side of the order. bid / ask
     * @param orderType       the type of the order. limit / ioc / post-only
     * @param clientOrderId   optional: CrossClient order id (non 0 value)
     * @param tag             optional: the string tag corresponding to who is inserting
     * NOTE: If duplicate CrossClient order ids are used, after a cancel order,
     * to cancel the second order with the same CrossClient order id,
     * you may need to crank the corresponding event queue to flush that order id
     * from the user open orders account before cancelling the second order.
     * (Depending on the order in which the order was cancelled).
     */
    placeOrder(asset: Asset, price: number, size: number, side: types.Side, options?: types.OrderOptions, preIxs?: TransactionInstruction[]): Promise<TransactionSignature>;
    /**
     * Find the next available bit to store a trigger order (0 to 127)
     * @param startIndex optional, the index from which to start looking (0 to 127)
     * @returns the first available bit (0 to 127)
     */
    findAvailableTriggerOrderBit(startIndex?: number): number;
    placeTimestampTriggerOrder(asset: Asset, orderPrice: number, triggerTime: anchor.BN, size: number, side: types.Side, orderType: types.OrderType, options?: types.TriggerOrderOptions): Promise<TransactionSignature>;
    placePriceTriggerOrder(asset: Asset, orderPrice: number, triggerPrice: number, size: number, side: types.Side, orderType: types.OrderType, options?: types.TriggerOrderOptions, triggerDirection?: types.TriggerDirection): Promise<TransactionSignature>;
    private placeTriggerOrder;
    createPlaceTriggerOrderIx(asset: Asset, orderPrice: number, size: number, side: types.Side, triggerPrice: number, triggerDirection: types.TriggerDirection, triggerTimestamp: anchor.BN, orderType: types.OrderType, triggerOrderBit: number, options?: types.TriggerOrderOptions): TransactionInstruction;
    /**
     * Close all positions using market orders
     * @param orderPrices Manual override for what price to send, decimal format
     */
    closeAllPositions(orderPrices: Map<Asset, number>): Promise<string[]>;
    cancelAllTriggerOrders(asset: Asset | undefined): Promise<string[]>;
    cancelAllTriggerOrdersAndPlaceOrder(asset: Asset, price: number, size: number, side: types.Side, options?: types.OrderOptions): Promise<string[]>;
    private createCancelTriggerOrdersTxs;
    cancelTriggerOrder(orderIndex: number): Promise<string>;
    editTimestampTriggerOrder(orderIndex: number, newOrderPrice: number, newTriggerTime: anchor.BN, newSize: number, newSide: types.Side, newOrderType: types.OrderType, newOptions?: types.TriggerOrderOptions): Promise<TransactionSignature>;
    takeTriggerOrder(orderIndex: number, asset: Asset, orderMarginAccount: PublicKey): Promise<string>;
    editPriceTriggerOrder(orderIndex: number, newOrderPrice: number, newTriggerPrice: number, newSize: number, newSide: types.Side, newDirection: types.TriggerDirection, newOrderType: types.OrderType, newOptions?: types.TriggerOrderOptions): Promise<TransactionSignature>;
    private editTriggerOrder;
    chooseAirdropCommunity(community: types.AirdropCommunity): Promise<TransactionSignature>;
    editDelegatedPubkey(delegatedPubkey: PublicKey): Promise<TransactionSignature>;
    createCancelOrderNoErrorInstruction(asset: Asset, orderId: BN, side: types.Side): TransactionInstruction;
    cancelMarketOrders(asset: Asset): Promise<TransactionSignature>;
    cancelAllMarketOrders(): Promise<TransactionSignature[]>;
    createCancelAllMarketOrdersInstruction(asset: Asset): TransactionInstruction;
    cancelMultipleOrders(cancelArguments: types.CancelArgs[]): Promise<TransactionSignature[]>;
    cancelMultipleOrdersNoError(cancelArguments: types.CancelArgs[]): Promise<TransactionSignature[]>;
    createPlacePerpOrderInstruction(asset: Asset, price: number, size: number, side: types.Side, options?: types.OrderOptions): TransactionInstruction;
    createPlaceMultiOrderInstruction(asset: Asset, bids: types.PlaceMultiOrderArg[], asks: types.PlaceMultiOrderArg[], orderType: types.OrderType): TransactionInstruction;
    /**
     * Cancels a user order by orderId
     * @param asset     the asset of the order to be cancelled.
     * @param orderId    the order id of the order.
     * @param side       the side of the order. bid / ask.
     */
    cancelOrder(asset: Asset, orderId: BN, side: types.Side): Promise<TransactionSignature>;
    /**
     * Cancels a user order by CrossClient order id.
     * It will only cancel the FIRST
     * @param asset          the asset of the order to be cancelled.
     * @param clientOrderId   the CrossClient order id of the order. (Non zero value).
     */
    cancelOrderByClientOrderId(asset: Asset, clientOrderId: number): Promise<TransactionSignature>;
    /**
     * Cancels a user order by orderId and atomically places an order
     * @param asset     the asset of the order to be cancelled.
     * @param orderId    the order id of the order.
     * @param cancelSide       the side of the order. bid / ask.
     * @param newOrderPrice  the native price of the order (6 d.p) as integer
     * @param newOrderSize   the quantity of the order (3 d.p) as integer
     * @param newOrderSide   the side of the order. bid / ask
     * @param newOrderType   the type of the order, limit / ioc / post-only
     * @param clientOrderId   optional: CrossClient order id (non 0 value)
     * @param newOrderTag     optional: the string tag corresponding to who is inserting. Default "SDK", max 4 length
     */
    cancelAndPlaceOrder(asset: Asset, orderId: BN, cancelSide: types.Side, newOrderPrice: number, newOrderSize: number, newOrderSide: types.Side, options?: types.OrderOptions): Promise<TransactionSignature>;
    /**
     * Cancels a user order by CrossClient order id and atomically places an order by new CrossClient order id.
     * @param asset                  the asset of the order to be cancelled and new order.
     * @param cancelClientOrderId     the CrossClient order id of the order to be cancelled.
     * @param newOrderPrice           the native price of the order (6 d.p) as integer
     * @param newOrderSize            the quantity of the order (3 d.p) as integer
     * @param newOrderSide            the side of the order. bid / ask
     * @param newOrderType            the type of the order, limit / ioc / post-only
     * @param newOrderClientOrderId   the CrossClient order id for the new order
     * @param newOrderTag     optional: the string tag corresponding to who is inserting. Default "SDK", max 4 length
     */
    cancelAndPlaceOrderByClientOrderId(asset: Asset, cancelClientOrderId: number, newOrderPrice: number, newOrderSize: number, newOrderSide: types.Side, newOptions?: types.OrderOptions): Promise<TransactionSignature>;
    /**
     * Cancels a user order by client order id and atomically places an order by new client order id.
     * Uses the 'NoError' cancel instruction, so a failed cancellation won't prohibit the placeOrder
     * @param asset                  the asset of the order to be cancelled and new order.
     * @param cancelClientOrderId     the client order id of the order to be cancelled.
     * @param newOrderPrice           the native price of the order (6 d.p) as integer
     * @param newOrderSize            the quantity of the order (3 d.p) as integer
     * @param newOrderSide            the side of the order. bid / ask
     * @param newOrderType            the type of the order, limit / ioc / post-only
     * @param newOrderClientOrderId   the client order id for the new order
     * @param newOrderTag     optional: the string tag corresponding to who is inserting. Default "SDK", max 4 length
     */
    replaceByClientOrderId(asset: Asset, cancelClientOrderId: number, newOrderPrice: number, newOrderSize: number, newOrderSide: types.Side, newOptions?: types.OrderOptions): Promise<TransactionSignature>;
    /**
     * Initializes a user open orders account for a given market.
     * This is handled atomically by place order but can be used by CrossClients to initialize it independent of placing an order.
     */
    initializeOpenOrdersAccount(asset: Asset): Promise<TransactionSignature>;
    /**
     * Closes a user open orders account for a given market.
     */
    closeOpenOrdersAccount(asset: Asset): Promise<TransactionSignature>;
    /**
     * Closes multiple user open orders account for a given set of markets.
     * Cannot pass in multiple of the same market address
     */
    closeMultipleOpenOrdersAccount(assets: Asset[]): Promise<TransactionSignature[]>;
    /**
     * Calls force cancel on another user's orders
     * @param asset  Asset to cancel orders on
     * @param marginAccountToCancel Users to be force-cancelled's margin account
     */
    forceCancelOrderByOrderId(asset: Asset, marginAccountToCancel: PublicKey, orderId: BN, side: types.Side): Promise<TransactionSignature>;
    /**
     * Calls force cancel on another user's orders
     * @param asset  Asset to cancel orders on
     * @param marginAccountToCancel Users to be force-cancelled's margin account
     */
    forceCancelOrders(asset: Asset, marginAccountToCancel: PublicKey): Promise<TransactionSignature>;
    /**
     * Calls liquidate on another user
     * @param market
     * @param liquidatedMarginAccount
     * @param size                        the quantity of the order (3 d.p)
     */
    liquidate(asset: Asset, liquidatedMarginAccount: PublicKey, size: number): Promise<TransactionSignature>;
    /**
     * Instruction builder for cancelAllOrders()
     * Returns a list of instructions cancelling all of this CrossClient's orders
     */
    cancelAllOrdersIxs(asset: Asset): TransactionInstruction[];
    /**
     * Instruction builder for cancelAllOrdersNoError()
     * Returns a list of instructions cancelling all of this CrossClient's orders
     */
    cancelAllOrdersNoErrorIxs(asset: Asset): TransactionInstruction[];
    /**
     * Cancels all active user orders
     */
    cancelAllOrders(asset?: Asset): Promise<TransactionSignature[]>;
    /**
     * Cancels all active user orders
     */
    cancelAllOrdersNoError(asset?: Asset): Promise<TransactionSignature[]>;
    getTriggerOrder(triggerOrderBit: number): types.TriggerOrder;
    getTriggerOrders(asset: Asset): types.TriggerOrder[];
    getOrders(asset: Asset): types.Order[];
    getPositions(asset: Asset): types.Position[];
    updateOpenOrdersSync(): void;
    updateOrders(): Promise<void>;
    private updatePositions;
    private updateOpenOrdersAddresses;
    /**
     * Getter functions for raw user margin account state.
     */
    /**
     * @param asset - market asset.
     * @param decimal - whether to convert to readable decimal.
     */
    getPositionSize(asset: Asset, decimal?: boolean): number;
    /**
     * @param asset - market asset.
     * @param decimal - whether to convert to readable decimal.
     */
    getCostOfTrades(asset: Asset, decimal?: boolean): number;
    /**
     * @param asset - market asset.
     * @param decimal - whether to convert to readable decimal.
     */
    getOpeningOrders(asset: Asset, side: types.Side, decimal?: boolean): number;
    /**
     * @param asset - market asset.
     * @param decimal - whether to convert to readable decimal.
     */
    getClosingOrders(asset: Asset, decimal?: boolean): number;
    /**
     * Getter function to grab the correct product ledger because perps is separate
     */
    getProductLedger(asset: Asset): ProductLedger;
    /**
     * Closes the CrossClient websocket subscription to margin account.
     */
    close(): Promise<void>;
    private delegatedCheck;
}
