"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSerumVaultOwnerAndNonce = exports.getReferrerAliasAddress = exports.getReferralAccountAddress = exports.getReferrerAccountAddress = exports.getCombinedSocializedLossAccount = exports.getSocializedLossAccount = exports.getMarketUninitialized = exports.getTriggerOrder = exports.getSpreadAccount = exports.getMarginAccount = exports.getCrossMarginAccount = exports.getCrossMarginAccountManager = exports.getReferrerPubkeyAccount = exports.getReferrerIdAccount = exports.getQuoteMint = exports.getBaseMint = exports.getMarketIndexes = exports.getPerpSyncQueue = exports.getGreeks = exports.getFlexUnderlyingMint = exports.getFlexUnderlying = exports.getUnderlying = exports.getPricing = exports.getZetaGroup = exports.getUserWhitelistTradingFeesAccount = exports.getUserWhitelistInsuranceAccount = exports.getUserWhitelistDepositAccount = exports.getUserInsuranceDepositAccount = exports.getZetaReferralsRewardsWallet = exports.getZetaTreasuryWallet = exports.getZetaCombinedInsuranceVault = exports.getZetaInsuranceVault = exports.getZetaVault = exports.getSerumVault = exports.getCombinedVault = exports.getVault = exports.getMintAuthority = exports.getSerumAuthority = exports.getOpenOrdersMap = exports.getCrossOpenOrdersMap = exports.createCrossOpenOrdersAddress = exports.createOpenOrdersAddress = exports.getOpenOrders = exports.getCrossOpenOrders = exports.getSettlement = exports.getMarketNode = exports.getState = exports.getNativeMinLotSize = exports.getDecimalMinLotSize = exports.getNativeTickSize = void 0;
exports.toAssets = exports.getOrCreateKeypair = exports.calculateMovementFees = exports.burnVaultTokens = exports.settleAndBurnVaultTokens = exports.getAllOpenOrdersAccounts = exports.getAllProgramAccountAddresses = exports.writeKeypair = exports.getCancelAllIxs = exports.getMutMarketAccounts = exports.pruneExpiredTIFOrdersV2 = exports.pruneExpiredTIFOrders = exports.createCrankMarketIx = exports.crankMarket = exports.cleanZetaMarketHalted = exports.cleanZetaMarkets = exports.getMarginFromOpenOrders = exports.getCrossMarginFromOpenOrders = exports.getAccountFromOpenOrders = exports.displayState = exports.getGreeksIndex = exports.sleep = exports.splitIxsIntoTx = exports.getSeqNumFromSerumOrderKey = exports.getPriceFromSerumOrderKey = exports.getClockData = exports.readBigInt64LE = exports.parseError = exports.processTransaction = exports.processVersionedTransaction = exports.sendJitoTxCaught = exports.sendRawTransactionCaught = exports.processTransactionJito = exports.processVersionedTransactionJito = exports.processTransactionBloxroute = exports.simulateTransaction = exports.getTradeEventsFromTx = exports.commitmentConfig = exports.defaultCommitment = exports.getAssociatedTokenAddress = exports.getTokenAccountInfo = exports.getTokenMint = exports.convertDecimalToNativeLotSize = exports.convertNativeLotSizeToDecimal = exports.convertNativeBNToDecimal = exports.convertNativeIntegerToDecimal = exports.getTradeEventPrice = exports.convertDecimalToNativeInteger = exports.sortMarketKeys = exports.sortOpenOrderKeys = void 0;
exports.getFeeBps = exports.getFeeTier = exports.calculateTakeTriggerOrderExecutionPrice = exports.initializeZetaMarkets = exports.deepCloneCrossMarginAccount = exports.checkLiquidity = exports.isAffiliateCodeAvailable = exports.median = exports.isFlexUnderlying = exports.getUnderlyingMint = exports.getZetaLutArr = exports.isOrderExpired = exports.getTIFOffset = exports.getProductLedger = exports.executeTriggerOrder = exports.applyPerpFunding = exports.fetchReferralId = exports.convertBufferToTrimmedString = exports.objectEquals = void 0;
const anchor = __importStar(require("@zetamarkets/anchor"));
const web3_js_1 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
const buffer_layout_1 = __importDefault(require("buffer-layout"));
const BN = anchor.BN;
const bs58 = __importStar(require("bs58"));
const assets_1 = require("./assets");
const fs = __importStar(require("fs"));
const constants = __importStar(require("./constants"));
const errors = __importStar(require("./errors"));
const exchange_1 = require("./exchange");
const types = __importStar(require("./types"));
const instructions = __importStar(require("./program-instructions"));
const _1 = require(".");
const network_1 = require("./network");
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const os = __importStar(require("os"));
const market_1 = require("./serum/market");
const axios_1 = __importDefault(require("axios"));
function getNativeTickSize(asset) {
    return exchange_1.exchange.state.tickSizes[_1.assets.assetToIndex(asset)];
}
exports.getNativeTickSize = getNativeTickSize;
function getDecimalMinLotSize(asset) {
    return getNativeMinLotSize(asset) / 10 ** constants.POSITION_PRECISION;
}
exports.getDecimalMinLotSize = getDecimalMinLotSize;
function getNativeMinLotSize(asset) {
    let assetIndex = _1.assets.assetToIndex(asset);
    if (exchange_1.exchange.state != undefined) {
        return exchange_1.exchange.state.minLotSizes[assetIndex];
    }
    return 1000;
}
exports.getNativeMinLotSize = getNativeMinLotSize;
function getState(programId) {
    return anchor.web3.PublicKey.findProgramAddressSync([Buffer.from(anchor.utils.bytes.utf8.encode("state"))], programId);
}
exports.getState = getState;
function getMarketNode(programId, zetaGroup, marketIndex) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("market-node")),
        zetaGroup.toBuffer(),
        Buffer.from([marketIndex]),
    ], programId);
}
exports.getMarketNode = getMarketNode;
function getSettlement(programId, underlyingMint, expirationTs) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("settlement")),
        underlyingMint.toBuffer(),
        expirationTs.toArrayLike(Buffer, "le", 8),
    ], programId);
}
exports.getSettlement = getSettlement;
function getCrossOpenOrders(programId, market, account) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("cross-open-orders")),
        constants.DEX_PID[exchange_1.exchange.network].toBuffer(),
        market.toBuffer(),
        account.toBuffer(),
    ], programId);
}
exports.getCrossOpenOrders = getCrossOpenOrders;
function getOpenOrders(programId, market, userKey) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("open-orders")),
        constants.DEX_PID[exchange_1.exchange.network].toBuffer(),
        market.toBuffer(),
        userKey.toBuffer(),
    ], programId);
}
exports.getOpenOrders = getOpenOrders;
function createOpenOrdersAddress(programId, market, userKey, nonce) {
    return web3_js_1.PublicKey.createProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("open-orders")),
        constants.DEX_PID[exchange_1.exchange.network].toBuffer(),
        market.toBuffer(),
        userKey.toBuffer(),
        Buffer.from([nonce]),
    ], programId);
}
exports.createOpenOrdersAddress = createOpenOrdersAddress;
function createCrossOpenOrdersAddress(programId, market, userKey, nonce) {
    return web3_js_1.PublicKey.createProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("cross-open-orders")),
        constants.DEX_PID[exchange_1.exchange.network].toBuffer(),
        market.toBuffer(),
        userKey.toBuffer(),
        Buffer.from([nonce]),
    ], programId);
}
exports.createCrossOpenOrdersAddress = createCrossOpenOrdersAddress;
function getCrossOpenOrdersMap(programId, openOrders) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("cross-open-orders-map")),
        openOrders.toBuffer(),
    ], programId);
}
exports.getCrossOpenOrdersMap = getCrossOpenOrdersMap;
function getOpenOrdersMap(programId, openOrders) {
    return anchor.web3.PublicKey.findProgramAddressSync([openOrders.toBuffer()], programId);
}
exports.getOpenOrdersMap = getOpenOrdersMap;
function getSerumAuthority(programId) {
    return anchor.web3.PublicKey.findProgramAddressSync([Buffer.from(anchor.utils.bytes.utf8.encode("serum"))], programId);
}
exports.getSerumAuthority = getSerumAuthority;
function getMintAuthority(programId) {
    return anchor.web3.PublicKey.findProgramAddressSync([Buffer.from(anchor.utils.bytes.utf8.encode("mint-auth"))], programId);
}
exports.getMintAuthority = getMintAuthority;
function getVault(programId, zetaGroup) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("vault")),
        zetaGroup.toBuffer(),
    ], programId);
}
exports.getVault = getVault;
function getCombinedVault(programId) {
    return anchor.web3.PublicKey.findProgramAddressSync([Buffer.from(anchor.utils.bytes.utf8.encode("combined-vault"))], programId);
}
exports.getCombinedVault = getCombinedVault;
function getSerumVault(programId, mint) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("serum-vault")),
        mint.toBuffer(),
    ], programId);
}
exports.getSerumVault = getSerumVault;
function getZetaVault(programId, mint) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("zeta-vault")),
        mint.toBuffer(),
    ], programId);
}
exports.getZetaVault = getZetaVault;
function getZetaInsuranceVault(programId, zetaGroup) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("zeta-insurance-vault")),
        zetaGroup.toBuffer(),
    ], programId);
}
exports.getZetaInsuranceVault = getZetaInsuranceVault;
function getZetaCombinedInsuranceVault(programId) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("zeta-combined-insurance-vault")),
    ], programId);
}
exports.getZetaCombinedInsuranceVault = getZetaCombinedInsuranceVault;
function getZetaTreasuryWallet(programId, mint) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("zeta-treasury-wallet")),
        mint.toBuffer(),
    ], programId);
}
exports.getZetaTreasuryWallet = getZetaTreasuryWallet;
function getZetaReferralsRewardsWallet(programId, mint) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("zeta-referrals-rewards-wallet")),
        mint.toBuffer(),
    ], programId);
}
exports.getZetaReferralsRewardsWallet = getZetaReferralsRewardsWallet;
function getUserInsuranceDepositAccount(programId, userKey) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("combined-user-insurance-deposit")),
        userKey.toBuffer(),
    ], programId);
}
exports.getUserInsuranceDepositAccount = getUserInsuranceDepositAccount;
function getUserWhitelistDepositAccount(programId, userKey) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("whitelist-deposit")),
        userKey.toBuffer(),
    ], programId);
}
exports.getUserWhitelistDepositAccount = getUserWhitelistDepositAccount;
function getUserWhitelistInsuranceAccount(programId, userKey) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("whitelist-insurance")),
        userKey.toBuffer(),
    ], programId);
}
exports.getUserWhitelistInsuranceAccount = getUserWhitelistInsuranceAccount;
function getUserWhitelistTradingFeesAccount(programId, userKey) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("whitelist-trading-fees")),
        userKey.toBuffer(),
    ], programId);
}
exports.getUserWhitelistTradingFeesAccount = getUserWhitelistTradingFeesAccount;
function getZetaGroup(programId, mint) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("zeta-group")),
        mint.toBuffer(),
    ], programId);
}
exports.getZetaGroup = getZetaGroup;
function getPricing(programId) {
    return anchor.web3.PublicKey.findProgramAddressSync([Buffer.from(anchor.utils.bytes.utf8.encode("pricing"))], programId);
}
exports.getPricing = getPricing;
function getUnderlying(programId, underlyingIndex) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("underlying")),
        Buffer.from([underlyingIndex]),
    ], programId);
}
exports.getUnderlying = getUnderlying;
function getFlexUnderlying(programId, underlyingIndex) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("flex-underlying")),
        Buffer.from([underlyingIndex]),
    ], programId);
}
exports.getFlexUnderlying = getFlexUnderlying;
function getFlexUnderlyingMint(programId, underlyingIndex) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("flex-underlying-mint")),
        Buffer.from([underlyingIndex]),
    ], programId);
}
exports.getFlexUnderlyingMint = getFlexUnderlyingMint;
function getGreeks(programId, zetaGroup) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("greeks")),
        zetaGroup.toBuffer(),
    ], programId);
}
exports.getGreeks = getGreeks;
function getPerpSyncQueue(programId, zetaGroup) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("perp-sync-queue")),
        zetaGroup.toBuffer(),
    ], programId);
}
exports.getPerpSyncQueue = getPerpSyncQueue;
function getMarketIndexes(programId, zetaGroup) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("market-indexes")),
        zetaGroup.toBuffer(),
    ], programId);
}
exports.getMarketIndexes = getMarketIndexes;
function getBaseMint(programId, market) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("base-mint")),
        market.toBuffer(),
    ], programId);
}
exports.getBaseMint = getBaseMint;
function getQuoteMint(programId, market) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("quote-mint")),
        market.toBuffer(),
    ], programId);
}
exports.getQuoteMint = getQuoteMint;
function getReferrerIdAccount(programId, id) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("referrer-id-account")),
        Buffer.from(id.replace(/[\0]+$/g, "")),
    ], programId);
}
exports.getReferrerIdAccount = getReferrerIdAccount;
function getReferrerPubkeyAccount(programId, userKey) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("referrer-pubkey-account")),
        userKey.toBuffer(),
    ], programId);
}
exports.getReferrerPubkeyAccount = getReferrerPubkeyAccount;
function getCrossMarginAccountManager(programId, userKey) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("cross-margin-manager")),
        userKey.toBuffer(),
    ], programId);
}
exports.getCrossMarginAccountManager = getCrossMarginAccountManager;
function getCrossMarginAccount(programId, userKey, seedNumber) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("cross-margin")),
        userKey.toBuffer(),
        seedNumber,
    ], programId);
}
exports.getCrossMarginAccount = getCrossMarginAccount;
function getMarginAccount(programId, zetaGroup, userKey) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("margin")),
        zetaGroup.toBuffer(),
        userKey.toBuffer(),
    ], programId);
}
exports.getMarginAccount = getMarginAccount;
function getSpreadAccount(programId, zetaGroup, userKey) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("spread")),
        zetaGroup.toBuffer(),
        userKey.toBuffer(),
    ], programId);
}
exports.getSpreadAccount = getSpreadAccount;
function getTriggerOrder(programId, marginAccount, triggerOrderBit) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("trigger-order")),
        marginAccount.toBuffer(),
        triggerOrderBit,
    ], programId);
}
exports.getTriggerOrder = getTriggerOrder;
function getMarketUninitialized(programId, zetaGroup, marketIndex) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("market")),
        zetaGroup.toBuffer(),
        Buffer.from([marketIndex]),
    ], programId);
}
exports.getMarketUninitialized = getMarketUninitialized;
function getSocializedLossAccount(programId, zetaGroup) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("socialized-loss")),
        zetaGroup.toBuffer(),
    ], programId);
}
exports.getSocializedLossAccount = getSocializedLossAccount;
function getCombinedSocializedLossAccount(programId) {
    return anchor.web3.PublicKey.findProgramAddressSync([Buffer.from(anchor.utils.bytes.utf8.encode("combined-socialized-loss"))], programId);
}
exports.getCombinedSocializedLossAccount = getCombinedSocializedLossAccount;
function getReferrerAccountAddress(programId, referrer) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("referrer")),
        referrer.toBuffer(),
    ], programId);
}
exports.getReferrerAccountAddress = getReferrerAccountAddress;
function getReferralAccountAddress(programId, user) {
    return anchor.web3.PublicKey.findProgramAddressSync([Buffer.from(anchor.utils.bytes.utf8.encode("referral")), user.toBuffer()], programId);
}
exports.getReferralAccountAddress = getReferralAccountAddress;
function getReferrerAliasAddress(programId, alias) {
    return anchor.web3.PublicKey.findProgramAddressSync([
        Buffer.from(anchor.utils.bytes.utf8.encode("referrer-alias")),
        Buffer.from(alias),
    ], programId);
}
exports.getReferrerAliasAddress = getReferrerAliasAddress;
/**
 * Returns the expected PDA by serum to own the serum vault
 * Serum uses a u64 as nonce which is not the same as
 * normal solana PDA convention and goes 0 -> 255
 */
function getSerumVaultOwnerAndNonce(market, dexPid) {
    const nonce = new BN(0);
    while (nonce.toNumber() < 255) {
        try {
            const vaultOwner = web3_js_1.PublicKey.createProgramAddressSync([market.toBuffer(), nonce.toArrayLike(Buffer, "le", 8)], dexPid);
            return [vaultOwner, nonce];
        }
        catch (e) {
            nonce.iaddn(1);
        }
    }
    throw new Error("Unable to find nonce");
}
exports.getSerumVaultOwnerAndNonce = getSerumVaultOwnerAndNonce;
/**
 * Serum interprets publickeys as [u64; 4]
 * Which requires swap64 sorting.
 */
function sortOpenOrderKeys(keys) {
    return keys.sort((a, b) => a.toBuffer().swap64().compare(b.toBuffer().swap64()));
}
exports.sortOpenOrderKeys = sortOpenOrderKeys;
/**
 * Normal sorting of keys
 */
function sortMarketKeys(keys) {
    return keys.sort((a, b) => a.toBuffer().compare(b.toBuffer()));
}
exports.sortMarketKeys = sortMarketKeys;
/**
 * Converts a decimal number to native fixed point integer of precision 6.
 * roundingFactor argument will round the result to the nearest <roundingFactor>. Default is 100.
 */
function convertDecimalToNativeInteger(amount, roundingFactor = constants.MIN_NATIVE_TICK_SIZE) {
    return (Math.trunc((amount * Math.pow(10, constants.PLATFORM_PRECISION)) / roundingFactor) * roundingFactor);
}
exports.convertDecimalToNativeInteger = convertDecimalToNativeInteger;
/**
 * Returns the trade event price. This may return a number that
 * does not divide perfectly by tick size (0.0001) if your order traded
 * against orders at different prices.
 */
function getTradeEventPrice(event) {
    let decimalCostOfTrades = convertNativeBNToDecimal(event.costOfTrades);
    let decimalSize = convertNativeLotSizeToDecimal(event.size.toNumber());
    return decimalCostOfTrades / decimalSize;
}
exports.getTradeEventPrice = getTradeEventPrice;
/**
 * Converts a native fixed point integer of precision 6 to decimal.
 */
function convertNativeIntegerToDecimal(amount) {
    return amount / Math.pow(10, constants.PLATFORM_PRECISION);
}
exports.convertNativeIntegerToDecimal = convertNativeIntegerToDecimal;
/**
 * Converts a program BN to a decimal number.
 * @param pricing   whether the BN you are converting is a pricing BN - defaults to false.
 */
function convertNativeBNToDecimal(number, precision = constants.PLATFORM_PRECISION) {
    // Note 53 bits - max number is slightly larger than 9 * 10 ^ 9 with decimals.
    let precisionBn = new anchor.BN(Math.pow(10, precision));
    return (
    // Integer
    number.div(precisionBn).toNumber() +
        // Decimal
        number.mod(precisionBn).toNumber() / precisionBn.toNumber());
}
exports.convertNativeBNToDecimal = convertNativeBNToDecimal;
/**
 * Converts a native lot size where 1 unit = 0.001 lots to human readable decimal
 * @param amount
 */
function convertNativeLotSizeToDecimal(amount) {
    return amount / Math.pow(10, constants.POSITION_PRECISION);
}
exports.convertNativeLotSizeToDecimal = convertNativeLotSizeToDecimal;
/**
 * Converts a human readable decimal to a native lot size where 1 unit = 0.001 lots
 * @param amount
 */
function convertDecimalToNativeLotSize(amount, roundingFactor = constants.MIN_NATIVE_MIN_LOT_SIZE) {
    return (Math.trunc((amount * Math.pow(10, constants.POSITION_PRECISION)) / roundingFactor) * roundingFactor);
}
exports.convertDecimalToNativeLotSize = convertDecimalToNativeLotSize;
async function getTokenMint(connection, key) {
    let info = await getTokenAccountInfo(connection, key);
    return new web3_js_1.PublicKey(info.mint);
}
exports.getTokenMint = getTokenMint;
/**
 * Copied from @solana/spl-token but their version requires you to
 * construct a Token object which is completely unnecessary
 */
async function getTokenAccountInfo(connection, key) {
    let info = await connection.getAccountInfo(key);
    if (info === null) {
        throw Error(`Token account ${key.toString()} doesn't exist.`);
    }
    if (info.data.length != spl_token_1.AccountLayout.span) {
        throw new Error(`Invalid account size`);
    }
    const data = Buffer.from(info.data);
    const accountInfo = spl_token_1.AccountLayout.decode(data);
    accountInfo.address = key;
    accountInfo.mint = new web3_js_1.PublicKey(accountInfo.mint);
    accountInfo.owner = new web3_js_1.PublicKey(accountInfo.owner);
    accountInfo.amount = spl_token_1.u64.fromBuffer(accountInfo.amount);
    if (accountInfo.delegateOption === 0) {
        accountInfo.delegate = null;
        accountInfo.delegatedAmount = 0;
    }
    else {
        accountInfo.delegate = new web3_js_1.PublicKey(accountInfo.delegate);
        accountInfo.delegatedAmount = spl_token_1.u64.fromBuffer(accountInfo.delegatedAmount);
    }
    accountInfo.isInitialized = accountInfo.state !== 0;
    accountInfo.isFrozen = accountInfo.state === 2;
    if (accountInfo.isNativeOption === 1) {
        accountInfo.rentExemptReserve = spl_token_1.u64.fromBuffer(accountInfo.isNative);
        accountInfo.isNative = true;
    }
    else {
        accountInfo.rentExemptReserve = null;
        accountInfo.isNative = false;
    }
    if (accountInfo.closeAuthorityOption === 0) {
        accountInfo.closeAuthority = null;
    }
    else {
        accountInfo.closeAuthority = new web3_js_1.PublicKey(accountInfo.closeAuthority);
    }
    return accountInfo;
}
exports.getTokenAccountInfo = getTokenAccountInfo;
function getAssociatedTokenAddress(mint, owner) {
    return web3_js_1.PublicKey.findProgramAddressSync([owner.toBuffer(), spl_token_1.TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()], spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID)[0];
}
exports.getAssociatedTokenAddress = getAssociatedTokenAddress;
function defaultCommitment() {
    return {
        skipPreflight: false,
        preflightCommitment: "confirmed",
        commitment: "confirmed",
    };
}
exports.defaultCommitment = defaultCommitment;
function commitmentConfig(commitment) {
    let opts = {
        skipPreflight: false,
        preflightCommitment: commitment,
        commitment,
    };
    if (exchange_1.exchange.maxRpcRetries != undefined) {
        opts["maxRetries"] = exchange_1.exchange.maxRpcRetries;
    }
    return opts;
}
exports.commitmentConfig = commitmentConfig;
async function getTradeEventsFromTx(txId, marginAccountFilter) {
    const parser = new anchor.EventParser(exchange_1.exchange.programId, exchange_1.exchange.program.coder);
    const tx = await exchange_1.exchange.connection.getTransaction(txId, {
        commitment: "confirmed",
        maxSupportedTransactionVersion: 0,
    });
    const logs = tx.meta.logMessages;
    if (!logs) {
        console.warn("No logs found");
        return;
    }
    const events = parser.parseLogs(logs);
    const tradeEvents = [];
    for (const event of events) {
        if (event.name.startsWith("TradeEvent")) {
            if (marginAccountFilter &&
                event.data.marginAccount.toString() != marginAccountFilter.toString()) {
                continue;
            }
            tradeEvents.push(event.data);
        }
    }
    return tradeEvents;
}
exports.getTradeEventsFromTx = getTradeEventsFromTx;
async function simulateTransaction(provider, tx) {
    let response;
    try {
        response = await provider.simulate(tx);
    }
    catch (err) {
        let parsedErr = parseError(err);
        throw parsedErr;
    }
    if (response === undefined) {
        throw new Error("Unable to simulate transaction");
    }
    const logs = response.logs;
    if (!logs) {
        throw new Error("Simulated logs not found");
    }
    let parser = new anchor.EventParser(exchange_1.exchange.programId, exchange_1.exchange.program.coder);
    let events = parser.parseLogs(response.logs);
    return { events, raw: logs };
}
exports.simulateTransaction = simulateTransaction;
function txConfirmationCheck(expectedLevel, currentLevel) {
    const levels = ["processed", "confirmed", "finalized"];
    if (levels.indexOf(expectedLevel) == -1) {
        throw Error("Please use commitment level 'processed', 'confirmed' or 'finalized'");
    }
    if (levels.indexOf(currentLevel) >= levels.indexOf(expectedLevel)) {
        return true;
    }
    return false;
}
async function processTransactionBloxroute(httpProvider, anchorProvider, tx, tip, blockhash, retries, skipConfirmation) {
    tx.add(web3_js_1.SystemProgram.transfer({
        fromPubkey: anchorProvider.publicKey,
        toPubkey: new web3_js_1.PublicKey("HWEoBxYs7ssKuudEjzjmpfJVX7Dvi7wescFsVx2L5yoY" // Trader API tip wallet
        ),
        lamports: tip,
    }));
    if (exchange_1.exchange.priorityFee != 0) {
        tx.instructions.unshift(web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
            microLamports: Math.round(exchange_1.exchange.priorityFee),
        }));
    }
    let failures = 0;
    while (true) {
        let recentBlockhash = blockhash !== null && blockhash !== void 0 ? blockhash : (await exchange_1.exchange.getCachedBlockhash());
        let v0Tx = new web3_js_1.VersionedTransaction(new web3_js_1.TransactionMessage({
            payerKey: anchorProvider.publicKey,
            recentBlockhash: recentBlockhash.blockhash,
            instructions: tx.instructions,
        }).compileToV0Message(getZetaLutArr()));
        v0Tx = (await anchorProvider.wallet.signTransaction(v0Tx));
        let rawTx = v0Tx.serialize();
        if (exchange_1.exchange.postSignCallback) {
            await exchange_1.exchange.postSignCallback();
        }
        let txSig;
        try {
            txSig = (await httpProvider.postSubmitV2({
                transaction: {
                    content: Buffer.from(rawTx).toString("base64"),
                    isCleanup: false,
                },
                skipPreFlight: true,
                frontRunningProtection: false,
            })).signature;
            // Poll the tx confirmation for N seconds
            // Polling is more reliable than websockets using confirmTransaction()
            let currentBlockHeight = 0;
            if (!skipConfirmation) {
                while (currentBlockHeight < recentBlockhash.lastValidBlockHeight) {
                    let status = await anchorProvider.connection.getSignatureStatuses([
                        txSig,
                    ]);
                    currentBlockHeight = await anchorProvider.connection.getBlockHeight(anchorProvider.connection.commitment);
                    if (status.value[0] != null) {
                        if (status.value[0].err != null) {
                            // Gets caught and parsed in the later catch
                            let err = parseInt(status.value[0].err["InstructionError"][1]["Custom"]);
                            throw err;
                        }
                        if (txConfirmationCheck("confirmed", status.value[0].confirmationStatus.toString())) {
                            return txSig;
                        }
                    }
                    await sleep(1500); // Don't spam the RPC
                }
                throw Error(`Transaction ${txSig} was not confirmed`);
            }
            else {
                return txSig;
            }
        }
        catch (err) {
            let parsedErr = parseError(err);
            failures += 1;
            if (!retries || failures > retries) {
                console.log(`txSig: ${txSig} failed. Error = ${parsedErr}`);
                throw parsedErr;
            }
            console.log(`Transaction failed to send. Retrying...`);
            console.log(`failCount=${failures}. error=${parsedErr}`);
        }
    }
}
exports.processTransactionBloxroute = processTransactionBloxroute;
/// Note that you must add in the jito tip instruction before you send this to here
async function processVersionedTransactionJito(provider, tx, signers, opts, blockhash) {
    let recentBlockhash = blockhash !== null && blockhash !== void 0 ? blockhash : (await exchange_1.exchange.getCachedBlockhash());
    tx.sign((signers !== null && signers !== void 0 ? signers : [])
        .filter((s) => s !== undefined)
        .map((kp) => {
        return kp;
    }));
    tx = (await provider.wallet.signTransaction(tx));
    let rawTx = tx.serialize();
    const encodedTx = bs58.encode(rawTx);
    const jitoURL = "https://mainnet.block-engine.jito.wtf/api/v1/transactions";
    const payload = {
        jsonrpc: "2.0",
        id: 1,
        method: "sendTransaction",
        params: [encodedTx],
    };
    let txOpts = opts || commitmentConfig(provider.connection.commitment);
    let txSig;
    if (exchange_1.exchange.postSignCallback) {
        await exchange_1.exchange.postSignCallback();
    }
    try {
        const response = await axios_1.default.post(jitoURL, payload, {
            headers: { "Content-Type": "application/json" },
        });
        txSig = response.data.result;
    }
    catch (error) {
        console.error("Error:", error);
        throw new Error("Jito Bundle Error: cannot send.");
    }
    if (exchange_1.exchange.skipRpcConfirmation) {
        return txSig;
    }
    let currentBlockHeight = await provider.connection.getBlockHeight(provider.connection.commitment);
    while (currentBlockHeight < recentBlockhash.lastValidBlockHeight) {
        // Keep resending to maximise the chance of confirmation
        await provider.connection.sendRawTransaction(rawTx, {
            skipPreflight: true,
            preflightCommitment: provider.connection.commitment,
            maxRetries: 0,
        });
        let status = await provider.connection.getSignatureStatuses([txSig]);
        currentBlockHeight = await provider.connection.getBlockHeight(provider.connection.commitment);
        if (status.value[0] != null) {
            if (status.value[0].err != null) {
                // Gets caught and parsed in the later catch
                let err = parseInt(status.value[0].err["InstructionError"][1]["Custom"]);
                let parsedErr = parseError(err);
                throw parsedErr;
            }
            if (txConfirmationCheck(txOpts.commitment ? txOpts.commitment.toString() : "confirmed", status.value[0].confirmationStatus.toString())) {
                return txSig;
            }
        }
        await sleep(500); // Don't spam the RPC
    }
    throw Error(`Transaction ${txSig} was not confirmed`);
}
exports.processVersionedTransactionJito = processVersionedTransactionJito;
async function processTransactionJito(provider, tx, signers, opts, lutAccs, blockhash) {
    if (exchange_1.exchange.jitoTip == 0) {
        throw Error("Jito bundle tip has not been set.");
    }
    if (exchange_1.exchange.priorityFee != 0) {
        tx.instructions.unshift(web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
            microLamports: Math.round(exchange_1.exchange.priorityFee),
        }));
    }
    tx.instructions.push(web3_js_1.SystemProgram.transfer({
        fromPubkey: exchange_1.exchange.provider.publicKey,
        toPubkey: new web3_js_1.PublicKey("DttWaMuVvTiduZRnguLF7jNxTgiMBZ1hyAumKUiL2KRL" // Jito tip account
        ),
        lamports: exchange_1.exchange.jitoTip, // tip
    }));
    let recentBlockhash = blockhash !== null && blockhash !== void 0 ? blockhash : (await exchange_1.exchange.getCachedBlockhash());
    let vTx = new web3_js_1.VersionedTransaction(new web3_js_1.TransactionMessage({
        payerKey: provider.wallet.publicKey,
        recentBlockhash: recentBlockhash.blockhash,
        instructions: tx.instructions,
    }).compileToV0Message(lutAccs));
    vTx.sign((signers !== null && signers !== void 0 ? signers : [])
        .filter((s) => s !== undefined)
        .map((kp) => {
        return kp;
    }));
    vTx = (await provider.wallet.signTransaction(vTx));
    let rawTx = vTx.serialize();
    const encodedTx = bs58.encode(rawTx);
    const jitoURL = "https://mainnet.block-engine.jito.wtf/api/v1/transactions";
    const payload = {
        jsonrpc: "2.0",
        id: 1,
        method: "sendTransaction",
        params: [encodedTx],
    };
    if (exchange_1.exchange.postSignCallback) {
        await exchange_1.exchange.postSignCallback();
    }
    let txOpts = opts || commitmentConfig(provider.connection.commitment);
    let txSig;
    try {
        const response = await axios_1.default.post(jitoURL, payload, {
            headers: { "Content-Type": "application/json" },
        });
        txSig = response.data.result;
    }
    catch (error) {
        console.error("Error:", error);
        throw new Error("Jito Bundle Error: cannot send.");
    }
    if (exchange_1.exchange.skipRpcConfirmation) {
        return txSig;
    }
    let currentBlockHeight = await provider.connection.getBlockHeight(provider.connection.commitment);
    while (currentBlockHeight < recentBlockhash.lastValidBlockHeight) {
        // Keep resending to maximise the chance of confirmation
        await provider.connection.sendRawTransaction(rawTx, {
            skipPreflight: true,
            preflightCommitment: provider.connection.commitment,
            maxRetries: 0,
        });
        let status = await provider.connection.getSignatureStatuses([txSig]);
        currentBlockHeight = await provider.connection.getBlockHeight(provider.connection.commitment);
        if (status.value[0] != null) {
            if (status.value[0].err != null) {
                // Gets caught and parsed in the later catch
                let err = parseInt(status.value[0].err["InstructionError"][1]["Custom"]);
                let parsedErr = parseError(err);
                throw parsedErr;
            }
            if (txConfirmationCheck(txOpts.commitment ? txOpts.commitment.toString() : "confirmed", status.value[0].confirmationStatus.toString())) {
                return txSig;
            }
        }
        await sleep(500); // Don't spam the RPC
    }
    throw Error(`Transaction ${txSig} was not confirmed`);
}
exports.processTransactionJito = processTransactionJito;
async function sendRawTransactionCaught(con, rawTx) {
    try {
        let txSig = await con.sendRawTransaction(rawTx, {
            skipPreflight: true,
            preflightCommitment: con.commitment,
            maxRetries: 0,
        });
        return txSig;
    }
    catch (e) {
        console.log(`Error sending tx: ${e}`);
    }
}
exports.sendRawTransactionCaught = sendRawTransactionCaught;
async function sendJitoTxCaught(payload) {
    try {
        let response = await axios_1.default.post("https://mainnet.block-engine.jito.wtf/api/v1/transactions", payload, {
            headers: { "Content-Type": "application/json" },
        });
        return response.data.result;
    }
    catch (e) {
        console.log(`Error sending tx: ${e}`);
    }
}
exports.sendJitoTxCaught = sendJitoTxCaught;
async function processVersionedTransaction(provider, tx, signers, opts, blockhash, retries) {
    if (exchange_1.exchange.useJitoBundle) {
        return processVersionedTransactionJito(provider, tx, signers, opts, blockhash);
    }
    let failures = 0;
    while (true) {
        let rawTx;
        let recentBlockhash = blockhash !== null && blockhash !== void 0 ? blockhash : (await exchange_1.exchange.getCachedBlockhash());
        tx.sign((signers !== null && signers !== void 0 ? signers : [])
            .filter((s) => s !== undefined)
            .map((kp) => {
            return kp;
        }));
        tx = (await provider.wallet.signTransaction(tx));
        rawTx = tx.serialize();
        let txOpts = opts || commitmentConfig(provider.connection.commitment);
        let txSig;
        let allConnections = [provider.connection].concat(exchange_1.exchange.doubleDownConnections);
        try {
            // Integration tests don't like the split send + confirm :(
            if (exchange_1.exchange.network == network_1.Network.LOCALNET) {
                return await anchor.sendAndConfirmRawTransaction(provider.connection, rawTx, txOpts);
            }
            let promises = [];
            for (var con of allConnections) {
                promises.push(sendRawTransactionCaught(con, rawTx));
            }
            // Jito's transactions endpoint, not a bundle
            // Might as well send it here for extra success, it's free
            if (exchange_1.exchange.network == network_1.Network.MAINNET) {
                const encodedTx = bs58.encode(rawTx);
                const payload = {
                    jsonrpc: "2.0",
                    id: 1,
                    method: "sendTransaction",
                    params: [encodedTx],
                };
                promises.push(sendJitoTxCaught(payload));
            }
            // All tx sigs are the same
            let txSigs = await Promise.all(promises);
            let txSig = txSigs.find((sig) => typeof sig === "string" && sig.length > 0);
            // Poll the tx confirmation for N seconds
            // Polling is more reliable than websockets using confirmTransaction()
            let currentBlockHeight = 0;
            if (!exchange_1.exchange.skipRpcConfirmation) {
                let resendCounter = 0;
                while (currentBlockHeight <
                    recentBlockhash.lastValidBlockHeight) {
                    // Keep resending to maximise the chance of confirmation
                    resendCounter += 1;
                    if (resendCounter % 4 == 0) {
                        for (var con of allConnections) {
                            promises.push(sendRawTransactionCaught(con, rawTx));
                        }
                        await Promise.race(promises);
                    }
                    let status = await provider.connection.getSignatureStatuses([txSig]);
                    currentBlockHeight = await provider.connection.getBlockHeight(provider.connection.commitment);
                    if (status.value[0] != null) {
                        if (status.value[0].err != null) {
                            // Gets caught and parsed in the later catch
                            let err = parseInt(status.value[0].err["InstructionError"][1]["Custom"]);
                            throw err;
                        }
                        if (txConfirmationCheck(txOpts.commitment ? txOpts.commitment.toString() : "confirmed", status.value[0].confirmationStatus.toString())) {
                            return txSig;
                        }
                    }
                    await sleep(500); // Don't spam the RPC
                }
                throw Error(`Transaction ${txSig} was not confirmed`);
            }
            else {
                return txSig;
            }
        }
        catch (err) {
            let parsedErr = parseError(err);
            failures += 1;
            if (!retries || failures > retries) {
                console.log(`txSig: ${txSig} failed. Error = ${parsedErr}`);
                throw parsedErr;
            }
            console.log(`Transaction failed to send. Retrying...`);
            console.log(`failCount=${failures}. error=${parsedErr}`);
        }
    }
}
exports.processVersionedTransaction = processVersionedTransaction;
async function processTransaction(provider, tx, signers, opts, useLedger = false, lutAccs, blockhash, retries) {
    if (exchange_1.exchange.useJitoBundle) {
        return processTransactionJito(provider, tx, signers, opts, lutAccs, blockhash);
    }
    if (exchange_1.exchange.httpProvider) {
        let txSig = await processTransactionBloxroute(exchange_1.exchange.httpProvider, provider, tx, exchange_1.exchange.tipMultiplier * exchange_1.exchange.priorityFee + 1050, blockhash, retries, exchange_1.exchange.skipRpcConfirmation);
        return txSig;
    }
    let failures = 0;
    while (true) {
        let rawTx;
        if (exchange_1.exchange.priorityFee != 0) {
            tx.instructions.unshift(web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
                microLamports: Math.round(exchange_1.exchange.priorityFee),
            }));
        }
        let recentBlockhash = blockhash !== null && blockhash !== void 0 ? blockhash : (await exchange_1.exchange.getCachedBlockhash());
        if (lutAccs) {
            if (useLedger) {
                throw Error("Ledger does not support versioned transactions");
            }
            let v0Tx = new web3_js_1.VersionedTransaction(new web3_js_1.TransactionMessage({
                payerKey: provider.wallet.publicKey,
                recentBlockhash: recentBlockhash.blockhash,
                instructions: tx.instructions,
            }).compileToV0Message(lutAccs));
            v0Tx.sign((signers !== null && signers !== void 0 ? signers : [])
                .filter((s) => s !== undefined)
                .map((kp) => {
                return kp;
            }));
            v0Tx = (await provider.wallet.signTransaction(v0Tx));
            rawTx = v0Tx.serialize();
        }
        else {
            tx.recentBlockhash = recentBlockhash.blockhash;
            tx.feePayer = useLedger
                ? exchange_1.exchange.ledgerWallet.publicKey
                : provider.wallet.publicKey;
            (signers !== null && signers !== void 0 ? signers : [])
                .filter((s) => s !== undefined)
                .forEach((kp) => {
                tx.partialSign(kp);
            });
            if (useLedger) {
                tx = await exchange_1.exchange.ledgerWallet.signTransaction(tx);
            }
            else {
                tx = (await provider.wallet.signTransaction(tx));
            }
            rawTx = tx.serialize();
        }
        if (exchange_1.exchange.postSignCallback) {
            await exchange_1.exchange.postSignCallback();
        }
        let txOpts = opts || commitmentConfig(provider.connection.commitment);
        let txSig;
        let allConnections = [provider.connection].concat(exchange_1.exchange.doubleDownConnections);
        try {
            // Integration tests don't like the split send + confirm :(
            if (exchange_1.exchange.network == network_1.Network.LOCALNET) {
                return await anchor.sendAndConfirmRawTransaction(provider.connection, rawTx, txOpts);
            }
            let promises = [];
            for (var con of allConnections) {
                promises.push(sendRawTransactionCaught(con, rawTx));
            }
            // Jito's transactions endpoint, not a bundle
            // Might as well send it here for extra success, it's free
            if (exchange_1.exchange.network == network_1.Network.MAINNET) {
                const encodedTx = bs58.encode(rawTx);
                const payload = {
                    jsonrpc: "2.0",
                    id: 1,
                    method: "sendTransaction",
                    params: [encodedTx],
                };
                promises.push(sendJitoTxCaught(payload));
            }
            // All tx sigs are the same
            let txSigs = await Promise.all(promises);
            let txSig = txSigs.find((sig) => typeof sig === "string" && sig.length > 0);
            // Poll the tx confirmation for N seconds
            // Polling is more reliable than websockets using confirmTransaction()
            let currentBlockHeight = 0;
            if (!exchange_1.exchange.skipRpcConfirmation) {
                let resendCounter = 0;
                while (currentBlockHeight <
                    recentBlockhash.lastValidBlockHeight) {
                    // Keep resending to maximise the chance of confirmation
                    resendCounter += 1;
                    if (resendCounter % 4 == 0) {
                        for (var con of allConnections) {
                            promises.push(sendRawTransactionCaught(con, rawTx));
                        }
                        await Promise.race(promises);
                    }
                    let status = await provider.connection.getSignatureStatuses([txSig]);
                    currentBlockHeight = await provider.connection.getBlockHeight(provider.connection.commitment);
                    if (status.value[0] != null) {
                        if (status.value[0].err != null) {
                            // Gets caught and parsed in the later catch
                            let err = parseInt(status.value[0].err["InstructionError"][1]["Custom"]);
                            throw err;
                        }
                        if (txConfirmationCheck(txOpts.commitment ? txOpts.commitment.toString() : "confirmed", status.value[0].confirmationStatus.toString())) {
                            return txSig;
                        }
                    }
                    await sleep(500); // Don't spam the RPC
                }
                throw Error(`Transaction ${txSig} was not confirmed`);
            }
            else {
                return txSig;
            }
        }
        catch (err) {
            let parsedErr = parseError(err);
            failures += 1;
            if (!retries || failures > retries) {
                console.log(`txSig: ${txSig} failed. Error = ${parsedErr}`);
                throw parsedErr;
            }
            console.log(`Transaction failed to send. Retrying...`);
            console.log(`failCount=${failures}. error=${parsedErr}`);
        }
    }
}
exports.processTransaction = processTransaction;
function parseError(err) {
    const anchorError = anchor.AnchorError.parse(err.logs);
    if (anchorError) {
        // Parse Anchor error into another type such that it's consistent.
        return errors.NativeAnchorError.parse(anchorError);
    }
    const programError = anchor.ProgramError.parse(err, errors.idlErrors);
    if (typeof err == typeof 0 && errors.idlErrors.has(err)) {
        return new errors.NativeAnchorError(parseInt(err), errors.idlErrors.get(err), [], []);
    }
    if (programError) {
        return programError;
    }
    let customErr = errors.parseCustomError(err);
    if (customErr != null) {
        return customErr;
    }
    let nativeErr = errors.NativeError.parse(err);
    if (nativeErr != null) {
        return nativeErr;
    }
    if (err.simulationResponse) {
        let simulatedError = anchor.AnchorError.parse(err.simulationResponse.logs);
        if (simulatedError) {
            return errors.NativeAnchorError.parse(simulatedError);
        }
    }
    return err;
}
exports.parseError = parseError;
const uint64 = (property = "uint64") => {
    return buffer_layout_1.default.blob(8, property);
};
const int64 = (property = "int64") => {
    return buffer_layout_1.default.blob(8, property);
};
const SystemClockLayout = buffer_layout_1.default.struct([
    uint64("slot"),
    int64("epochStartTimestamp"),
    uint64("epoch"),
    uint64("leaderScheduleEpoch"),
    int64("unixTimestamp"),
]);
// https://github.com/nodejs/node/blob/v14.17.0/lib/internal/errors.js#L758
const ERR_BUFFER_OUT_OF_BOUNDS = () => new Error("Attempt to access memory outside buffer bounds");
// https://github.com/nodejs/node/blob/v14.17.0/lib/internal/errors.js#L1262
const ERR_OUT_OF_RANGE = (str, range, received) => new Error(`The value of "${str} is out of range. It must be ${range}. Received ${received}`);
// https://github.com/nodejs/node/blob/v14.17.0/lib/internal/errors.js#L968
const ERR_INVALID_ARG_TYPE = (name, expected, actual) => new Error(`The "${name}" argument must be of type ${expected}. Received ${actual}`);
// https://github.com/nodejs/node/blob/v14.17.0/lib/internal/validators.js#L127-L130
function validateNumber(value, name) {
    if (typeof value !== "number")
        throw ERR_INVALID_ARG_TYPE(name, "number", value);
}
// https://github.com/nodejs/node/blob/v14.17.0/lib/internal/buffer.js#L68-L80
function boundsError(value, length) {
    if (Math.floor(value) !== value) {
        validateNumber(value, "offset");
        throw ERR_OUT_OF_RANGE("offset", "an integer", value);
    }
    if (length < 0)
        throw ERR_BUFFER_OUT_OF_BOUNDS();
    throw ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${length}`, value);
}
// https://github.com/nodejs/node/blob/v14.17.0/lib/internal/buffer.js#L129-L145
function readBigInt64LE(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined)
        boundsError(offset, buffer.length - 8);
    // tslint:disable-next-line:no-bitwise
    const val = buffer[offset + 4] +
        buffer[offset + 5] * 2 ** 8 +
        buffer[offset + 6] * 2 ** 16 +
        (last << 24); // Overflow
    return ((BigInt(val) << BigInt(32)) + // tslint:disable-line:no-bitwise
        BigInt(first +
            buffer[++offset] * 2 ** 8 +
            buffer[++offset] * 2 ** 16 +
            buffer[++offset] * 2 ** 24));
}
exports.readBigInt64LE = readBigInt64LE;
function getClockData(accountInfo) {
    let info = SystemClockLayout.decode(accountInfo.data);
    return {
        timestamp: Number(readBigInt64LE(info.unixTimestamp, 0)),
        slot: Number(readBigInt64LE(info.slot, 0)),
    };
}
exports.getClockData = getClockData;
function getPriceFromSerumOrderKey(key) {
    return key.ushrn(64);
}
exports.getPriceFromSerumOrderKey = getPriceFromSerumOrderKey;
function getSeqNumFromSerumOrderKey(key, isBid) {
    let lower = key.maskn(64);
    if (isBid) {
        let x = lower.notn(64);
        return x;
    }
    else {
        return lower;
    }
}
exports.getSeqNumFromSerumOrderKey = getSeqNumFromSerumOrderKey;
function splitIxsIntoTx(ixs, ixsPerTx) {
    let txs = [];
    for (var i = 0; i < ixs.length; i += ixsPerTx) {
        let tx = new web3_js_1.Transaction();
        let slice = ixs.slice(i, i + ixsPerTx);
        for (let j = 0; j < slice.length; j++) {
            tx.add(slice[j]);
        }
        txs.push(tx);
    }
    return txs;
}
exports.splitIxsIntoTx = splitIxsIntoTx;
async function sleep(ms) {
    await new Promise((resolve) => setTimeout(resolve, ms, undefined));
}
exports.sleep = sleep;
/**
 * Given a market index, return the index to access the greeks.productGreeks.
 */
function getGreeksIndex(marketIndex) {
    let expirySeries = Math.floor(marketIndex / constants.PRODUCTS_PER_EXPIRY);
    let modIndex = marketIndex % constants.PRODUCTS_PER_EXPIRY;
    return (expirySeries * constants.NUM_STRIKES + (modIndex % constants.NUM_STRIKES));
}
exports.getGreeksIndex = getGreeksIndex;
function printMarkets(subExchange) {
    let markPrice = subExchange.getMarkPrice();
    console.log(`[MARKET] INDEX: ${constants.PERP_INDEX} MARK_PRICE ${markPrice.toFixed(6)}`);
}
function displayState() {
    let subExchanges = exchange_1.exchange.subExchanges;
    for (var [asset, subExchange] of subExchanges) {
        // Products without expiries, ie perps
        printMarkets(subExchange);
    }
}
exports.displayState = displayState;
// Either margin or cross margin acc
async function getAccountFromOpenOrders(openOrders, asset) {
    let crossOpenOrdersMapInfo = (await exchange_1.exchange.program.account.crossOpenOrdersMap.fetchNullable(getCrossOpenOrdersMap(exchange_1.exchange.programId, openOrders)[0]));
    // If it was a CrossMarginAccount, just proceed
    if (crossOpenOrdersMapInfo != null) {
        return getCrossMarginAccount(exchange_1.exchange.programId, crossOpenOrdersMapInfo.userKey, Uint8Array.from([crossOpenOrdersMapInfo.subaccountIndex]))[0];
    }
    // If it wasn't a CrossMarginAccount, it should be a MarginAccount or error
    let openOrdersMapInfo = (await exchange_1.exchange.program.account.openOrdersMap.fetch(getOpenOrdersMap(exchange_1.exchange.programId, openOrders)[0]));
    return getMarginAccount(exchange_1.exchange.programId, exchange_1.exchange.pricing.zetaGroupKeys[_1.assets.assetToIndex(asset)], openOrdersMapInfo.userKey)[0];
}
exports.getAccountFromOpenOrders = getAccountFromOpenOrders;
async function getCrossMarginFromOpenOrders(openOrders) {
    const [openOrdersMap, _openOrdersMapNonce] = getCrossOpenOrdersMap(exchange_1.exchange.programId, openOrders);
    let openOrdersMapInfo = (await exchange_1.exchange.program.account.crossOpenOrdersMap.fetch(openOrdersMap));
    const [crossMarginAccount, _marginNonce] = getCrossMarginAccount(exchange_1.exchange.programId, openOrdersMapInfo.userKey, Uint8Array.from([openOrdersMapInfo.subaccountIndex]));
    return crossMarginAccount;
}
exports.getCrossMarginFromOpenOrders = getCrossMarginFromOpenOrders;
async function getMarginFromOpenOrders(asset, openOrders, market) {
    const [openOrdersMap, _openOrdersMapNonce] = getOpenOrdersMap(exchange_1.exchange.programId, openOrders);
    let openOrdersMapInfo = (await exchange_1.exchange.program.account.openOrdersMap.fetch(openOrdersMap));
    const [marginAccount, _marginNonce] = getMarginAccount(exchange_1.exchange.programId, market.zetaGroup, openOrdersMapInfo.userKey);
    return marginAccount;
}
exports.getMarginFromOpenOrders = getMarginFromOpenOrders;
async function cleanZetaMarkets(asset, marketAccountTuples) {
    let txs = [];
    for (var i = 0; i < marketAccountTuples.length; i += constants.CLEAN_MARKET_LIMIT) {
        let tx = new web3_js_1.Transaction();
        let slice = marketAccountTuples.slice(i, i + constants.CLEAN_MARKET_LIMIT);
        tx.add(instructions.cleanZetaMarketsIx(asset, slice.flat()));
        txs.push(tx);
    }
    await Promise.all(txs.map(async (tx) => {
        await processTransaction(exchange_1.exchange.provider, tx);
    }));
}
exports.cleanZetaMarkets = cleanZetaMarkets;
async function cleanZetaMarketHalted(asset) {
    let tx = new web3_js_1.Transaction();
    tx.add(instructions.cleanZetaMarketHaltedIx(asset));
    await processTransaction(exchange_1.exchange.provider, tx);
}
exports.cleanZetaMarketHalted = cleanZetaMarketHalted;
/*
 * Allows you to pass in a map that may have cached values for openOrdersAccounts
 * returns true in case where event queue is empty, false if events were cranked
 */
async function crankMarket(asset, openOrdersToMargin, crankLimit) {
    let ix = await createCrankMarketIx(asset, openOrdersToMargin, crankLimit);
    if (ix == null)
        return true;
    let tx = new web3_js_1.Transaction()
        .add(web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
        units: 250000,
    }))
        .add(ix);
    await processTransaction(exchange_1.exchange.provider, tx);
    return false;
}
exports.crankMarket = crankMarket;
async function createCrankMarketIx(asset, openOrdersToMargin, crankLimit) {
    let market = exchange_1.exchange.getPerpMarket(asset);
    let eventQueue = await market.serumMarket.loadEventQueue(exchange_1.exchange.connection);
    if (eventQueue.length == 0) {
        return null;
    }
    const openOrdersSet = new Set();
    // We pass in a couple of extra accounts for perps so the limit is lower
    let limit = constants.CRANK_PERP_ACCOUNT_LIMIT;
    // Manually defined crankLimit will override
    if (crankLimit) {
        limit = crankLimit;
    }
    for (var i = 0; i < eventQueue.length; i++) {
        openOrdersSet.add(eventQueue[i].openOrders.toString());
        if (openOrdersSet.size == limit) {
            break;
        }
    }
    const uniqueOpenOrders = sortOpenOrderKeys([...openOrdersSet].map((s) => new web3_js_1.PublicKey(s)));
    let remainingAccounts = new Array(uniqueOpenOrders.length * 2);
    await Promise.all(uniqueOpenOrders.map(async (openOrders, index) => {
        let marginAccount;
        if (openOrdersToMargin &&
            !openOrdersToMargin.has(openOrders.toBase58())) {
            marginAccount = await getAccountFromOpenOrders(openOrders, asset);
            openOrdersToMargin.set(openOrders.toBase58(), marginAccount);
        }
        else if (openOrdersToMargin &&
            openOrdersToMargin.has(openOrders.toBase58())) {
            marginAccount = openOrdersToMargin.get(openOrders.toBase58());
        }
        else {
            marginAccount = await getAccountFromOpenOrders(openOrders, asset);
        }
        let openOrdersIndex = index * 2;
        remainingAccounts[openOrdersIndex] = {
            pubkey: openOrders,
            isSigner: false,
            isWritable: true,
        };
        remainingAccounts[openOrdersIndex + 1] = {
            pubkey: marginAccount,
            isSigner: false,
            isWritable: true,
        };
    }));
    return instructions.crankMarketIx(asset, market.address, market.serumMarket.eventQueueAddress, constants.DEX_PID[exchange_1.exchange.network], remainingAccounts);
}
exports.createCrankMarketIx = createCrankMarketIx;
/*
 * prune expired TIF orders from a list of market indices.
 */
async function pruneExpiredTIFOrders(asset) {
    let tx = new web3_js_1.Transaction().add(instructions.pruneExpiredTIFOrdersIx(asset));
    return processTransaction(exchange_1.exchange.provider, tx);
}
exports.pruneExpiredTIFOrders = pruneExpiredTIFOrders;
async function pruneExpiredTIFOrdersV2(asset, limit) {
    let tx = new web3_js_1.Transaction().add(instructions.pruneExpiredTIFOrdersIxV2(asset, limit));
    return processTransaction(exchange_1.exchange.provider, tx);
}
exports.pruneExpiredTIFOrdersV2 = pruneExpiredTIFOrdersV2;
function getMutMarketAccounts(asset) {
    let market = exchange_1.exchange.getPerpMarket(asset);
    return [
        { pubkey: market.address, isSigner: false, isWritable: false },
        {
            pubkey: market.serumMarket.bidsAddress,
            isSigner: false,
            isWritable: false,
        },
        {
            pubkey: market.serumMarket.asksAddress,
            isSigner: false,
            isWritable: false,
        },
    ];
}
exports.getMutMarketAccounts = getMutMarketAccounts;
async function getCancelAllIxs(asset, orders, _expiration) {
    let ixs = [];
    await Promise.all(orders.map(async (order) => {
        const [openOrdersMap, _openOrdersMapNonce] = getCrossOpenOrdersMap(exchange_1.exchange.programId, order.owner);
        let openOrdersMapInfo = await exchange_1.exchange.program.account.crossOpenOrdersMap.fetchNullable(openOrdersMap);
        let account;
        // MarginAccount
        if (openOrdersMapInfo == null) {
            const [openOrdersMap, _openOrdersMapNonce] = getOpenOrdersMap(exchange_1.exchange.programId, order.owner);
            let map = (await exchange_1.exchange.program.account.openOrdersMap.fetch(openOrdersMap));
            const [marginAccount, _marginNonce] = getMarginAccount(exchange_1.exchange.programId, exchange_1.exchange.getZetaGroupAddress(asset), map.userKey);
            account = marginAccount;
        }
        // CrossMarginAccount
        else {
            let map = openOrdersMapInfo;
            const [marginAccount, _marginNonce] = getCrossMarginAccount(exchange_1.exchange.programId, map.userKey, Uint8Array.from([map.subaccountIndex]));
            account = marginAccount;
        }
        let ix = instructions.cancelOrderHaltedIx(asset, account, order.owner, order.orderId, order.side);
        ixs.push(ix);
    }));
    return ixs;
}
exports.getCancelAllIxs = getCancelAllIxs;
function writeKeypair(filename, keypair) {
    let secret = "[" + keypair.secretKey.toString() + "]";
    fs.writeFileSync(filename, secret);
}
exports.writeKeypair = writeKeypair;
async function getAllProgramAccountAddresses(accountType, asset = undefined) {
    let filters = [
        {
            memcmp: {
                offset: 0,
                bytes: bs58.encode(anchor.BorshAccountsCoder.accountDiscriminator(accountType)),
            },
        },
    ];
    if (asset != undefined) {
        let assetOffset = 0;
        // From the account itself in account.rs
        if (accountType == types.ProgramAccountType.MarginAccount) {
            assetOffset = constants.MARGIN_ACCOUNT_ASSET_OFFSET;
        }
        else if (accountType == types.ProgramAccountType.SpreadAccount) {
            assetOffset = constants.SPREAD_ACCOUNT_ASSET_OFFSET;
        }
        filters.push({
            memcmp: {
                offset: assetOffset,
                bytes: bs58.encode([_1.assets.assetToIndex(asset)]),
            },
        });
    }
    let noDataAccounts = await exchange_1.exchange.provider.connection.getProgramAccounts(exchange_1.exchange.programId, {
        commitment: exchange_1.exchange.provider.connection.commitment,
        dataSlice: {
            offset: 0,
            length: 0,
        },
        filters: filters,
    });
    let pubkeys = [];
    for (let i = 0; i < noDataAccounts.length; i++) {
        pubkeys.push(noDataAccounts[i].pubkey);
    }
    return pubkeys;
}
exports.getAllProgramAccountAddresses = getAllProgramAccountAddresses;
async function getAllOpenOrdersAccounts(asset, accountLimit) {
    let allOpenOrders = [];
    let market = exchange_1.exchange.getPerpMarket(asset);
    let maPubkeys = await getAllProgramAccountAddresses(types.ProgramAccountType.MarginAccount);
    // Randomly grab the first N only to avoid overloading the app
    maPubkeys.sort(() => Math.random() - 0.5);
    if (accountLimit) {
        maPubkeys = maPubkeys.slice(0, accountLimit);
    }
    console.log(`${maPubkeys.length} marginAccounts pubkeys`);
    let marginAccounts = [];
    for (let i = 0; i < maPubkeys.length; i += constants.MAX_ACCOUNTS_TO_FETCH) {
        marginAccounts = marginAccounts.concat(await exchange_1.exchange.program.account.marginAccount.fetchMultiple(maPubkeys.slice(i, i + constants.MAX_ACCOUNTS_TO_FETCH)));
    }
    marginAccounts.forEach((marginAccount) => {
        if (_1.assets.fromProgramAsset(marginAccount.asset) != asset) {
            return;
        }
        let nonce = marginAccount.openOrdersNonce[constants.PERP_INDEX];
        if (nonce != 0) {
            let [openOrders, _nonce] = getOpenOrders(exchange_1.exchange.programId, market.address, marginAccount.authority);
            allOpenOrders.push(openOrders);
        }
    });
    let cmaPubkeys = await getAllProgramAccountAddresses(types.ProgramAccountType.CrossMarginAccount);
    // Randomly grab the first N only to avoid overloading the app
    cmaPubkeys.sort(() => Math.random() - 0.5);
    if (accountLimit) {
        cmaPubkeys = cmaPubkeys.slice(0, accountLimit);
    }
    console.log(`${cmaPubkeys.length} crossMarginAccounts`);
    let crossMarginAccounts = [];
    for (let i = 0; i < cmaPubkeys.length; i += constants.MAX_ACCOUNTS_TO_FETCH) {
        crossMarginAccounts = crossMarginAccounts.concat(await exchange_1.exchange.program.account.crossMarginAccount.fetchMultiple(cmaPubkeys.slice(i, i + constants.MAX_ACCOUNTS_TO_FETCH)));
    }
    crossMarginAccounts.forEach((crossMarginAccount, i) => {
        let nonce = crossMarginAccount.openOrdersNonces[_1.assets.assetToIndex(asset)];
        if (nonce != 0) {
            let [openOrders, _nonce] = getCrossOpenOrders(exchange_1.exchange.programId, market.address, cmaPubkeys[i]);
            allOpenOrders.push(openOrders);
        }
    });
    return allOpenOrders;
}
exports.getAllOpenOrdersAccounts = getAllOpenOrdersAccounts;
async function settleAndBurnVaultTokens(asset, provider, accountLimit = 100) {
    let openOrdersRaw = await getAllOpenOrdersAccounts(asset, accountLimit);
    let openOrdersFiltered = [];
    for (var i = 0; i < openOrdersRaw.length; i += constants.MAX_ACCOUNTS_TO_FETCH) {
        let ooBatch = await exchange_1.exchange.connection.getMultipleAccountsInfo(openOrdersRaw.slice(i, i + constants.MAX_ACCOUNTS_TO_FETCH), provider.connection.commitment);
        for (var j = 0; j < ooBatch.length; j++) {
            const decoded = market_1._OPEN_ORDERS_LAYOUT_V2.decode(ooBatch[j].data);
            let openOrdersAccount = new market_1.OpenOrders(openOrdersRaw[i + j], decoded, exchange_1.exchange.programId);
            if (openOrdersAccount.baseTokenFree.toNumber() != 0 ||
                openOrdersAccount.baseTokenTotal.toNumber() != 0 ||
                openOrdersAccount.quoteTokenFree.toNumber() != 0 ||
                openOrdersAccount.quoteTokenTotal.toNumber() != 0) {
                openOrdersFiltered.push(openOrdersRaw[i + j]);
            }
        }
    }
    let market = exchange_1.exchange.getPerpMarket(asset);
    console.log(`Burning tokens for ${openOrdersFiltered.length} openOrders accounts`);
    let remainingAccounts = openOrdersFiltered.map((key) => {
        return { pubkey: key, isSigner: false, isWritable: true };
    });
    const [vaultOwner, _vaultSignerNonce] = getSerumVaultOwnerAndNonce(market.address, constants.DEX_PID[exchange_1.exchange.network]);
    let txs = instructions.settleDexFundsTxs(asset, vaultOwner, remainingAccounts);
    for (var j = 0; j < txs.length; j += 5) {
        console.log("Settle tx num =", j);
        let txSlice = txs.slice(j, j + 5);
        await Promise.all(txSlice.map(async (tx, i) => {
            try {
                await processTransaction(provider, tx);
            }
            catch (e) {
                console.log(`Settle failed on tx ${j + i}, continuing...`);
            }
        }));
    }
    let burnTx = instructions.burnVaultTokenTx(asset);
    await processTransaction(provider, burnTx);
}
exports.settleAndBurnVaultTokens = settleAndBurnVaultTokens;
async function burnVaultTokens(asset, provider) {
    let market = exchange_1.exchange.getPerpMarket(asset);
    console.log(`Burning tokens`);
    let burnTx = instructions.burnVaultTokenTx(asset);
    await processTransaction(provider, burnTx);
}
exports.burnVaultTokens = burnVaultTokens;
/**
 * Calculates the total movement fees for a set of movements.
 * @param movements   list of position movements.
 * @param spotPrice   spot price in decimal
 * @param feeBps      fees charged in bps
 * @param decimal     whether to return fees in decimal or native integer (defaults to native integer)
 */
function calculateMovementFees(movements, spotPrice, feeBps, decimal = false) {
    let fees = 0;
    let totalContracts = 0;
    for (var i = 0; i < movements.length; i++) {
        totalContracts += convertNativeLotSizeToDecimal(Math.abs(movements[i].size.toNumber()));
    }
    let notionalValue = totalContracts * spotPrice;
    let fee = (notionalValue * feeBps) / constants.BPS_DENOMINATOR;
    return decimal ? fee : convertDecimalToNativeInteger(fee);
}
exports.calculateMovementFees = calculateMovementFees;
function getOrCreateKeypair(filename) {
    let keypair;
    if (fs.existsSync(filename)) {
        // File exists.
        keypair = web3_js_1.Keypair.fromSecretKey(Buffer.from(JSON.parse(fs.readFileSync(filename, {
            encoding: "utf-8",
        }))));
    }
    else {
        // File does not exist
        keypair = web3_js_1.Keypair.generate();
        writeKeypair(filename, keypair);
    }
    return keypair;
}
exports.getOrCreateKeypair = getOrCreateKeypair;
function toAssets(assetsStr) {
    let assets = [];
    for (var asset of assetsStr) {
        assets.push((0, assets_1.nameToAsset)(asset));
    }
    return assets;
}
exports.toAssets = toAssets;
function objectEquals(a, b) {
    return JSON.stringify(a) == JSON.stringify(b);
}
exports.objectEquals = objectEquals;
function convertBufferToTrimmedString(buffer) {
    let bufferString = Buffer.from(buffer).toString().trim();
    let splitIndex = bufferString.length;
    for (let index = 0; index < bufferString.length; ++index) {
        if (bufferString.charCodeAt(index) === 0) {
            splitIndex = index;
            break;
        }
    }
    return bufferString.substring(0, splitIndex);
}
exports.convertBufferToTrimmedString = convertBufferToTrimmedString;
async function fetchReferralId(user) {
    const accKey = getReferrerPubkeyAccount(exchange_1.exchange.programId, user)[0];
    const accBuffer = await exchange_1.exchange.program.account.referrerPubkeyAccount.fetchNullable(accKey.toString());
    if (accBuffer == null) {
        return null;
    }
    return Buffer.from(accBuffer.referrerId).toString();
}
exports.fetchReferralId = fetchReferralId;
async function applyPerpFunding(asset, keys) {
    let remainingAccounts = keys.map((key) => {
        return { pubkey: key, isSigner: false, isWritable: true };
    });
    let txs = [];
    for (var i = 0; i < remainingAccounts.length; i += constants.MAX_FUNDING_ACCOUNTS) {
        let tx = new web3_js_1.Transaction();
        let slice = remainingAccounts.slice(i, i + constants.MAX_FUNDING_ACCOUNTS);
        tx.add(instructions.applyPerpFundingIx(asset, slice));
        txs.push(tx);
    }
    await Promise.all(txs.map(async (tx) => {
        let txSig = await processTransaction(exchange_1.exchange.provider, tx);
    }));
}
exports.applyPerpFunding = applyPerpFunding;
async function executeTriggerOrder(asset, side, triggerOrderBit, triggerOrder, marginAccount, openOrders, payer) {
    let tx = new web3_js_1.Transaction().add(instructions.executeTriggerOrderV2Ix(asset, side, triggerOrderBit, triggerOrder, marginAccount, openOrders, payer));
    await processTransaction(exchange_1.exchange.provider, tx);
}
exports.executeTriggerOrder = executeTriggerOrder;
function getProductLedger(marginAccount, index) {
    if (index == constants.PERP_INDEX) {
        return marginAccount.perpProductLedger;
    }
    return marginAccount.productLedgers[index];
}
exports.getProductLedger = getProductLedger;
function getTIFOffset(marketInfo, tifOptions) {
    if (tifOptions.expiryOffset == undefined &&
        tifOptions.expiryTs == undefined) {
        return 0;
    }
    if (tifOptions.expiryOffset != undefined &&
        tifOptions.expiryTs != undefined) {
        throw new Error("Cannot set both expiryOffset and expiryTs");
    }
    let currEpochStartTs = marketInfo.serumMarket.epochStartTs.toNumber();
    let epochLength = marketInfo.serumMarket.epochLength.toNumber();
    let epochEnd = currEpochStartTs + epochLength;
    let now = exchange_1.exchange.clockTimestamp;
    // get correct epoch end in case where serumMarket data is not up to date
    if (now > epochEnd) {
        currEpochStartTs = now - (now % epochLength);
        epochEnd = currEpochStartTs + epochLength;
    }
    if (tifOptions.expiryOffset != undefined) {
        if (tifOptions.expiryOffset <= 0) {
            throw new Error("Invalid expiry offset");
        }
        let desiredExpiryTs = now + tifOptions.expiryOffset;
        let desiredOffset = desiredExpiryTs % epochLength;
        if (epochEnd >= desiredExpiryTs) {
            return desiredOffset;
        }
        else {
            // Cap the offset at the end of the cycle.
            return epochLength;
        }
    }
    if (tifOptions.expiryTs != undefined) {
        if (tifOptions.expiryTs < exchange_1.exchange.clockTimestamp) {
            throw new Error("Cannot place an expired order");
        }
        let tifOffset = tifOptions.expiryTs - currEpochStartTs;
        if (tifOffset > epochLength) {
            return epochLength;
        }
        if (tifOffset <= 0) {
            throw new Error("Cannot place an expired order");
        }
        return tifOffset;
    }
}
exports.getTIFOffset = getTIFOffset;
function isOrderExpired(orderTIFOffset, orderSeqNum, epochStartTs, startEpochSeqNum, TIFBufferSeconds) {
    if (orderTIFOffset == 0) {
        return false;
    }
    if (epochStartTs + orderTIFOffset <
        exchange_1.exchange.clockTimestamp - TIFBufferSeconds) {
        return true;
    }
    if (startEpochSeqNum.gt(orderSeqNum)) {
        return true;
    }
    return false;
}
exports.isOrderExpired = isOrderExpired;
function getZetaLutArr() {
    if (exchange_1.exchange.network == network_1.Network.LOCALNET) {
        return [];
    }
    return constants.STATIC_AND_PERPS_LUT[exchange_1.exchange.network];
}
exports.getZetaLutArr = getZetaLutArr;
function getUnderlyingMint(asset) {
    if (asset in constants.MINTS) {
        return constants.MINTS[asset];
    }
    if (asset in constants.FLEX_MINTS[exchange_1.exchange.network]) {
        return constants.FLEX_MINTS[exchange_1.exchange.network][asset];
    }
    throw Error("Underlying mint does not exist!");
}
exports.getUnderlyingMint = getUnderlyingMint;
function isFlexUnderlying(asset) {
    return asset in constants.FLEX_MINTS[exchange_1.exchange.network];
}
exports.isFlexUnderlying = isFlexUnderlying;
function median(arr) {
    if (!arr.length)
        return undefined;
    const s = [...arr].sort((a, b) => a - b);
    const mid = Math.floor(s.length / 2);
    return s.length % 2 === 0 ? (s[mid - 1] + s[mid]) / 2 : s[mid];
}
exports.median = median;
async function isAffiliateCodeAvailable(code) {
    let referrerIdAddress = getReferrerIdAccount(exchange_1.exchange.programId, code)[0];
    let referrerIdAccount = await exchange_1.exchange.program.account.referrerIdAccount.fetchNullable(referrerIdAddress);
    return referrerIdAccount == null;
}
exports.isAffiliateCodeAvailable = isAffiliateCodeAvailable;
const checkLiquidity = (size, asset, side, slippage, orderbook) => {
    // We default to min lot size to still show a price
    const fillSize = size || getDecimalMinLotSize(asset);
    slippage !== null && slippage !== void 0 ? slippage : (slippage = constants.PERP_MARKET_ORDER_SPOT_SLIPPAGE);
    orderbook !== null && orderbook !== void 0 ? orderbook : (orderbook = exchange_1.exchange.getOrderbook(asset));
    const orderbookSide = side === types.Side.ASK ? orderbook.bids : orderbook.asks;
    // Invalid order
    if (!orderbookSide || !orderbookSide.length) {
        return { validLiquidity: false, avgPrice: 0, worstPrice: 0 };
    }
    let validLiquidity = false;
    // Size seen on the orderbook that satisfies the specified price
    let seenSize = 0;
    // The cumulative trade value for the seen size
    let cumAmount = 0;
    // The price of the worst orderbook level that will statisfy the request size entirely
    let worstPrice = 0;
    for (let i = 0; i < orderbookSide.length; i++) {
        const orderbookLevel = orderbookSide[i];
        const isWithinSlippge = checkWithinSlippageTolerance(orderbookLevel.price, side, asset, orderbook, slippage);
        if (!isWithinSlippge) {
            // If not within slippage break early, not a valid market order
            break;
        }
        // Size remaining to fill from orderbook
        const sizeRemaining = fillSize - seenSize;
        // We can satify our size requirements without taking the entire level's size
        const sizeToFill = Math.min(sizeRemaining, orderbookLevel.size);
        seenSize += sizeToFill;
        cumAmount += sizeToFill * orderbookLevel.price;
        worstPrice = orderbookLevel.price;
        validLiquidity = seenSize >= fillSize;
        // Size requirements satified
        if (validLiquidity)
            break;
    }
    // Average price across all the seen levels
    const avgPrice = cumAmount / seenSize || exchange_1.exchange.getMarkPrice(asset);
    return { validLiquidity, avgPrice, worstPrice };
};
exports.checkLiquidity = checkLiquidity;
const checkWithinSlippageTolerance = (price, side, asset, orderbook, slippage) => {
    const spotPrice = exchange_1.exchange.getMarkPrice(asset);
    const orderbookMidpoint = !orderbook.asks.length || !orderbook.bids.length
        ? undefined
        : (orderbook.asks[0].price + orderbook.bids[0].price) / 2;
    const markPrice = orderbookMidpoint || spotPrice;
    if (side === types.Side.BID && price < markPrice)
        return true;
    if (side === types.Side.ASK && price > markPrice)
        return true;
    const maxSlippage = slippage * markPrice;
    return Math.abs(price - markPrice) <= Math.abs(maxSlippage);
};
function deepCloneCrossMarginAccount(marginAccount) {
    return (0, lodash_clonedeep_1.default)(marginAccount);
}
exports.deepCloneCrossMarginAccount = deepCloneCrossMarginAccount;
/**
 * Initializes the zeta markets for a zeta group.
 */
async function initializeZetaMarkets(asset, zetaGroupAddress) {
    // Initialize market indexes.
    let [marketIndexes, marketIndexesNonce] = getMarketIndexes(exchange_1.exchange.programId, zetaGroupAddress);
    console.log("Initializing market indexes.");
    let tx = new web3_js_1.Transaction().add(instructions.initializeMarketIndexesIx(asset, marketIndexes, marketIndexesNonce));
    try {
        await processTransaction(exchange_1.exchange.provider, tx, [], defaultCommitment(), exchange_1.exchange.useLedger);
    }
    catch (e) {
        console.error(`Initialize market indexes failed: ${e}`);
    }
    let tx2 = new web3_js_1.Transaction().add(instructions.addPerpMarketIndexIx(asset, marketIndexes));
    try {
        await processTransaction(exchange_1.exchange.provider, tx2, [], defaultCommitment(), exchange_1.exchange.useLedger);
        await sleep(100);
    }
    catch (e) {
        console.error(`Add market indexes failed: ${e}`);
        console.log(e);
    }
    let marketIndexesAccount = (await exchange_1.exchange.program.account.marketIndexes.fetch(marketIndexes));
    if (!marketIndexesAccount.initialized) {
        throw Error("Market indexes are not initialized!");
    }
    await initializeZetaMarket(asset, zetaGroupAddress, marketIndexes, marketIndexesAccount);
}
exports.initializeZetaMarkets = initializeZetaMarkets;
async function initializeZetaMarket(asset, zetaGroupAddress, marketIndexes, marketIndexesAccount) {
    console.log(`Initializing zeta market`);
    const homedir = os.homedir();
    let dir = `${homedir}/keys/${(0, assets_1.assetToName)(asset)}`;
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
    let i = constants.PERP_INDEX;
    const requestQueue = getOrCreateKeypair(`${dir}/rq-${i}.json`);
    const eventQueue = getOrCreateKeypair(`${dir}/eq-${i}.json`);
    const bids = getOrCreateKeypair(`${dir}/bids-${i}.json`);
    const asks = getOrCreateKeypair(`${dir}/asks-${i}.json`);
    let [tx, tx2] = await instructions.initializeZetaMarketTxs(asset, marketIndexesAccount.indexes[i], requestQueue.publicKey, eventQueue.publicKey, bids.publicKey, asks.publicKey, marketIndexes, zetaGroupAddress);
    let marketInitialized = false;
    let accountsInitialized = false;
    if (exchange_1.exchange.network != network_1.Network.LOCALNET) {
        // Validate that the market hasn't already been initialized
        // So no sol is wasted on unnecessary accounts.
        const [market, _marketNonce] = getMarketUninitialized(exchange_1.exchange.programId, zetaGroupAddress, marketIndexesAccount.indexes[i]);
        let info = await exchange_1.exchange.provider.connection.getAccountInfo(market);
        if (info !== null) {
            marketInitialized = true;
        }
        info = await exchange_1.exchange.provider.connection.getAccountInfo(bids.publicKey);
        if (info !== null) {
            accountsInitialized = true;
        }
    }
    if (accountsInitialized) {
        console.log(`Market ${i} serum accounts already initialized...`);
    }
    else {
        try {
            console.log("initialize zeta market accounts");
            await processTransaction(exchange_1.exchange.provider, tx, [requestQueue, eventQueue, bids, asks], commitmentConfig(exchange_1.exchange.connection.commitment), exchange_1.exchange.useLedger);
        }
        catch (e) {
            console.error(`Initialize zeta market serum accounts ${i} failed: ${e}`);
        }
    }
    if (marketInitialized) {
        console.log(`Market ${i} already initialized. Skipping...`);
    }
    else {
        try {
            console.log("initialize zeta market instruction");
            await processTransaction(exchange_1.exchange.provider, tx2, [], commitmentConfig(exchange_1.exchange.connection.commitment), exchange_1.exchange.useLedger);
        }
        catch (e) {
            console.error(`Initialize zeta market ${i} failed: ${e}`);
        }
    }
}
function calculateTakeTriggerOrderExecutionPrice(triggerOrder) {
    if (triggerOrder.triggerPrice == null) {
        throw new Error("Trigger order needs a trigger price.");
    }
    let fee = exchange_1.exchange.state.nativeTakeTriggerOrderFeePercentage.toNumber() / 100000000;
    let tradePriceFee = fee * triggerOrder.triggerPrice.toNumber();
    let side = types.fromProgramSide(triggerOrder.side);
    let executionPrice = null;
    if (side == types.Side.BID) {
        executionPrice = Math.min(triggerOrder.orderPrice.toNumber(), triggerOrder.triggerPrice.toNumber() + tradePriceFee);
    }
    else {
        executionPrice = Math.max(triggerOrder.orderPrice.toNumber(), triggerOrder.triggerPrice.toNumber() - tradePriceFee);
    }
    return executionPrice;
}
exports.calculateTakeTriggerOrderExecutionPrice = calculateTakeTriggerOrderExecutionPrice;
function getFeeTier(accountType) {
    let tier = constants.ACCOUNT_TYPE_TO_FEE_TIER_MAP[accountType];
    if (tier == undefined) {
        return 0;
    }
    return tier;
}
exports.getFeeTier = getFeeTier;
function getFeeBps(isTaker, accountType) {
    let feeMap = isTaker
        ? constants.FEE_TIER_MAP_BPS["taker"]
        : constants.FEE_TIER_MAP_BPS["maker"];
    let fee = feeMap[accountType];
    if (fee == undefined) {
        return feeMap[constants.MarginAccountType.NORMAL];
    }
    return fee;
}
exports.getFeeBps = getFeeBps;
