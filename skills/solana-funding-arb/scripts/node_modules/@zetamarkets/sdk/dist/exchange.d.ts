import * as anchor from "@zetamarkets/anchor";
import { PublicKey, ConfirmOptions, AccountMeta, Commitment, Connection } from "@solana/web3.js";
import { Connection as ConnectionZstd } from "zeta-solana-web3";
import { PerpSyncQueue, State, Pricing } from "./program-types";
import { Market, ZetaGroupMarkets } from "./market";
import { RiskCalculator } from "./risk";
import { EventType } from "./events";
import { Network } from "./network";
import { Oracle } from "./oracle";
import { Zeta } from "./types/zeta";
import * as types from "./types";
import { Asset } from "./constants";
import { SubExchange } from "./subexchange";
import * as instructions from "./program-instructions";
import { HttpProvider } from "@bloxroute/solana-trader-client-ts";
export declare class Exchange {
    /**
     * Whether the object has been set up (in .initialize()).
     */
    get isSetup(): boolean;
    private _isSetup;
    /**
     * Whether the object has been initialized (in .load()).
     */
    get isInitialized(): boolean;
    private _isInitialized;
    /**
     * Account storing zeta state.
     */
    get state(): State;
    private _state;
    /**
     * Account storing zeta pricing.
     */
    get pricing(): Pricing;
    private _pricing;
    /**
     * The solana network being used.
     */
    get network(): Network;
    private _network;
    /**
     * Anchor program instance.
     */
    get program(): anchor.Program<Zeta>;
    private _program;
    get programId(): PublicKey;
    /**
     * Anchor provider instance.
     */
    get provider(): anchor.AnchorProvider;
    get connection(): ConnectionZstd;
    private _provider;
    get httpProvider(): HttpProvider;
    private _httpProvider;
    /**
     * Separate connection used for orderbook subscriptions.
     * For example you might use a connection with Whirligig and low commitment for faster results
     */
    get orderbookConnection(): ConnectionZstd;
    private _orderbookConnection;
    /**
     * Public key used as the stable coin mint.
     */
    get usdcMintAddress(): PublicKey;
    private _usdcMintAddress;
    /**
     * ConfirmOptions, stored so we don't need it again when making a SerumMarket.
     */
    get opts(): ConfirmOptions;
    private _opts;
    get subExchanges(): Map<Asset, SubExchange>;
    private _subExchanges;
    /**
     * The assets being used
     */
    get assets(): Asset[];
    private _assets;
    get oracle(): Oracle;
    private _oracle;
    /**
     * Risk calculator that holds all margin requirements.
     */
    get riskCalculator(): RiskCalculator;
    private _riskCalculator;
    /**
     * Zeta PDA for serum market authority
     */
    get serumAuthority(): PublicKey;
    private _serumAuthority;
    /**
     * Zeta PDA for minting serum mints
     */
    get mintAuthority(): PublicKey;
    private _mintAuthority;
    /**
     * Address of state account.
     */
    get stateAddress(): PublicKey;
    private _stateAddress;
    /**
     * Address of zeta pricing account.
     */
    get pricingAddress(): PublicKey;
    private _pricingAddress;
    /**
     * Public key for treasury wallet.
     */
    get treasuryWalletAddress(): PublicKey;
    private _treasuryWalletAddress;
    /**
     * Public key for referral rewards wallet.
     */
    get referralsRewardsWalletAddress(): PublicKey;
    private _referralsRewardsWalletAddress;
    /**
     * Public key for combined insurance fund.
     */
    get combinedInsuranceVaultAddress(): PublicKey;
    private _combinedInsuranceVaultAddress;
    /**
     * Public key for combined deposit vault.
     */
    get combinedVaultAddress(): PublicKey;
    private _combinedVaultAddress;
    /**
     * Public key for combined socialized loss account.
     */
    get combinedSocializedLossAccountAddress(): PublicKey;
    private _combinedSocializedLossAccountAddress;
    /**
     * Stores the latest timestamp received by websocket subscription
     * to the system clock account.
     */
    get clockTimestamp(): number;
    private _clockTimestamp;
    /**
     * Stores the latest clock slot from clock subscription.
     */
    get clockSlot(): number;
    private _clockSlot;
    /**
     * Websocket subscription id for clock.
     */
    private _clockSubscriptionId;
    /**
     * The subscription id for the pricing account.
     */
    private _pricingSubscriptionId;
    /**
     * The subscription id for the state account.
     */
    private _stateSubscriptionId;
    /**
     * @param interval   How often to poll zeta group and state in seconds.
     */
    get pollInterval(): number;
    set pollInterval(interval: number);
    private _pollInterval;
    private _lastPollTimestamp;
    get ledgerWallet(): any;
    private _ledgerWallet;
    get useLedger(): boolean;
    setLedgerWallet(wallet: any): void;
    maxRpcRetries: number | undefined;
    skipRpcConfirmation: boolean | undefined;
    zetaGroupPubkeyToAsset(key: PublicKey): Asset;
    private _zetaGroupPubkeyToAsset;
    private _useLedger;
    private _programSubscriptionIds;
    private _eventEmitters;
    get priorityFee(): number;
    private _priorityFee;
    get useJitoBundle(): boolean;
    private _useJitoBundle;
    get jitoTip(): number;
    private _jitoTip;
    get doubleDownConnections(): Connection[];
    addDoubleDownConnection(connection: Connection): void;
    private _doubleDownConnections;
    get useAutoPriorityFee(): boolean;
    private _useAutoPriorityFee;
    private _autoPriorityFeeOffset;
    private _autoPriorityFeeMultiplier;
    private _autoPriorityFeeUseMax;
    get tipMultiplier(): number;
    private _tipMultiplier;
    get postSignCallback(): () => Promise<void>;
    set postSignCallback(callback: () => Promise<void>);
    private _postSignCallback;
    get autoPriorityFeeUpperLimit(): number;
    private _autoPriorityFeeUpperLimit;
    get blockhashCommitment(): Commitment;
    private _blockhashCommitment;
    getCachedBlockhash(): Promise<Readonly<{
        blockhash: string;
        lastValidBlockHeight: number;
    }>>;
    private _blockhashCache;
    setUseAutoPriorityFee(useAutoPriorityFee: boolean): void;
    toggleAutoPriorityFee(): void;
    setAutoPriorityFeeScaling(offset?: number, multiplier?: number): void;
    toggleAutoPriorityFeeUseMax(): void;
    setAutoPriorityFeeUseMax(useMax: boolean): void;
    setTipMultiplier(multiplier: number): void;
    updatePriorityFee(microLamportsPerCU: number): void;
    setUseJitoBundle(option: boolean): void;
    updateJitoTip(tipAmountInLamports: number): void;
    updateAutoPriorityFeeUpperLimit(microLamportsPerCU: number): void;
    updateBlockhashCommitment(commitment: Commitment): void;
    initialize(loadConfig: types.LoadExchangeConfig, wallet?: types.DummyWallet): void;
    initializeCombinedInsuranceVault(): Promise<void>;
    initializeCombinedVault(): Promise<void>;
    initializeCombinedSocializedLossAccount(): Promise<void>;
    updateTreasurySplitTokenAccount(treasurySplitTokenAccount: PublicKey, treasurySplitPercentage: number, admin: PublicKey): Promise<void>;
    initializeZetaState(params: instructions.StateParams, referralAdmin: PublicKey, secondaryAdmin: PublicKey): Promise<void>;
    initializeZetaPricing(perpArgs: instructions.UpdatePerpParametersArgs, marginArgs: instructions.UpdateMarginParametersArgs): Promise<void>;
    load(loadConfig: types.LoadExchangeConfig, wallet?: types.DummyWallet, callback?: (asset: Asset, event: EventType, slot: number, data: any) => void, postSignCallback?: () => Promise<void>, bloxrouteHttpProvider?: HttpProvider): Promise<void>;
    private addSubExchange;
    getSubExchange(asset: Asset): SubExchange;
    getAllSubExchanges(): SubExchange[];
    updateAutoFee(): Promise<void>;
    private subscribeOracle;
    private setClockData;
    private subscribeClock;
    addProgramSubscriptionId(id: number): void;
    updateExchangeState(): Promise<void>;
    /**
     * Polls the on chain account to update state.
     */
    updateState(): Promise<void>;
    /**
     * Polls the on chain account to update mark prices
     */
    updateZetaPricing(): Promise<void>;
    /**
     * Update the expiry state variables for the program.
     */
    updateZetaState(params: instructions.StateParams): Promise<void>;
    private subscribeState;
    private updateCachedBlockhash;
    private subscribePricing;
    getZetaGroupMarkets(asset: Asset): ZetaGroupMarkets;
    getPerpMarket(asset: Asset): Market;
    getZetaGroupAddress(asset: Asset): PublicKey;
    getPerpSyncQueue(asset: Asset): PerpSyncQueue;
    getOrderbook(asset: Asset): types.DepthOrderbook;
    getMarkPrice(asset: Asset): number;
    getInsuranceVaultAddress(): PublicKey;
    getVaultAddress(): PublicKey;
    getSocializedLossAccountAddress(): PublicKey;
    updateMarginParameters(asset: Asset, args: instructions.UpdateMarginParametersArgs): Promise<void>;
    updatePerpParameters(asset: Asset, args: instructions.UpdatePerpParametersArgs): Promise<void>;
    updateSerumMarkets(asset: Asset): Promise<void>;
    updatePerpSerumMarketIfNeeded(asset: Asset, epochDelay: number): Promise<void>;
    initializeZetaMarkets(asset: Asset, zetaGroupAddress: PublicKey): Promise<void>;
    initializeZetaMarketsTIFEpochCycle(asset: Asset, cycleLengthSecs: number): Promise<void>;
    initializePerpSyncQueue(asset: Asset): Promise<void>;
    initializeUnderlying(asset: Asset, flexUnderlying: boolean): Promise<void>;
    updatePricing(asset: Asset): Promise<void>;
    updatePricingV3(asset: Asset, price: anchor.BN, timestamp: anchor.BN): Promise<void>;
    updatePricingPubkeys(asset: Asset, oracle: PublicKey, market: PublicKey, perpSyncQueue: PublicKey, zetaGroupKey: PublicKey): Promise<void>;
    whitelistUserForDeposit(asset: Asset, user: PublicKey): Promise<void>;
    whitelistUserForInsuranceVault(asset: Asset, user: PublicKey): Promise<void>;
    whitelistUserForTradingFees(asset: Asset, user: PublicKey): Promise<void>;
    treasuryMovement(treasuryMovementType: types.TreasuryMovementType, amount: anchor.BN): Promise<void>;
    rebalanceInsuranceVault(marginAccounts: any[]): Promise<void>;
    adminCancelTriggerOrder(orderIndex: number, crossMarginAccount: PublicKey, enforceTpslConditions?: boolean): Promise<string>;
    halt(asset: Asset): Promise<void>;
    unhalt(asset: Asset): Promise<void>;
    updateHaltState(asset: Asset, timestamp: anchor.BN, spotPrice: anchor.BN): Promise<void>;
    settlePositionsHalted(asset: Asset, marginAccounts: AccountMeta[]): Promise<void>;
    cancelAllOrdersHalted(asset: Asset): Promise<void>;
    cleanZetaMarketHalted(asset: Asset): Promise<void>;
    isHalted(asset: Asset): boolean;
    close(): Promise<void>;
}
export declare const exchange: Exchange;
