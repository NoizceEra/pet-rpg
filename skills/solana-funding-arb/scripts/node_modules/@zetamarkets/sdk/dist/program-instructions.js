"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateMarginParametersIx = exports.updateTreasurySplitTokenAccountIx = exports.applyPerpFundingIx = exports.updatePricingV3Ix = exports.updatePricingV2Ix = exports.crankMarketIx = exports.liquidateV2Ix = exports.rebalanceInsuranceVaultIx = exports.treasuryMovementIx = exports.collectTreasuryFundsIx = exports.initializePerpSyncQueueIx = exports.initializeUnderlyingIx = exports.initializeZetaMarketTxs = exports.initializeZetaMarketTIFEpochCyclesIx = exports.forceCancelOrdersV2Ix = exports.forceCancelOrderByOrderIdV2Ix = exports.cancelOrderByClientOrderIdNoErrorIx = exports.cancelOrderByClientOrderIdIx = exports.cancelAllMarketOrdersIx = exports.pruneExpiredTIFOrdersIx = exports.pruneExpiredTIFOrdersIxV2 = exports.cancelOrderNoErrorIx = exports.cancelOrderIx = exports.editTriggerOrderIx = exports.forceCancelTriggerOrderIx = exports.cancelTriggerOrderV2Ix = exports.takeTriggerOrderIx = exports.executeTriggerOrderV2Ix = exports.placeTriggerOrderIx = exports.placeMultiOrdersIx = exports.placePerpOrderV5Ix = exports.closeOpenOrdersV2Ix = exports.closeOpenOrdersV4Ix = exports.initializeOpenOrdersV3Ix = exports.initializeOpenOrdersV2Ix = exports.withdrawV2Ix = exports.withdrawInsuranceVaultV2Ix = exports.depositInsuranceVaultV2Ix = exports.depositPermissionlessIx = exports.depositV2Ix = exports.initializeInsuranceDepositAccountIx = exports.closeMarginAccountIx = exports.closeCrossMarginAccountIx = exports.initializeCrossMarginAccountIx = exports.closeCrossMarginAccountManagerIx = exports.initializeCrossMarginAccountManagerV2Ix = exports.migrateToCrossMarginAccountIx = exports.initializeCombinedSocializedLossAccountIx = exports.initializeCombinedVaultIx = exports.initializeCombinedInsuranceVaultIx = void 0;
exports.initializeMinLotsAndTickSizes = exports.updateTickSizeIx = exports.updateMinLotIx = exports.editMaType = exports.updateMakerRebatePercentageIx = exports.updateTakeTriggerOrderFeePercentageIx = exports.editDelegatedPubkeyIx = exports.chooseAirdropCommunityIx = exports.toggleMarketMakerIx = exports.burnVaultTokenTx = exports.settleDexFundsIx = exports.settleDexFundsTxs = exports.updateReferralsAdminIx = exports.closeReferrerAccountsIx = exports.initializeReferrerAccountsIx = exports.updatePricingAdminIx = exports.updateAdminIx = exports.updateHaltStateIx = exports.unhaltIx = exports.haltIx = exports.cancelOrderHaltedIx = exports.cleanZetaMarketHaltedIx = exports.cleanZetaMarketsIx = exports.settlePositionsHaltedIx = exports.settlePositionsHaltedTxs = exports.initializeWhitelistTradingFeesAccountIx = exports.initializeWhitelistInsuranceAccountIx = exports.initializeWhitelistDepositAccountIx = exports.addMarketIndexesIx = exports.initializeMarketIndexesIx = exports.addPerpMarketIndexIx = exports.updateZetaStateIx = exports.initializeZetaReferralsRewardsWalletIx = exports.initializeZetaTreasuryWalletIx = exports.initializeZetaStateIx = exports.updateZetaPricingPubkeysIx = exports.initializeZetaPricingIx = exports.updatePerpParametersIx = void 0;
const exchange_1 = require("./exchange");
const web3_js_1 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
const utils = __importStar(require("./utils"));
const anchor = __importStar(require("@zetamarkets/anchor"));
const types = __importStar(require("./types"));
const constants = __importStar(require("./constants"));
const assets_1 = require("./assets");
const obscenity_1 = require("obscenity");
const profanityMatcher = new obscenity_1.RegExpMatcher({
    ...obscenity_1.englishDataset.build(),
    ...obscenity_1.englishRecommendedTransformers,
});
function initializeCombinedInsuranceVaultIx() {
    let [insuranceVault, insuranceVaultNonce] = utils.getZetaCombinedInsuranceVault(exchange_1.exchange.programId);
    return exchange_1.exchange.program.instruction.initializeCombinedInsuranceVault(insuranceVaultNonce, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            insuranceVault: insuranceVault,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            usdcMint: exchange_1.exchange.usdcMintAddress,
            admin: exchange_1.exchange.state.admin,
            systemProgram: web3_js_1.SystemProgram.programId,
        },
    });
}
exports.initializeCombinedInsuranceVaultIx = initializeCombinedInsuranceVaultIx;
function initializeCombinedVaultIx() {
    let [vault, vaultNonce] = utils.getCombinedVault(exchange_1.exchange.programId);
    return exchange_1.exchange.program.instruction.initializeCombinedVault(vaultNonce, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            vault: vault,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            usdcMint: exchange_1.exchange.usdcMintAddress,
            admin: exchange_1.exchange.state.admin,
            systemProgram: web3_js_1.SystemProgram.programId,
        },
    });
}
exports.initializeCombinedVaultIx = initializeCombinedVaultIx;
function initializeCombinedSocializedLossAccountIx() {
    let [account, accountNonce] = utils.getCombinedSocializedLossAccount(exchange_1.exchange.programId);
    return exchange_1.exchange.program.instruction.initializeCombinedSocializedLossAccount(accountNonce, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            socializedLossAccount: account,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            usdcMint: exchange_1.exchange.usdcMintAddress,
            admin: exchange_1.exchange.state.admin,
            systemProgram: web3_js_1.SystemProgram.programId,
        },
    });
}
exports.initializeCombinedSocializedLossAccountIx = initializeCombinedSocializedLossAccountIx;
function migrateToCrossMarginAccountIx(marginAccounts, crossMarginAccount, userKey) {
    let remainingAccounts = [];
    for (var account of marginAccounts) {
        remainingAccounts.push({
            pubkey: account,
            isSigner: false,
            isWritable: true,
        });
    }
    return exchange_1.exchange.program.instruction.migrateToCrossMarginAccount({
        accounts: {
            crossMarginAccount,
            pricing: exchange_1.exchange.pricingAddress,
            authority: userKey,
        },
        remainingAccounts,
    });
}
exports.migrateToCrossMarginAccountIx = migrateToCrossMarginAccountIx;
function initializeCrossMarginAccountManagerV2Ix(crossMarginAccountManager, user, referrer) {
    return exchange_1.exchange.program.instruction.initializeCrossMarginAccountManagerV2(referrer ? referrer : null, {
        accounts: {
            crossMarginAccountManager,
            authority: user,
            payer: user,
            zetaProgram: exchange_1.exchange.programId,
            systemProgram: web3_js_1.SystemProgram.programId,
        },
    });
}
exports.initializeCrossMarginAccountManagerV2Ix = initializeCrossMarginAccountManagerV2Ix;
function closeCrossMarginAccountManagerIx(userKey, crossMarginAccountManager) {
    return exchange_1.exchange.program.instruction.closeCrossMarginAccountManager({
        accounts: {
            crossMarginAccountManager,
            authority: userKey,
            state: exchange_1.exchange.stateAddress,
            admin: exchange_1.exchange.state.admin,
            pricingAdmin: exchange_1.exchange.state.pricingAdmin,
        },
    });
}
exports.closeCrossMarginAccountManagerIx = closeCrossMarginAccountManagerIx;
function initializeCrossMarginAccountIx(crossMarginAccount, crossMarginAccountManager, user) {
    return exchange_1.exchange.program.instruction.initializeCrossMarginAccount(0, {
        accounts: {
            crossMarginAccount,
            crossMarginAccountManager,
            authority: user,
            payer: user,
            zetaProgram: exchange_1.exchange.programId,
            systemProgram: web3_js_1.SystemProgram.programId,
        },
    });
}
exports.initializeCrossMarginAccountIx = initializeCrossMarginAccountIx;
function closeCrossMarginAccountIx(userKey, crossMarginAccount, crossMarginAccountManager) {
    return exchange_1.exchange.program.instruction.closeCrossMarginAccount(0, {
        accounts: {
            crossMarginAccount,
            crossMarginAccountManager,
            authority: userKey,
            state: exchange_1.exchange.stateAddress,
            admin: exchange_1.exchange.state.admin,
            pricingAdmin: exchange_1.exchange.state.pricingAdmin,
        },
    });
}
exports.closeCrossMarginAccountIx = closeCrossMarginAccountIx;
function closeMarginAccountIx(asset, userKey, marginAccount) {
    return exchange_1.exchange.program.instruction.closeMarginAccount({
        accounts: {
            marginAccount,
            authority: userKey,
            zetaGroup: exchange_1.exchange.getZetaGroupAddress(asset),
            admin: exchange_1.exchange.state.admin,
            pricingAdmin: exchange_1.exchange.state.pricingAdmin,
            state: exchange_1.exchange.stateAddress,
        },
    });
}
exports.closeMarginAccountIx = closeMarginAccountIx;
function initializeInsuranceDepositAccountIx(payer, userKey, userWhitelistInsuranceKey) {
    let [insuranceDepositAccount, nonce] = utils.getUserInsuranceDepositAccount(exchange_1.exchange.programId, userKey);
    return exchange_1.exchange.program.instruction.initializeInsuranceDepositAccount(nonce, {
        accounts: {
            insuranceDepositAccount,
            payer,
            authority: userKey,
            systemProgram: web3_js_1.SystemProgram.programId,
            whitelistInsuranceAccount: userWhitelistInsuranceKey,
        },
    });
}
exports.initializeInsuranceDepositAccountIx = initializeInsuranceDepositAccountIx;
/**
 * @param amount the native amount to deposit (6dp)
 */
function depositV2Ix(amount, marginAccount, usdcAccount, userKey, whitelistDepositAccount) {
    let remainingAccounts = whitelistDepositAccount !== undefined
        ? [
            {
                pubkey: whitelistDepositAccount,
                isSigner: false,
                isWritable: false,
            },
        ]
        : [];
    // TODO: Probably use mint to find decimal places in future.
    return exchange_1.exchange.program.instruction.depositV2(new anchor.BN(amount), {
        accounts: {
            pricing: exchange_1.exchange.pricingAddress,
            marginAccount: marginAccount,
            vault: exchange_1.exchange.combinedVaultAddress,
            userTokenAccount: usdcAccount,
            socializedLossAccount: exchange_1.exchange.combinedSocializedLossAccountAddress,
            authority: userKey,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            state: exchange_1.exchange.stateAddress,
        },
        remainingAccounts,
    });
}
exports.depositV2Ix = depositV2Ix;
/**
 * @param amount the native amount to deposit (6dp)
 * @param user to deposit to
 */
function depositPermissionlessIx(amount, userToDeposit, payer, whitelistDepositAccount) {
    let remainingAccounts = whitelistDepositAccount !== undefined
        ? [
            {
                pubkey: whitelistDepositAccount,
                isSigner: false,
                isWritable: false,
            },
        ]
        : [];
    // Default to 0 for now and CMA
    let crossMarginAccount = utils.getCrossMarginAccount(exchange_1.exchange.programId, userToDeposit, Uint8Array.from([0]))[0];
    let depositTokenAcc = utils.getAssociatedTokenAddress(constants.USDC_MINT_ADDRESS[exchange_1.exchange.network], payer);
    // TODO: Probably use mint to find decimal places in future.
    return exchange_1.exchange.program.instruction.depositPermissionless(new anchor.BN(amount), {
        accounts: {
            pricing: exchange_1.exchange.pricingAddress,
            crossMarginAccount,
            vault: exchange_1.exchange.combinedVaultAddress,
            depositTokenAcc,
            socializedLossAccount: exchange_1.exchange.combinedSocializedLossAccountAddress,
            authority: userToDeposit,
            payer,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            state: exchange_1.exchange.stateAddress,
        },
        remainingAccounts,
    });
}
exports.depositPermissionlessIx = depositPermissionlessIx;
/**
 * @param amount
 * @param insuranceDepositAccount
 * @param usdcAccount
 * @param userKey
 */
function depositInsuranceVaultV2Ix(amount, insuranceDepositAccount, usdcAccount, userKey) {
    return exchange_1.exchange.program.instruction.depositInsuranceVaultV2(new anchor.BN(amount), {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            pricing: exchange_1.exchange.pricingAddress,
            insuranceVault: exchange_1.exchange.combinedInsuranceVaultAddress,
            insuranceDepositAccount,
            userTokenAccount: usdcAccount,
            zetaVault: exchange_1.exchange.combinedVaultAddress,
            socializedLossAccount: exchange_1.exchange.combinedSocializedLossAccountAddress,
            authority: userKey,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
        },
    });
}
exports.depositInsuranceVaultV2Ix = depositInsuranceVaultV2Ix;
function withdrawInsuranceVaultV2Ix(percentageAmount, insuranceDepositAccount, usdcAccount, userKey) {
    return exchange_1.exchange.program.instruction.withdrawInsuranceVaultV2(new anchor.BN(percentageAmount), {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            pricing: exchange_1.exchange.pricingAddress,
            insuranceVault: exchange_1.exchange.combinedInsuranceVaultAddress,
            insuranceDepositAccount,
            userTokenAccount: usdcAccount,
            authority: userKey,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
        },
    });
}
exports.withdrawInsuranceVaultV2Ix = withdrawInsuranceVaultV2Ix;
/**
 * @param amount the native amount to withdraw (6dp)
 */
function withdrawV2Ix(amount, marginAccount, usdcAccount, userKey) {
    return exchange_1.exchange.program.instruction.withdrawV2(new anchor.BN(amount), {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            pricing: exchange_1.exchange.pricingAddress,
            vault: exchange_1.exchange.combinedVaultAddress,
            marginAccount: marginAccount,
            userTokenAccount: usdcAccount,
            authority: userKey,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            socializedLossAccount: exchange_1.exchange.combinedSocializedLossAccountAddress,
        },
    });
}
exports.withdrawV2Ix = withdrawV2Ix;
function initializeOpenOrdersV2Ix(market, userKey, authority, marginAccount) {
    const [openOrdersPda, _openOrdersNonce] = utils.getOpenOrders(exchange_1.exchange.programId, market, userKey);
    const [openOrdersMap, _openOrdersMapNonce] = utils.getOpenOrdersMap(exchange_1.exchange.programId, openOrdersPda);
    return [
        exchange_1.exchange.program.instruction.initializeOpenOrdersV2({
            accounts: {
                state: exchange_1.exchange.stateAddress,
                dexProgram: constants.DEX_PID[exchange_1.exchange.network],
                systemProgram: web3_js_1.SystemProgram.programId,
                openOrders: openOrdersPda,
                marginAccount: marginAccount,
                authority: authority,
                payer: authority,
                market: market,
                rent: web3_js_1.SYSVAR_RENT_PUBKEY,
                serumAuthority: exchange_1.exchange.serumAuthority,
                openOrdersMap,
            },
        }),
        openOrdersPda,
    ];
}
exports.initializeOpenOrdersV2Ix = initializeOpenOrdersV2Ix;
function initializeOpenOrdersV3Ix(asset, market, authority, crossMarginAccount) {
    const [openOrdersPda, _openOrdersNonce] = utils.getCrossOpenOrders(exchange_1.exchange.programId, market, crossMarginAccount);
    const [openOrdersMap, _openOrdersMapNonce] = utils.getCrossOpenOrdersMap(exchange_1.exchange.programId, openOrdersPda);
    return [
        exchange_1.exchange.program.instruction.initializeOpenOrdersV3((0, assets_1.toProgramAsset)(asset), {
            accounts: {
                state: exchange_1.exchange.stateAddress,
                dexProgram: constants.DEX_PID[exchange_1.exchange.network],
                systemProgram: web3_js_1.SystemProgram.programId,
                openOrders: openOrdersPda,
                crossMarginAccount: crossMarginAccount,
                authority: authority,
                payer: authority,
                market: market,
                rent: web3_js_1.SYSVAR_RENT_PUBKEY,
                serumAuthority: exchange_1.exchange.serumAuthority,
                openOrdersMap,
            },
        }),
        openOrdersPda,
    ];
}
exports.initializeOpenOrdersV3Ix = initializeOpenOrdersV3Ix;
function closeOpenOrdersV4Ix(asset, userKey, crossMarginAccount, openOrders) {
    const [openOrdersMap, openOrdersMapNonce] = utils.getCrossOpenOrdersMap(exchange_1.exchange.programId, openOrders);
    let market = exchange_1.exchange.getPerpMarket(asset);
    return exchange_1.exchange.program.instruction.closeOpenOrdersV4(openOrdersMapNonce, (0, assets_1.toProgramAsset)(asset), {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            pricing: exchange_1.exchange.pricingAddress,
            dexProgram: constants.DEX_PID[exchange_1.exchange.network],
            openOrders,
            crossMarginAccount: crossMarginAccount,
            authority: userKey,
            market: market.address,
            serumAuthority: exchange_1.exchange.serumAuthority,
            openOrdersMap,
            eventQueue: market.serumMarket.eventQueueAddress,
            admin: exchange_1.exchange.state.admin,
            pricingAdmin: exchange_1.exchange.state.pricingAdmin,
        },
    });
}
exports.closeOpenOrdersV4Ix = closeOpenOrdersV4Ix;
function closeOpenOrdersV2Ix(market, userKey, marginAccount, openOrders) {
    const [openOrdersMap, openOrdersMapNonce] = utils.getOpenOrdersMap(exchange_1.exchange.programId, openOrders);
    return exchange_1.exchange.program.instruction.closeOpenOrdersV2(openOrdersMapNonce, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            dexProgram: constants.DEX_PID[exchange_1.exchange.network],
            openOrders,
            marginAccount: marginAccount,
            authority: userKey,
            market: market,
            serumAuthority: exchange_1.exchange.serumAuthority,
            openOrdersMap,
            admin: exchange_1.exchange.state.admin,
            pricingAdmin: exchange_1.exchange.state.pricingAdmin,
        },
    });
}
exports.closeOpenOrdersV2Ix = closeOpenOrdersV2Ix;
function placePerpOrderV5Ix(asset, price, size, side, orderType, reduceOnly, clientOrderId, tag, tifOffset, marginAccount, authority, openOrders, whitelistTradingFeesAccount, selfTradeBehavior) {
    if (tag.length > constants.MAX_ORDER_TAG_LENGTH) {
        throw Error(`Tag is too long! Max length = ${constants.MAX_ORDER_TAG_LENGTH}`);
    }
    let subExchange = exchange_1.exchange.getSubExchange(asset);
    let marketData = subExchange.markets.market;
    let remainingAccounts = whitelistTradingFeesAccount !== undefined
        ? [
            {
                pubkey: whitelistTradingFeesAccount,
                isSigner: false,
                isWritable: false,
            },
        ]
        : [];
    return exchange_1.exchange.program.instruction.placePerpOrderV5(new anchor.BN(price), new anchor.BN(size), types.toProgramSide(side), types.toProgramOrderType(orderType), reduceOnly, clientOrderId == 0 ? null : new anchor.BN(clientOrderId), new String(tag), tifOffset == 0 ? null : tifOffset, (0, assets_1.toProgramAsset)(asset), selfTradeBehavior != undefined
        ? types.toProgramSelfTradeBehavior(selfTradeBehavior)
        : null, {
        accounts: {
            authority: authority,
            placeOrderAccounts: {
                state: exchange_1.exchange.stateAddress,
                pricing: exchange_1.exchange.pricingAddress,
                marginAccount: marginAccount,
                dexProgram: constants.DEX_PID[exchange_1.exchange.network],
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                serumAuthority: exchange_1.exchange.serumAuthority,
                openOrders: openOrders,
                rent: web3_js_1.SYSVAR_RENT_PUBKEY,
                marketAccounts: {
                    market: marketData.serumMarket.address,
                    requestQueue: marketData.serumMarket.requestQueueAddress,
                    eventQueue: marketData.serumMarket.eventQueueAddress,
                    bids: marketData.serumMarket.bidsAddress,
                    asks: marketData.serumMarket.asksAddress,
                    coinVault: marketData.serumMarket.baseVaultAddress,
                    pcVault: marketData.serumMarket.quoteVaultAddress,
                    // User params.
                    orderPayerTokenAccount: side == types.Side.BID
                        ? marketData.quoteVault
                        : marketData.baseVault,
                    coinWallet: marketData.baseVault,
                    pcWallet: marketData.quoteVault,
                },
                oracle: constants.PYTH_PRICE_FEEDS[exchange_1.exchange.network][asset],
                oracleBackupFeed: web3_js_1.PublicKey.default,
                oracleBackupProgram: web3_js_1.PublicKey.default,
                marketMint: side == types.Side.BID
                    ? marketData.serumMarket.quoteMintAddress
                    : marketData.serumMarket.baseMintAddress,
                mintAuthority: exchange_1.exchange.mintAuthority,
                perpSyncQueue: exchange_1.exchange.pricing.perpSyncQueues[(0, assets_1.assetToIndex)(asset)],
            },
        },
        remainingAccounts,
    });
}
exports.placePerpOrderV5Ix = placePerpOrderV5Ix;
function placeMultiOrdersIx(asset, bidOrders, askOrders, orderType, marginAccount, authority, openOrders) {
    let subExchange = exchange_1.exchange.getSubExchange(asset);
    let marketData = subExchange.markets.market;
    return exchange_1.exchange.program.instruction.placeMultiOrders((0, assets_1.toProgramAsset)(asset), bidOrders, askOrders, types.toProgramOrderType(orderType), {
        accounts: {
            authority,
            state: exchange_1.exchange.stateAddress,
            pricing: exchange_1.exchange.pricingAddress,
            marginAccount,
            dexProgram: constants.DEX_PID[exchange_1.exchange.network],
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            serumAuthority: exchange_1.exchange.serumAuthority,
            openOrders,
            rent: web3_js_1.SYSVAR_RENT_PUBKEY,
            market: marketData.serumMarket.address,
            requestQueue: marketData.serumMarket.requestQueueAddress,
            eventQueue: marketData.serumMarket.eventQueueAddress,
            bids: marketData.serumMarket.bidsAddress,
            asks: marketData.serumMarket.asksAddress,
            marketBaseVault: marketData.serumMarket.baseVaultAddress,
            marketQuoteVault: marketData.serumMarket.quoteVaultAddress,
            // User params.
            zetaBaseVault: marketData.baseVault,
            zetaQuoteVault: marketData.quoteVault,
            oracle: constants.PYTH_PRICE_FEEDS[exchange_1.exchange.network][asset],
            oracleBackupFeed: web3_js_1.PublicKey.default,
            oracleBackupProgram: web3_js_1.PublicKey.default,
            marketBaseMint: marketData.serumMarket.baseMintAddress,
            marketQuoteMint: marketData.serumMarket.quoteMintAddress,
            mintAuthority: exchange_1.exchange.mintAuthority,
            perpSyncQueue: exchange_1.exchange.pricing.perpSyncQueues[(0, assets_1.assetToIndex)(asset)],
        },
    });
}
exports.placeMultiOrdersIx = placeMultiOrdersIx;
function placeTriggerOrderIx(asset, orderPrice, triggerPrice, triggerDirection, triggerTimestamp, triggerOrderBit, size, side, orderType, reduceOnly, tag, marginAccount, authority, openOrders) {
    let [triggerOrder, _nonce] = utils.getTriggerOrder(exchange_1.exchange.programId, marginAccount, Uint8Array.from([triggerOrderBit]));
    return exchange_1.exchange.program.instruction.placeTriggerOrder(triggerOrderBit, new anchor.BN(orderPrice), triggerPrice == 0 ? null : new anchor.BN(triggerPrice), triggerDirection == types.TriggerDirection.UNINITIALIZED
        ? null
        : types.toProgramTriggerDirection(triggerDirection), triggerTimestamp == 0 ? null : triggerTimestamp, new anchor.BN(size), types.toProgramSide(side), types.toProgramOrderType(orderType), reduceOnly, new String(tag), (0, assets_1.toProgramAsset)(asset), {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            openOrders: openOrders,
            authority: authority,
            marginAccount: marginAccount,
            pricing: exchange_1.exchange.pricingAddress,
            triggerOrder: triggerOrder,
            systemProgram: web3_js_1.SystemProgram.programId,
            dexProgram: constants.DEX_PID[exchange_1.exchange.network],
            market: exchange_1.exchange.getPerpMarket(asset).serumMarket.address,
        },
    });
}
exports.placeTriggerOrderIx = placeTriggerOrderIx;
function executeTriggerOrderV2Ix(asset, side, triggerOrderBit, triggerOrder, marginAccount, openOrders, payer) {
    let marketData = exchange_1.exchange.getPerpMarket(asset);
    return exchange_1.exchange.program.instruction.executeTriggerOrderV2(triggerOrderBit, {
        accounts: {
            payer: payer,
            triggerOrder: triggerOrder,
            placeOrderAccounts: {
                state: exchange_1.exchange.stateAddress,
                pricing: exchange_1.exchange.pricingAddress,
                marginAccount: marginAccount,
                dexProgram: constants.DEX_PID[exchange_1.exchange.network],
                tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                serumAuthority: exchange_1.exchange.serumAuthority,
                openOrders: openOrders,
                rent: web3_js_1.SYSVAR_RENT_PUBKEY,
                marketAccounts: {
                    market: marketData.serumMarket.address,
                    requestQueue: marketData.serumMarket.requestQueueAddress,
                    eventQueue: marketData.serumMarket.eventQueueAddress,
                    bids: marketData.serumMarket.bidsAddress,
                    asks: marketData.serumMarket.asksAddress,
                    coinVault: marketData.serumMarket.baseVaultAddress,
                    pcVault: marketData.serumMarket.quoteVaultAddress,
                    // User params.
                    orderPayerTokenAccount: side == types.Side.BID
                        ? marketData.quoteVault
                        : marketData.baseVault,
                    coinWallet: marketData.baseVault,
                    pcWallet: marketData.quoteVault,
                },
                oracle: constants.PYTH_PRICE_FEEDS[exchange_1.exchange.network][asset],
                oracleBackupFeed: web3_js_1.PublicKey.default,
                oracleBackupProgram: web3_js_1.PublicKey.default,
                marketMint: side == types.Side.BID
                    ? marketData.serumMarket.quoteMintAddress
                    : marketData.serumMarket.baseMintAddress,
                mintAuthority: exchange_1.exchange.mintAuthority,
                perpSyncQueue: exchange_1.exchange.pricing.perpSyncQueues[(0, assets_1.assetToIndex)(asset)],
            },
        },
    });
}
exports.executeTriggerOrderV2Ix = executeTriggerOrderV2Ix;
function takeTriggerOrderIx(asset, triggerOrder, triggerOrderBit, orderMarginAccount, takerMarginAccount, taker) {
    let marketData = exchange_1.exchange.getPerpMarket(asset);
    return exchange_1.exchange.program.instruction.takeTriggerOrder(triggerOrderBit, {
        accounts: {
            triggerOrder: triggerOrder,
            state: exchange_1.exchange.stateAddress,
            pricing: exchange_1.exchange.pricingAddress,
            oracle: constants.PYTH_PRICE_FEEDS[exchange_1.exchange.network][asset],
            oracleBackupFeed: web3_js_1.PublicKey.default,
            oracleBackupProgram: web3_js_1.PublicKey.default,
            bids: marketData.serumMarket.bidsAddress,
            asks: marketData.serumMarket.asksAddress,
            taker,
            takerMarginAccount,
            orderMarginAccount,
        },
    });
}
exports.takeTriggerOrderIx = takeTriggerOrderIx;
function cancelTriggerOrderV2Ix(triggerOrderBit, authority, triggerOrder, marginAccount) {
    return exchange_1.exchange.program.instruction.cancelTriggerOrderV2(triggerOrderBit, {
        accounts: {
            authority: authority,
            triggerOrder: triggerOrder,
            marginAccount: marginAccount,
        },
    });
}
exports.cancelTriggerOrderV2Ix = cancelTriggerOrderV2Ix;
function forceCancelTriggerOrderIx(triggerOrderBit, authority, triggerOrder, marginAccount, enforceTpslConditions = true) {
    return exchange_1.exchange.program.instruction.forceCancelTriggerOrder(triggerOrderBit, enforceTpslConditions, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            admin: authority,
            triggerOrder: triggerOrder,
            marginAccount: marginAccount,
        },
    });
}
exports.forceCancelTriggerOrderIx = forceCancelTriggerOrderIx;
function editTriggerOrderIx(newOrderPrice, newTriggerPrice, newTriggerDirection, newTriggerTimestamp, newSize, newSide, newOrderType, newReduceOnly, owner, triggerOrder, crossMarginAccount) {
    return exchange_1.exchange.program.instruction.editTriggerOrderV2(new anchor.BN(newOrderPrice), newTriggerPrice == 0 ? null : new anchor.BN(newTriggerPrice), newTriggerDirection == types.TriggerDirection.UNINITIALIZED ||
        newTriggerDirection == undefined
        ? null
        : types.toProgramTriggerDirection(newTriggerDirection), newTriggerTimestamp == 0 || newTriggerTimestamp == undefined
        ? null
        : new anchor.BN(newTriggerTimestamp), new anchor.BN(newSize), types.toProgramSide(newSide), types.toProgramOrderType(newOrderType), newReduceOnly, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            owner: owner,
            triggerOrder: triggerOrder,
            marginAccount: crossMarginAccount,
        },
    });
}
exports.editTriggerOrderIx = editTriggerOrderIx;
function cancelOrderIx(asset, userKey, marginAccount, openOrders, orderId, side) {
    let marketData = exchange_1.exchange.getPerpMarket(asset);
    return exchange_1.exchange.program.instruction.cancelOrder(types.toProgramSide(side), orderId, (0, assets_1.toProgramAsset)(asset), {
        accounts: {
            authority: userKey,
            cancelAccounts: {
                state: exchange_1.exchange.stateAddress,
                marginAccount: marginAccount,
                dexProgram: constants.DEX_PID[exchange_1.exchange.network],
                serumAuthority: exchange_1.exchange.serumAuthority,
                openOrders,
                market: marketData.address,
                bids: marketData.serumMarket.bidsAddress,
                asks: marketData.serumMarket.asksAddress,
                eventQueue: marketData.serumMarket.eventQueueAddress,
            },
        },
    });
}
exports.cancelOrderIx = cancelOrderIx;
function cancelOrderNoErrorIx(asset, userKey, marginAccount, openOrders, orderId, side) {
    let marketData = exchange_1.exchange.getPerpMarket(asset);
    return exchange_1.exchange.program.instruction.cancelOrderNoError(types.toProgramSide(side), orderId, (0, assets_1.toProgramAsset)(asset), {
        accounts: {
            authority: userKey,
            cancelAccounts: {
                state: exchange_1.exchange.stateAddress,
                marginAccount: marginAccount,
                dexProgram: constants.DEX_PID[exchange_1.exchange.network],
                serumAuthority: exchange_1.exchange.serumAuthority,
                openOrders,
                market: marketData.address,
                bids: marketData.serumMarket.bidsAddress,
                asks: marketData.serumMarket.asksAddress,
                eventQueue: marketData.serumMarket.eventQueueAddress,
            },
        },
    });
}
exports.cancelOrderNoErrorIx = cancelOrderNoErrorIx;
function pruneExpiredTIFOrdersIxV2(asset, limit) {
    let marketData = exchange_1.exchange.getPerpMarket(asset);
    return exchange_1.exchange.program.instruction.pruneExpiredTifOrdersV2(limit, {
        accounts: {
            dexProgram: constants.DEX_PID[exchange_1.exchange.network],
            state: exchange_1.exchange.stateAddress,
            serumAuthority: exchange_1.exchange.serumAuthority,
            market: marketData.address,
            bids: marketData.serumMarket.bidsAddress,
            asks: marketData.serumMarket.asksAddress,
            eventQueue: marketData.serumMarket.eventQueueAddress,
        },
    });
}
exports.pruneExpiredTIFOrdersIxV2 = pruneExpiredTIFOrdersIxV2;
function pruneExpiredTIFOrdersIx(asset) {
    let marketData = exchange_1.exchange.getPerpMarket(asset);
    return exchange_1.exchange.program.instruction.pruneExpiredTifOrders({
        accounts: {
            dexProgram: constants.DEX_PID[exchange_1.exchange.network],
            state: exchange_1.exchange.stateAddress,
            serumAuthority: exchange_1.exchange.serumAuthority,
            market: marketData.address,
            bids: marketData.serumMarket.bidsAddress,
            asks: marketData.serumMarket.asksAddress,
            eventQueue: marketData.serumMarket.eventQueueAddress,
        },
    });
}
exports.pruneExpiredTIFOrdersIx = pruneExpiredTIFOrdersIx;
function cancelAllMarketOrdersIx(asset, userKey, marginAccount, openOrders) {
    let marketData = exchange_1.exchange.getPerpMarket(asset);
    return exchange_1.exchange.program.instruction.cancelAllMarketOrders((0, assets_1.toProgramAsset)(asset), {
        accounts: {
            authority: userKey,
            cancelAccounts: {
                state: exchange_1.exchange.stateAddress,
                marginAccount: marginAccount,
                dexProgram: constants.DEX_PID[exchange_1.exchange.network],
                serumAuthority: exchange_1.exchange.serumAuthority,
                openOrders,
                market: marketData.address,
                bids: marketData.serumMarket.bidsAddress,
                asks: marketData.serumMarket.asksAddress,
                eventQueue: marketData.serumMarket.eventQueueAddress,
            },
        },
    });
}
exports.cancelAllMarketOrdersIx = cancelAllMarketOrdersIx;
function cancelOrderByClientOrderIdIx(asset, userKey, marginAccount, openOrders, clientOrderId) {
    let marketData = exchange_1.exchange.getPerpMarket(asset);
    return exchange_1.exchange.program.instruction.cancelOrderByClientOrderId(clientOrderId, (0, assets_1.toProgramAsset)(asset), {
        accounts: {
            authority: userKey,
            cancelAccounts: {
                state: exchange_1.exchange.stateAddress,
                marginAccount: marginAccount,
                dexProgram: constants.DEX_PID[exchange_1.exchange.network],
                serumAuthority: exchange_1.exchange.serumAuthority,
                openOrders,
                market: marketData.address,
                bids: marketData.serumMarket.bidsAddress,
                asks: marketData.serumMarket.asksAddress,
                eventQueue: marketData.serumMarket.eventQueueAddress,
            },
        },
    });
}
exports.cancelOrderByClientOrderIdIx = cancelOrderByClientOrderIdIx;
function cancelOrderByClientOrderIdNoErrorIx(asset, userKey, marginAccount, openOrders, clientOrderId) {
    let marketData = exchange_1.exchange.getPerpMarket(asset);
    return exchange_1.exchange.program.instruction.cancelOrderByClientOrderIdNoError(clientOrderId, (0, assets_1.toProgramAsset)(asset), {
        accounts: {
            authority: userKey,
            cancelAccounts: {
                state: exchange_1.exchange.stateAddress,
                marginAccount: marginAccount,
                dexProgram: constants.DEX_PID[exchange_1.exchange.network],
                serumAuthority: exchange_1.exchange.serumAuthority,
                openOrders,
                market: marketData.address,
                bids: marketData.serumMarket.bidsAddress,
                asks: marketData.serumMarket.asksAddress,
                eventQueue: marketData.serumMarket.eventQueueAddress,
            },
        },
    });
}
exports.cancelOrderByClientOrderIdNoErrorIx = cancelOrderByClientOrderIdNoErrorIx;
function forceCancelOrderByOrderIdV2Ix(asset, marginAccount, openOrders, orderId, side) {
    let assetIndex = (0, assets_1.assetToIndex)(asset);
    let marketData = exchange_1.exchange.getPerpMarket(asset);
    return exchange_1.exchange.program.instruction.forceCancelOrderByOrderIdV2(types.toProgramSide(side), orderId, (0, assets_1.toProgramAsset)(asset), {
        accounts: {
            pricing: exchange_1.exchange.pricingAddress,
            oracle: constants.PYTH_PRICE_FEEDS[exchange_1.exchange.network][asset],
            oracleBackupFeed: web3_js_1.PublicKey.default,
            oracleBackupProgram: web3_js_1.PublicKey.default,
            cancelAccounts: {
                state: exchange_1.exchange.stateAddress,
                marginAccount: marginAccount,
                dexProgram: constants.DEX_PID[exchange_1.exchange.network],
                serumAuthority: exchange_1.exchange.serumAuthority,
                openOrders,
                market: marketData.address,
                bids: marketData.serumMarket.bidsAddress,
                asks: marketData.serumMarket.asksAddress,
                eventQueue: marketData.serumMarket.eventQueueAddress,
            },
        },
    });
}
exports.forceCancelOrderByOrderIdV2Ix = forceCancelOrderByOrderIdV2Ix;
function forceCancelOrdersV2Ix(asset, marginAccount, openOrders) {
    let assetIndex = (0, assets_1.assetToIndex)(asset);
    let marketData = exchange_1.exchange.getPerpMarket(asset);
    return exchange_1.exchange.program.instruction.forceCancelOrdersV2((0, assets_1.toProgramAsset)(asset), {
        accounts: {
            pricing: exchange_1.exchange.pricingAddress,
            oracle: constants.PYTH_PRICE_FEEDS[exchange_1.exchange.network][asset],
            oracleBackupFeed: web3_js_1.PublicKey.default,
            oracleBackupProgram: web3_js_1.PublicKey.default,
            cancelAccounts: {
                state: exchange_1.exchange.stateAddress,
                marginAccount: marginAccount,
                dexProgram: constants.DEX_PID[exchange_1.exchange.network],
                serumAuthority: exchange_1.exchange.serumAuthority,
                openOrders,
                market: marketData.address,
                bids: marketData.serumMarket.bidsAddress,
                asks: marketData.serumMarket.asksAddress,
                eventQueue: marketData.serumMarket.eventQueueAddress,
            },
        },
    });
}
exports.forceCancelOrdersV2Ix = forceCancelOrdersV2Ix;
function initializeZetaMarketTIFEpochCyclesIx(asset, cycleLength) {
    return exchange_1.exchange.program.instruction.initializeMarketTifEpochCycle(cycleLength, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            admin: exchange_1.exchange.state.admin,
            market: exchange_1.exchange.getPerpMarket(asset).address,
            serumAuthority: exchange_1.exchange.serumAuthority,
            dexProgram: constants.DEX_PID[exchange_1.exchange.network],
        },
    });
}
exports.initializeZetaMarketTIFEpochCyclesIx = initializeZetaMarketTIFEpochCyclesIx;
async function initializeZetaMarketTxs(asset, seedIndex, requestQueue, eventQueue, bids, asks, marketIndexes, zetaGroupAddress) {
    const [market, marketNonce] = utils.getMarketUninitialized(exchange_1.exchange.programId, zetaGroupAddress, seedIndex);
    const [vaultOwner, vaultSignerNonce] = utils.getSerumVaultOwnerAndNonce(market, constants.DEX_PID[exchange_1.exchange.network]);
    const [baseMint, baseMintNonce] = utils.getBaseMint(exchange_1.exchange.program.programId, market);
    const [quoteMint, quoteMintNonce] = utils.getQuoteMint(exchange_1.exchange.program.programId, market);
    // Create SPL token vaults for serum trading owned by the Zeta program
    const [zetaBaseVault, zetaBaseVaultNonce] = utils.getZetaVault(exchange_1.exchange.program.programId, baseMint);
    const [zetaQuoteVault, zetaQuoteVaultNonce] = utils.getZetaVault(exchange_1.exchange.program.programId, quoteMint);
    // Create SPL token vaults for serum trading owned by the DEX program
    const [dexBaseVault, dexBaseVaultNonce] = utils.getSerumVault(exchange_1.exchange.program.programId, baseMint);
    const [dexQuoteVault, dexQuoteVaultNonce] = utils.getSerumVault(exchange_1.exchange.program.programId, quoteMint);
    let fromPubkey = exchange_1.exchange.useLedger
        ? exchange_1.exchange.ledgerWallet.publicKey
        : exchange_1.exchange.provider.wallet.publicKey;
    const tx = new web3_js_1.Transaction();
    tx.add(web3_js_1.SystemProgram.createAccount({
        fromPubkey,
        newAccountPubkey: requestQueue,
        lamports: await exchange_1.exchange.provider.connection.getMinimumBalanceForRentExemption(5120 + 12),
        space: 5120 + 12,
        programId: constants.DEX_PID[exchange_1.exchange.network],
    }), web3_js_1.SystemProgram.createAccount({
        fromPubkey,
        newAccountPubkey: eventQueue,
        lamports: await exchange_1.exchange.provider.connection.getMinimumBalanceForRentExemption(262144 + 12),
        space: 262144 + 12,
        programId: constants.DEX_PID[exchange_1.exchange.network],
    }), web3_js_1.SystemProgram.createAccount({
        fromPubkey,
        newAccountPubkey: bids,
        lamports: await exchange_1.exchange.provider.connection.getMinimumBalanceForRentExemption(65536 + 12),
        space: 65536 + 12,
        programId: constants.DEX_PID[exchange_1.exchange.network],
    }), web3_js_1.SystemProgram.createAccount({
        fromPubkey,
        newAccountPubkey: asks,
        lamports: await exchange_1.exchange.provider.connection.getMinimumBalanceForRentExemption(65536 + 12),
        space: 65536 + 12,
        programId: constants.DEX_PID[exchange_1.exchange.network],
    }));
    let tx2 = new web3_js_1.Transaction().add(exchange_1.exchange.program.instruction.initializeMarketPda((0, assets_1.toProgramAsset)(asset), {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            marketIndexes,
            pricing: exchange_1.exchange.pricingAddress,
            admin: exchange_1.exchange.state.admin,
            market,
            systemProgram: web3_js_1.SystemProgram.programId,
            rent: web3_js_1.SYSVAR_RENT_PUBKEY,
        },
    }), exchange_1.exchange.program.instruction.initializeZetaMarket({
        asset: (0, assets_1.toProgramAsset)(asset),
        vaultSignerNonce,
    }, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            marketIndexes: marketIndexes,
            pricing: exchange_1.exchange.pricingAddress,
            admin: exchange_1.exchange.state.admin,
            market,
            requestQueue: requestQueue,
            eventQueue: eventQueue,
            bids: bids,
            asks: asks,
            baseMint,
            quoteMint,
            dexBaseVault,
            dexQuoteVault,
            vaultOwner,
            mintAuthority: exchange_1.exchange.mintAuthority,
            serumAuthority: exchange_1.exchange.serumAuthority,
            dexProgram: constants.DEX_PID[exchange_1.exchange.network],
            systemProgram: web3_js_1.SystemProgram.programId,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            rent: web3_js_1.SYSVAR_RENT_PUBKEY,
        },
    }), exchange_1.exchange.program.instruction.initializeZetaSpecificMarketVaults((0, assets_1.toProgramAsset)(asset), {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            marketIndexes,
            pricing: exchange_1.exchange.pricingAddress,
            admin: exchange_1.exchange.state.admin,
            market,
            baseMint,
            quoteMint,
            zetaBaseVault,
            zetaQuoteVault,
            serumAuthority: exchange_1.exchange.serumAuthority,
            systemProgram: web3_js_1.SystemProgram.programId,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            rent: web3_js_1.SYSVAR_RENT_PUBKEY,
        },
    }));
    return [tx, tx2];
}
exports.initializeZetaMarketTxs = initializeZetaMarketTxs;
function initializeUnderlyingIx(underlyingMint, flexUnderlying) {
    let [underlying, _underlyingNonce] = flexUnderlying
        ? utils.getFlexUnderlying(exchange_1.exchange.programId, exchange_1.exchange.state.numFlexUnderlyings)
        : utils.getUnderlying(exchange_1.exchange.programId, exchange_1.exchange.state.numUnderlyings);
    return exchange_1.exchange.program.instruction.initializeUnderlying(flexUnderlying, {
        accounts: {
            admin: exchange_1.exchange.state.admin,
            zetaProgram: exchange_1.exchange.programId,
            state: exchange_1.exchange.stateAddress,
            systemProgram: web3_js_1.SystemProgram.programId,
            underlying: underlying,
            underlyingMint: underlyingMint,
        },
    });
}
exports.initializeUnderlyingIx = initializeUnderlyingIx;
function initializePerpSyncQueueIx(asset) {
    let [perpSyncQueue, nonce] = utils.getPerpSyncQueue(exchange_1.exchange.programId, exchange_1.exchange.getSubExchange(asset).zetaGroupAddress);
    return exchange_1.exchange.program.instruction.initializePerpSyncQueue(nonce, (0, assets_1.toProgramAsset)(asset), {
        accounts: {
            admin: exchange_1.exchange.state.admin,
            zetaProgram: exchange_1.exchange.programId,
            state: exchange_1.exchange.stateAddress,
            perpSyncQueue,
            pricing: exchange_1.exchange.pricingAddress,
            systemProgram: web3_js_1.SystemProgram.programId,
        },
    });
}
exports.initializePerpSyncQueueIx = initializePerpSyncQueueIx;
function collectTreasuryFundsIx(collectionTokenAccount, amount, admin) {
    return exchange_1.exchange.program.instruction.collectTreasuryFunds(amount, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            treasuryWallet: exchange_1.exchange.treasuryWalletAddress,
            collectionTokenAccount,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            admin,
        },
    });
}
exports.collectTreasuryFundsIx = collectTreasuryFundsIx;
function treasuryMovementIx(treasuryMovementType, amount) {
    return exchange_1.exchange.program.instruction.treasuryMovement(types.toProgramTreasuryMovementType(treasuryMovementType), amount, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            insuranceVault: exchange_1.exchange.getInsuranceVaultAddress(),
            treasuryWallet: exchange_1.exchange.treasuryWalletAddress,
            referralsRewardsWallet: exchange_1.exchange.referralsRewardsWalletAddress,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            admin: exchange_1.exchange.provider.wallet.publicKey,
        },
    });
}
exports.treasuryMovementIx = treasuryMovementIx;
function rebalanceInsuranceVaultIx(remainingAccounts) {
    return exchange_1.exchange.program.instruction.rebalanceInsuranceVaultV2({
        accounts: {
            state: exchange_1.exchange.stateAddress,
            zetaVault: exchange_1.exchange.combinedVaultAddress,
            insuranceVault: exchange_1.exchange.combinedInsuranceVaultAddress,
            treasuryWallet: exchange_1.exchange.treasuryWalletAddress,
            treasurySplitTokenAccount: exchange_1.exchange.state.treasurySplitTokenAccount,
            socializedLossAccount: exchange_1.exchange.combinedSocializedLossAccountAddress,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
        },
        remainingAccounts,
    });
}
exports.rebalanceInsuranceVaultIx = rebalanceInsuranceVaultIx;
function liquidateV2Ix(asset, liquidator, liquidatorAccount, market, liquidatedAccount, size) {
    let liquidateSize = new anchor.BN(size);
    let asset_index = (0, assets_1.assetToIndex)(asset);
    return exchange_1.exchange.program.instruction.liquidateV2(liquidateSize, (0, assets_1.toProgramAsset)(asset), {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            liquidator,
            liquidatorAccount,
            pricing: exchange_1.exchange.pricingAddress,
            oracle: constants.PYTH_PRICE_FEEDS[exchange_1.exchange.network][asset],
            oracleBackupFeed: web3_js_1.PublicKey.default,
            oracleBackupProgram: web3_js_1.PublicKey.default,
            market,
            liquidatedAccount,
        },
    });
}
exports.liquidateV2Ix = liquidateV2Ix;
function crankMarketIx(asset, market, eventQueue, dexProgram, remainingAccounts) {
    return exchange_1.exchange.program.instruction.crankEventQueue((0, assets_1.toProgramAsset)(asset), {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            pricing: exchange_1.exchange.pricingAddress,
            perpSyncQueue: exchange_1.exchange.getSubExchange(asset).perpSyncQueueAddress,
            market,
            eventQueue,
            dexProgram,
            serumAuthority: exchange_1.exchange.serumAuthority,
        },
        remainingAccounts,
    });
}
exports.crankMarketIx = crankMarketIx;
function updatePricingV2Ix(asset) {
    let subExchange = exchange_1.exchange.getSubExchange(asset);
    let marketData = exchange_1.exchange.getPerpMarket(asset);
    let asset_index = (0, assets_1.assetToIndex)(asset);
    return exchange_1.exchange.program.instruction.updatePricingV2((0, assets_1.toProgramAsset)(asset), {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            pricing: exchange_1.exchange.pricingAddress,
            oracle: constants.PYTH_PRICE_FEEDS[exchange_1.exchange.network][asset],
            oracleBackupFeed: web3_js_1.PublicKey.default,
            oracleBackupProgram: web3_js_1.PublicKey.default,
            perpMarket: marketData.address,
            perpBids: subExchange.markets.market.serumMarket.bidsAddress,
            perpAsks: subExchange.markets.market.serumMarket.asksAddress,
        },
    });
}
exports.updatePricingV2Ix = updatePricingV2Ix;
function updatePricingV3Ix(asset, price, timestamp) {
    let subExchange = exchange_1.exchange.getSubExchange(asset);
    let marketData = exchange_1.exchange.getPerpMarket(asset);
    let asset_index = (0, assets_1.assetToIndex)(asset);
    return exchange_1.exchange.program.instruction.updatePricingV3((0, assets_1.toProgramAsset)(asset), price, timestamp, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            pricing: exchange_1.exchange.pricingAddress,
            oracle: constants.PYTH_PRICE_FEEDS[exchange_1.exchange.network][asset],
            perpMarket: marketData.address,
            perpBids: subExchange.markets.market.serumMarket.bidsAddress,
            perpAsks: subExchange.markets.market.serumMarket.asksAddress,
            pricingAdmin: exchange_1.exchange.state.pricingAdmin,
        },
    });
}
exports.updatePricingV3Ix = updatePricingV3Ix;
function applyPerpFundingIx(asset, remainingAccounts) {
    return exchange_1.exchange.program.instruction.applyPerpFunding((0, assets_1.toProgramAsset)(asset), {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            pricing: exchange_1.exchange.pricingAddress,
        },
        remainingAccounts, // margin accounts
    });
}
exports.applyPerpFundingIx = applyPerpFundingIx;
function updateTreasurySplitTokenAccountIx(treasurySplitTokenAccount, treasurySplitPercentage, admin) {
    return exchange_1.exchange.program.instruction.updateTreasurySplitTokenAccount(treasurySplitPercentage, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            admin,
            treasurySplitTokenAccount,
        },
    });
}
exports.updateTreasurySplitTokenAccountIx = updateTreasurySplitTokenAccountIx;
function updateMarginParametersIx(asset, args, admin) {
    return exchange_1.exchange.program.instruction.updateMarginParameters(args, (0, assets_1.toProgramAsset)(asset), {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            pricing: exchange_1.exchange.pricingAddress,
            admin,
        },
    });
}
exports.updateMarginParametersIx = updateMarginParametersIx;
function updatePerpParametersIx(asset, args, admin) {
    return exchange_1.exchange.program.instruction.updatePerpParameters(args, (0, assets_1.toProgramAsset)(asset), {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            pricing: exchange_1.exchange.pricingAddress,
            admin,
        },
    });
}
exports.updatePerpParametersIx = updatePerpParametersIx;
function initializeZetaPricingIx(perpArgs, marginArgs) {
    let [pricing, pricingNonce] = utils.getPricing(exchange_1.exchange.programId);
    return exchange_1.exchange.program.instruction.initializeZetaPricing({
        minFundingRatePercent: perpArgs.minFundingRatePercent,
        maxFundingRatePercent: perpArgs.maxFundingRatePercent,
        perpImpactCashDelta: perpArgs.perpImpactCashDelta,
        marginInitial: marginArgs.futureMarginInitial,
        marginMaintenance: marginArgs.futureMarginMaintenance,
        pricingNonce: pricingNonce,
    }, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            pricing: pricing,
            admin: exchange_1.exchange.state.admin,
            systemProgram: web3_js_1.SystemProgram.programId,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            rent: web3_js_1.SYSVAR_RENT_PUBKEY,
        },
    });
}
exports.initializeZetaPricingIx = initializeZetaPricingIx;
function updateZetaPricingPubkeysIx(args) {
    return exchange_1.exchange.program.instruction.updateZetaPricingPubkeys(args, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            pricing: exchange_1.exchange.pricingAddress,
            admin: exchange_1.exchange.state.admin,
        },
    });
}
exports.updateZetaPricingPubkeysIx = updateZetaPricingPubkeysIx;
function initializeZetaStateIx(stateAddress, stateNonce, serumAuthority, treasuryWallet, referralsAdmin, referralsRewardsWallet, serumNonce, mintAuthority, mintAuthorityNonce, params, secondaryAdmin) {
    let args = params;
    args["stateNonce"] = stateNonce;
    args["serumNonce"] = serumNonce;
    args["mintAuthNonce"] = mintAuthorityNonce;
    return exchange_1.exchange.program.instruction.initializeZetaState(args, {
        accounts: {
            state: stateAddress,
            serumAuthority,
            mintAuthority,
            treasuryWallet,
            referralsAdmin,
            referralsRewardsWallet,
            rent: web3_js_1.SYSVAR_RENT_PUBKEY,
            systemProgram: web3_js_1.SystemProgram.programId,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            usdcMint: exchange_1.exchange.usdcMintAddress,
            admin: exchange_1.exchange.provider.wallet.publicKey,
            secondaryAdmin: secondaryAdmin,
        },
    });
}
exports.initializeZetaStateIx = initializeZetaStateIx;
function initializeZetaTreasuryWalletIx() {
    return exchange_1.exchange.program.instruction.initializeZetaTreasuryWallet({
        accounts: {
            state: exchange_1.exchange.stateAddress,
            treasuryWallet: exchange_1.exchange.treasuryWalletAddress,
            rent: web3_js_1.SYSVAR_RENT_PUBKEY,
            systemProgram: web3_js_1.SystemProgram.programId,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            usdcMint: exchange_1.exchange.usdcMintAddress,
            admin: exchange_1.exchange.provider.wallet.publicKey,
        },
    });
}
exports.initializeZetaTreasuryWalletIx = initializeZetaTreasuryWalletIx;
function initializeZetaReferralsRewardsWalletIx() {
    return exchange_1.exchange.program.instruction.initializeZetaReferralsRewardsWallet({
        accounts: {
            state: exchange_1.exchange.stateAddress,
            referralsRewardsWallet: exchange_1.exchange.referralsRewardsWalletAddress,
            rent: web3_js_1.SYSVAR_RENT_PUBKEY,
            systemProgram: web3_js_1.SystemProgram.programId,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
            usdcMint: exchange_1.exchange.usdcMintAddress,
            admin: exchange_1.exchange.provider.wallet.publicKey,
        },
    });
}
exports.initializeZetaReferralsRewardsWalletIx = initializeZetaReferralsRewardsWalletIx;
function updateZetaStateIx(params, admin) {
    return exchange_1.exchange.program.instruction.updateZetaState(params, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            admin,
        },
    });
}
exports.updateZetaStateIx = updateZetaStateIx;
function addPerpMarketIndexIx(asset, marketIndexes) {
    return exchange_1.exchange.program.instruction.addPerpMarketIndex((0, assets_1.toProgramAsset)(asset), {
        accounts: {
            marketIndexes,
            pricing: exchange_1.exchange.pricingAddress,
        },
    });
}
exports.addPerpMarketIndexIx = addPerpMarketIndexIx;
function initializeMarketIndexesIx(asset, marketIndexes, nonce) {
    return exchange_1.exchange.program.instruction.initializeMarketIndexes(nonce, (0, assets_1.toProgramAsset)(asset), {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            marketIndexes: marketIndexes,
            admin: exchange_1.exchange.state.admin,
            systemProgram: web3_js_1.SystemProgram.programId,
            pricing: exchange_1.exchange.pricingAddress,
        },
    });
}
exports.initializeMarketIndexesIx = initializeMarketIndexesIx;
function addMarketIndexesIx(asset, marketIndexes) {
    return exchange_1.exchange.program.instruction.addMarketIndexes({
        accounts: {
            marketIndexes,
            zetaGroup: exchange_1.exchange.getZetaGroupAddress(asset),
        },
    });
}
exports.addMarketIndexesIx = addMarketIndexesIx;
function initializeWhitelistDepositAccountIx(asset, user, admin) {
    let [whitelistDepositAccount, whitelistDepositNonce] = utils.getUserWhitelistDepositAccount(exchange_1.exchange.program.programId, user);
    return exchange_1.exchange.program.instruction.initializeWhitelistDepositAccount(whitelistDepositNonce, {
        accounts: {
            whitelistDepositAccount,
            admin,
            user: user,
            systemProgram: web3_js_1.SystemProgram.programId,
            state: exchange_1.exchange.stateAddress,
        },
    });
}
exports.initializeWhitelistDepositAccountIx = initializeWhitelistDepositAccountIx;
function initializeWhitelistInsuranceAccountIx(user, admin) {
    let [whitelistInsuranceAccount, whitelistInsuranceNonce] = utils.getUserWhitelistInsuranceAccount(exchange_1.exchange.program.programId, user);
    return exchange_1.exchange.program.instruction.initializeWhitelistInsuranceAccount(whitelistInsuranceNonce, {
        accounts: {
            whitelistInsuranceAccount,
            admin,
            user: user,
            systemProgram: web3_js_1.SystemProgram.programId,
            state: exchange_1.exchange.stateAddress,
        },
    });
}
exports.initializeWhitelistInsuranceAccountIx = initializeWhitelistInsuranceAccountIx;
function initializeWhitelistTradingFeesAccountIx(user, admin) {
    let [whitelistTradingFeesAccount, whitelistTradingFeesNonce] = utils.getUserWhitelistTradingFeesAccount(exchange_1.exchange.program.programId, user);
    return exchange_1.exchange.program.instruction.initializeWhitelistTradingFeesAccount(whitelistTradingFeesNonce, {
        accounts: {
            whitelistTradingFeesAccount,
            admin,
            user: user,
            systemProgram: web3_js_1.SystemProgram.programId,
            state: exchange_1.exchange.stateAddress,
        },
    });
}
exports.initializeWhitelistTradingFeesAccountIx = initializeWhitelistTradingFeesAccountIx;
function settlePositionsHaltedTxs(asset, marginAccounts, admin) {
    let txs = [];
    for (var i = 0; i < marginAccounts.length; i += constants.MAX_SETTLEMENT_ACCOUNTS) {
        let slice = marginAccounts.slice(i, i + constants.MAX_SETTLEMENT_ACCOUNTS);
        txs.push(new web3_js_1.Transaction().add(settlePositionsHaltedIx(asset, slice, admin)));
    }
    return txs;
}
exports.settlePositionsHaltedTxs = settlePositionsHaltedTxs;
function settlePositionsHaltedIx(asset, marginAccounts, admin) {
    return exchange_1.exchange.program.instruction.settlePositionsHalted((0, assets_1.toProgramAsset)(asset), {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            pricing: exchange_1.exchange.pricingAddress,
            admin,
        },
        remainingAccounts: marginAccounts,
    });
}
exports.settlePositionsHaltedIx = settlePositionsHaltedIx;
function cleanZetaMarketsIx(asset, marketAccounts) {
    return exchange_1.exchange.program.instruction.cleanZetaMarkets({
        accounts: {
            state: exchange_1.exchange.stateAddress,
            zetaGroup: exchange_1.exchange.getZetaGroupAddress(asset),
        },
        remainingAccounts: marketAccounts,
    });
}
exports.cleanZetaMarketsIx = cleanZetaMarketsIx;
function cleanZetaMarketHaltedIx(asset) {
    let marketData = exchange_1.exchange.getPerpMarket(asset);
    return exchange_1.exchange.program.instruction.cleanZetaMarketHalted((0, assets_1.toProgramAsset)(asset), {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            market: marketData.address,
            bids: marketData.serumMarket.bidsAddress,
            asks: marketData.serumMarket.asksAddress,
        },
    });
}
exports.cleanZetaMarketHaltedIx = cleanZetaMarketHaltedIx;
function cancelOrderHaltedIx(asset, account, openOrders, orderId, side) {
    let marketData = exchange_1.exchange.getPerpMarket(asset);
    return exchange_1.exchange.program.instruction.cancelOrderHalted(types.toProgramSide(side), orderId, (0, assets_1.toProgramAsset)(asset), {
        accounts: {
            cancelAccounts: {
                state: exchange_1.exchange.stateAddress,
                marginAccount: account,
                dexProgram: constants.DEX_PID[exchange_1.exchange.network],
                serumAuthority: exchange_1.exchange.serumAuthority,
                openOrders,
                market: marketData.address,
                bids: marketData.serumMarket.bidsAddress,
                asks: marketData.serumMarket.asksAddress,
                eventQueue: marketData.serumMarket.eventQueueAddress,
            },
        },
    });
}
exports.cancelOrderHaltedIx = cancelOrderHaltedIx;
function haltIx(asset, admin) {
    return exchange_1.exchange.program.instruction.halt((0, assets_1.toProgramAsset)(asset), {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            pricing: exchange_1.exchange.pricingAddress,
            admin,
        },
    });
}
exports.haltIx = haltIx;
function unhaltIx(asset, admin) {
    return exchange_1.exchange.program.instruction.unhalt((0, assets_1.toProgramAsset)(asset), {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            pricing: exchange_1.exchange.pricingAddress,
            admin,
        },
    });
}
exports.unhaltIx = unhaltIx;
function updateHaltStateIx(args, admin) {
    return exchange_1.exchange.program.instruction.updateHaltState(args, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            admin,
        },
    });
}
exports.updateHaltStateIx = updateHaltStateIx;
function updateAdminIx(secondary, admin, newAdmin) {
    let accounts = {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            admin,
            newAdmin,
        },
    };
    if (secondary) {
        return exchange_1.exchange.program.instruction.updateSecondaryAdmin(accounts);
    }
    return exchange_1.exchange.program.instruction.updateAdmin(accounts);
}
exports.updateAdminIx = updateAdminIx;
function updatePricingAdminIx(secondary, admin, newAdmin) {
    let accounts = {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            admin,
            newAdmin,
        },
    };
    if (secondary) {
        return exchange_1.exchange.program.instruction.updatePricingAdmin(accounts);
    }
    return exchange_1.exchange.program.instruction.updateAdmin(accounts);
}
exports.updatePricingAdminIx = updatePricingAdminIx;
function initializeReferrerAccountsIx(id, user, referrerIdAccount, referrerPubkeyAccount) {
    if (profanityMatcher.hasMatch(id)) {
        throw Error("ID has profanity, be nice!");
    }
    return exchange_1.exchange.program.instruction.initializeReferrerAccounts(id, {
        accounts: {
            authority: user,
            referrerIdAccount,
            referrerPubkeyAccount,
            systemProgram: web3_js_1.SystemProgram.programId,
        },
    });
}
exports.initializeReferrerAccountsIx = initializeReferrerAccountsIx;
function closeReferrerAccountsIx(user, referrerIdAccount, referrerPubkeyAccount) {
    return exchange_1.exchange.program.instruction.closeReferrerAccounts({
        accounts: {
            authority: user,
            referrerIdAccount,
            referrerPubkeyAccount,
            state: exchange_1.exchange.stateAddress,
            admin: exchange_1.exchange.state.admin,
            pricingAdmin: exchange_1.exchange.state.pricingAdmin,
        },
    });
}
exports.closeReferrerAccountsIx = closeReferrerAccountsIx;
function updateReferralsAdminIx(admin, newReferralsAdmin) {
    return exchange_1.exchange.program.instruction.updateReferralsAdmin({
        accounts: {
            state: exchange_1.exchange.stateAddress,
            admin,
            newAdmin: newReferralsAdmin,
        },
    });
}
exports.updateReferralsAdminIx = updateReferralsAdminIx;
function settleDexFundsTxs(asset, vaultOwner, remainingAccounts) {
    let market = exchange_1.exchange.getSubExchange(asset).markets.getMarket();
    let accounts = {
        state: exchange_1.exchange.stateAddress,
        market: market.address,
        zetaBaseVault: market.baseVault,
        zetaQuoteVault: market.quoteVault,
        dexBaseVault: market.serumMarket.baseVaultAddress,
        dexQuoteVault: market.serumMarket.quoteVaultAddress,
        vaultOwner,
        mintAuthority: exchange_1.exchange.mintAuthority,
        serumAuthority: exchange_1.exchange.serumAuthority,
        dexProgram: constants.DEX_PID[exchange_1.exchange.network],
        tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
    };
    let txs = [];
    for (var j = 0; j < remainingAccounts.length; j += constants.MAX_SETTLE_ACCOUNTS) {
        let tx = new web3_js_1.Transaction();
        let slice = remainingAccounts.slice(j, j + constants.MAX_SETTLE_ACCOUNTS);
        tx.add(exchange_1.exchange.program.instruction.settleDexFunds({
            accounts,
            remainingAccounts: slice,
        }));
        txs.push(tx);
    }
    return txs;
}
exports.settleDexFundsTxs = settleDexFundsTxs;
function settleDexFundsIx(asset, vaultOwner, openOrders) {
    let market = exchange_1.exchange.getSubExchange(asset).markets.getMarket();
    let accounts = {
        state: exchange_1.exchange.stateAddress,
        market: market.address,
        zetaBaseVault: market.baseVault,
        zetaQuoteVault: market.quoteVault,
        dexBaseVault: market.serumMarket.baseVaultAddress,
        dexQuoteVault: market.serumMarket.quoteVaultAddress,
        vaultOwner,
        mintAuthority: exchange_1.exchange.mintAuthority,
        serumAuthority: exchange_1.exchange.serumAuthority,
        dexProgram: constants.DEX_PID[exchange_1.exchange.network],
        tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
    };
    let remainingAccounts = [
        {
            pubkey: openOrders,
            isSigner: false,
            isWritable: true,
        },
    ];
    return exchange_1.exchange.program.instruction.settleDexFunds({
        accounts,
        remainingAccounts,
    });
}
exports.settleDexFundsIx = settleDexFundsIx;
function burnVaultTokenTx(asset) {
    let market = exchange_1.exchange.getSubExchange(asset).markets.getMarket();
    let tx = new web3_js_1.Transaction();
    tx.add(exchange_1.exchange.program.instruction.burnVaultTokens({
        accounts: {
            state: exchange_1.exchange.stateAddress,
            mint: market.serumMarket.quoteMintAddress,
            vault: market.quoteVault,
            serumAuthority: exchange_1.exchange.serumAuthority,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
        },
    }));
    tx.add(exchange_1.exchange.program.instruction.burnVaultTokens({
        accounts: {
            state: exchange_1.exchange.stateAddress,
            mint: market.serumMarket.baseMintAddress,
            vault: market.baseVault,
            serumAuthority: exchange_1.exchange.serumAuthority,
            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
        },
    }));
    return tx;
}
exports.burnVaultTokenTx = burnVaultTokenTx;
function toggleMarketMakerIx(isMarketMaker, account) {
    return exchange_1.exchange.program.instruction.toggleMarketMaker(isMarketMaker, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            admin: exchange_1.exchange.state.admin,
            marginAccount: account,
        },
    });
}
exports.toggleMarketMakerIx = toggleMarketMakerIx;
function chooseAirdropCommunityIx(community, accountManager, authority) {
    return exchange_1.exchange.program.instruction.chooseAirdropCommunity(community, {
        accounts: {
            crossMarginAccountManager: accountManager,
            authority,
        },
    });
}
exports.chooseAirdropCommunityIx = chooseAirdropCommunityIx;
function editDelegatedPubkeyIx(delegatedPubkey, account, authority) {
    return exchange_1.exchange.program.instruction.editDelegatedPubkey(delegatedPubkey, {
        accounts: {
            marginAccount: account,
            authority,
        },
    });
}
exports.editDelegatedPubkeyIx = editDelegatedPubkeyIx;
function updateTakeTriggerOrderFeePercentageIx(newTakeTriggerOrderFeePercentage, admin) {
    return exchange_1.exchange.program.instruction.updateTakeTriggerOrderFeePercentage(newTakeTriggerOrderFeePercentage, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            admin,
        },
    });
}
exports.updateTakeTriggerOrderFeePercentageIx = updateTakeTriggerOrderFeePercentageIx;
function updateMakerRebatePercentageIx(newNativeMakerRebatePercetange, admin) {
    return exchange_1.exchange.program.instruction.updateMakerRebatePercentage(newNativeMakerRebatePercetange, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            admin,
        },
    });
}
exports.updateMakerRebatePercentageIx = updateMakerRebatePercentageIx;
function editMaType(maType, marginAccount, admin) {
    return exchange_1.exchange.program.instruction.editMaType(types.toProgramMarginAccountType(maType), {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            admin,
            marginAccount,
        },
    });
}
exports.editMaType = editMaType;
function updateMinLotIx(asset, newMinLotSize, admin) {
    return exchange_1.exchange.program.instruction.updateMinLot((0, assets_1.toProgramAsset)(asset), newMinLotSize, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            admin,
        },
    });
}
exports.updateMinLotIx = updateMinLotIx;
function updateTickSizeIx(asset, newTickSize, admin) {
    return exchange_1.exchange.program.instruction.updateTickSize((0, assets_1.toProgramAsset)(asset), newTickSize, {
        accounts: {
            state: exchange_1.exchange.stateAddress,
            admin,
        },
    });
}
exports.updateTickSizeIx = updateTickSizeIx;
function initializeMinLotsAndTickSizes(admin) {
    return exchange_1.exchange.program.instruction.initializeMinLotsAndTickSizes({
        accounts: {
            state: exchange_1.exchange.stateAddress,
            admin,
        },
    });
}
exports.initializeMinLotsAndTickSizes = initializeMinLotsAndTickSizes;
