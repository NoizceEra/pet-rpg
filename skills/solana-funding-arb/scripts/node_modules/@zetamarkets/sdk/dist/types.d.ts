import * as anchor from "@zetamarkets/anchor";
import { BN } from "@zetamarkets/anchor";
import { ConfirmOptions, Connection, PublicKey, Transaction, VersionedTransaction, Keypair } from "@solana/web3.js";
import { Connection as ConnectionZstd } from "zeta-solana-web3";
import { Asset, MarginAccountType } from "./constants";
import { CrossMarginAccount, MarginAccount } from "./program-types";
import { Network, types } from ".";
/**
 * Wallet interface for objects that can be used to sign provider transactions.
 */
export interface Wallet {
    signTransaction(tx: Transaction | VersionedTransaction): Promise<Transaction | VersionedTransaction>;
    signAllTransactions(txs: Transaction[] | VersionedTransaction[]): Promise<Transaction[] | VersionedTransaction[]>;
    publicKey: PublicKey;
}
export declare class DummyWallet implements Wallet {
    constructor();
    signTransaction(_tx: Transaction | VersionedTransaction): Promise<Transaction | VersionedTransaction>;
    signAllTransactions(_txs: Transaction[] | VersionedTransaction[]): Promise<Transaction[] | VersionedTransaction[]>;
    get publicKey(): PublicKey;
}
export declare class PythDummyWallet implements Wallet {
    constructor();
    readonly payer: Keypair;
    signTransaction<T extends Transaction | VersionedTransaction>(_tx: T): Promise<T>;
    signAllTransactions<T extends Transaction | VersionedTransaction>(txs: T[]): Promise<T[]>;
    get publicKey(): PublicKey;
}
export declare enum OrderType {
    LIMIT = 0,
    POSTONLY = 1,
    FILLORKILL = 2,
    IMMEDIATEORCANCEL = 3,
    POSTONLYSLIDE = 4,
    POSTONLYFRONT = 5
}
export declare function toProgramOrderType(orderType: OrderType): {
    limit: {};
    postOnly?: undefined;
    fillOrKill?: undefined;
    immediateOrCancel?: undefined;
    postOnlySlide?: undefined;
    postOnlyFront?: undefined;
} | {
    postOnly: {};
    limit?: undefined;
    fillOrKill?: undefined;
    immediateOrCancel?: undefined;
    postOnlySlide?: undefined;
    postOnlyFront?: undefined;
} | {
    fillOrKill: {};
    limit?: undefined;
    postOnly?: undefined;
    immediateOrCancel?: undefined;
    postOnlySlide?: undefined;
    postOnlyFront?: undefined;
} | {
    immediateOrCancel: {};
    limit?: undefined;
    postOnly?: undefined;
    fillOrKill?: undefined;
    postOnlySlide?: undefined;
    postOnlyFront?: undefined;
} | {
    postOnlySlide: {};
    limit?: undefined;
    postOnly?: undefined;
    fillOrKill?: undefined;
    immediateOrCancel?: undefined;
    postOnlyFront?: undefined;
} | {
    postOnlyFront: {};
    limit?: undefined;
    postOnly?: undefined;
    fillOrKill?: undefined;
    immediateOrCancel?: undefined;
    postOnlySlide?: undefined;
};
export declare function fromProgramOrderType(orderType: any): OrderType;
export declare enum SelfTradeBehavior {
    CANCELPROVIDE = 0,
    ABORTTRANSACTION = 1
}
export declare function toProgramSelfTradeBehavior(behavior: SelfTradeBehavior): {
    cancelProvide: {};
    abortTransaction?: undefined;
} | {
    abortTransaction: {};
    cancelProvide?: undefined;
};
export declare enum Side {
    BID = 0,
    ASK = 1
}
export declare enum TriggerDirection {
    UNINITIALIZED = 0,
    LESSTHANOREQUAL = 1,
    GREATERTHANOREQUAL = 2
}
export declare enum UserCallbackType {
    POLLUPDATE = 0,
    MARGINACCOUNTCHANGE = 1,
    SPREADACCOUNTCHANGE = 2,
    CROSSMARGINACCOUNTCHANGE = 3
}
export declare function toProgramSide(side: Side): {
    bid: {};
    ask?: undefined;
} | {
    ask: {};
    bid?: undefined;
};
export declare function fromProgramSide(side: any): Side;
export declare function toProgramTriggerDirection(triggerDirection: TriggerDirection): {
    uninitialized: {};
    lessThanOrEqual?: undefined;
    greaterThanOrEqual?: undefined;
} | {
    lessThanOrEqual: {};
    uninitialized?: undefined;
    greaterThanOrEqual?: undefined;
} | {
    greaterThanOrEqual: {};
    uninitialized?: undefined;
    lessThanOrEqual?: undefined;
};
export declare function fromProgramTriggerDirection(triggerDirection: any): TriggerDirection;
export declare enum Kind {
    UNINITIALIZED = "uninitialized",
    CALL = "call",
    PUT = "put",
    FUTURE = "future",
    PERP = "perp"
}
export declare function toProductKind(kind: Object): Kind;
export interface LiquidityCheckInfo {
    validLiquidity: boolean;
    avgPrice: number;
    worstPrice: number;
}
export interface Order {
    marketIndex: number;
    market: PublicKey;
    price: number;
    size: number;
    side: Side;
    orderId: BN;
    owner: PublicKey;
    clientOrderId: BN;
    tifOffset: number;
    asset: Asset;
}
export interface TriggerOrder {
    orderPrice: number;
    triggerPrice: number | null;
    size: number;
    creationTs: number;
    triggerDirection: TriggerDirection | null;
    triggerTimestamp: anchor.BN | null;
    side: Side;
    asset: Asset;
    orderType: OrderType;
    reduceOnly: boolean;
    triggerOrderBit: number;
}
export declare function orderEquals(a: Order, b: Order, cmpOrderId?: boolean): boolean;
export interface Position {
    marketIndex: number;
    market: PublicKey;
    size: number;
    costOfTrades: number;
    asset: Asset;
}
export declare function positionEquals(a: Position, b: Position): boolean;
export interface Level {
    price: number;
    size: number;
    owners: Set<string>;
}
export interface DepthOrderbook {
    bids: Level[];
    asks: Level[];
}
export interface TopLevel {
    bid: Level | null;
    ask: Level | null;
}
export declare enum MarginType {
    /**
     * Margin for orders.
     */
    INITIAL = "initial",
    /**
     * Margin for positions.
     */
    MAINTENANCE = "maintenance"
}
export interface MarginRequirement {
    initialLong: number;
    initialShort: number;
    maintenanceLong: number;
    maintenanceShort: number;
}
export interface MarginAccountState {
    balance: number;
    equity: number;
    initialMargin: number;
    initialMarginSkipConcession: number;
    maintenanceMargin: number;
    unrealizedPnl: number;
    unpaidFunding: number;
    availableBalanceInitial: number;
    availableBalanceMaintenance: number;
    availableBalanceWithdrawable: number;
}
export interface AssetRiskState {
    initialMargin: number;
    initialMarginSkipConcession: number;
    maintenanceMargin: number;
    maintenanceMarginIncludingOrders: number;
    unrealizedPnl: number;
    unpaidFunding: number;
    potentialOrderLoss: number;
}
export interface CrossMarginAccountState {
    balance: number;
    equity: number;
    availableBalanceInitial: number;
    availableBalanceMaintenance: number;
    availableBalanceMaintenanceIncludingOrders: number;
    availableBalanceWithdrawable: number;
    assetState: Map<Asset, AssetRiskState>;
    initialMarginTotal: number;
    initalMarginSkipConcessionTotal: number;
    maintenanceMarginTotal: number;
    maintenanceMarginIncludingOrdersTotal: number;
    unrealizedPnlTotal: number;
    unpaidFundingTotal: number;
    potentialOrderLossTotal: number;
}
export interface CancelArgs {
    asset: Asset;
    market: PublicKey;
    orderId: anchor.BN;
    cancelSide: Side;
}
export interface MarginParams {
    futureMarginInitial: number;
    futureMarginMaintenance: number;
}
export declare enum ProgramAccountType {
    CrossMarginAccountManager = "CrossMarginAccountManager",
    CrossMarginAccount = "CrossMarginAccount",
    MarginAccount = "MarginAccount",
    SpreadAccount = "SpreadAccount",
    ZetaGroup = "ZetaGroup",
    Greeks = "Greeks",
    PerpSyncQueue = "PerpSyncQueue",
    State = "State",
    Pricing = "Pricing"
}
export interface ClockData {
    timestamp: number;
    slot: number;
}
export declare enum MovementType {
    LOCK = 1,
    UNLOCK = 2
}
export declare function toProgramMovementType(movementType: MovementType): {
    lock: {};
    unlock?: undefined;
} | {
    unlock: {};
    lock?: undefined;
};
export declare enum TreasuryMovementType {
    TO_TREASURY_FROM_INSURANCE = 1,
    TO_INSURANCE_FROM_TREASURY = 2,
    TO_TREASURY_FROM_REFERRALS_REWARDS = 3,
    TO_REFERRALS_REWARDS_FROM_TREASURY = 4
}
export declare function toProgramTreasuryMovementType(treasuryMovementType: TreasuryMovementType): {
    toTreasuryFromInsurance: {};
    toInsuranceFromTreasury?: undefined;
    toTreasuryFromReferralsRewards?: undefined;
    toReferralsRewardsFromTreasury?: undefined;
} | {
    toInsuranceFromTreasury: {};
    toTreasuryFromInsurance?: undefined;
    toTreasuryFromReferralsRewards?: undefined;
    toReferralsRewardsFromTreasury?: undefined;
} | {
    toTreasuryFromReferralsRewards: {};
    toTreasuryFromInsurance?: undefined;
    toInsuranceFromTreasury?: undefined;
    toReferralsRewardsFromTreasury?: undefined;
} | {
    toReferralsRewardsFromTreasury: {};
    toTreasuryFromInsurance?: undefined;
    toInsuranceFromTreasury?: undefined;
    toTreasuryFromReferralsRewards?: undefined;
};
export declare type MarketIdentifier = number | PublicKey;
export declare function fromProgramMarginAccountType(accountType: any): MarginAccountType;
export declare function toProgramMarginAccountType(accountType: MarginAccountType): any;
export declare function isMarketMaker(account: CrossMarginAccount | MarginAccount): boolean;
export declare enum OrderCompleteType {
    CANCEL = 0,
    FILL = 1,
    BOOTED = 2
}
export declare function fromProgramOrderCompleteType(orderCompleteType: any): OrderCompleteType;
export interface OrderOptions {
    tifOptions: TIFOptions;
    orderType?: types.OrderType;
    reduceOnly?: boolean;
    clientOrderId?: number;
    tag?: string;
    blockhash?: {
        blockhash: string;
        lastValidBlockHeight: number;
    };
    selfTradeBehavior?: SelfTradeBehavior;
}
export interface TriggerOrderOptions {
    reduceOnly?: boolean;
    tag?: string;
    blockhash?: {
        blockhash: string;
        lastValidBlockHeight: number;
    };
}
export declare function getDefaultTriggerDirection(side: Side): TriggerDirection;
export declare function defaultTriggerOrderOptions(): TriggerOrderOptions;
/**
 * Only set one of these options
 * @field expiryOffset  seconds in future that the order will expire. Set to undefined to disable TIF.
 * @field expiryTs      timestamp that the order will expire. Set to undefined to disable TIF.
 */
export interface TIFOptions {
    expiryOffset?: number | undefined;
    expiryTs?: number | undefined;
}
export declare function defaultOrderOptions(): OrderOptions;
export interface LoadExchangeConfig {
    network: Network;
    connection: Connection;
    orderbookConnection?: Connection | ConnectionZstd;
    orderbookAssetSubscriptionOverride?: Asset[];
    opts: ConfirmOptions;
    throttleMs: number;
    loadFromStore: boolean;
    TIFBufferSeconds: number;
    loadAssets?: Asset[];
    doubleDownConnections?: Connection[];
    blockhashCacheTimeoutSeconds?: number;
}
export declare function defaultLoadExchangeConfig(network: Network, connection: Connection, opts?: ConfirmOptions, throttleMs?: number, loadFromStore?: boolean, orderbookConnection?: Connection, orderbookAssetSubscriptionOverride?: Asset[], TIFBufferSeconds?: number, loadAssets?: Asset[]): LoadExchangeConfig;
export interface ExecutionInfo {
    asset: Asset;
    price: number;
    size: number;
    isTaker: boolean;
}
/**
 * Price and side should be in native integer format i.e. the raw number (not the decimal).
 * 6 d.p for price and 3 d.p for size
 */
export interface PlaceMultiOrderArg {
    price: number;
    size: number;
    tifOptions: TIFOptions;
    clientOrderId?: number;
}
export declare enum AirdropCommunity {
    UNASSIGNED = 0,
    JUP = 1,
    PYTH = 2,
    DEBRIDGE = 3,
    SUPERTEAM = 4,
    MADLADS = 5,
    TENSORIANS = 6,
    ASSETDASH = 7
}
