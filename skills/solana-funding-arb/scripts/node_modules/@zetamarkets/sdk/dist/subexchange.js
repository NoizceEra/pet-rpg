"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubExchange = void 0;
const web3_js_1 = require("@solana/web3.js");
const utils = __importStar(require("./utils"));
const constants = __importStar(require("./constants"));
const market_1 = require("./market");
const network_1 = require("./network");
const assets_1 = require("./assets");
const instructions = __importStar(require("./program-instructions"));
const exchange_1 = require("./exchange");
class SubExchange {
    constructor() {
        this._isSetup = false;
        this._isInitialized = false;
        this._eventEmitters = [];
    }
    /**
     * Whether the object has been set up (in .initialize()).
     */
    get isSetup() {
        return this._isSetup;
    }
    /**
     * Whether the object has been initialized (in .load()).
     */
    get isInitialized() {
        return this._isInitialized;
    }
    /**
     * The asset loaded to the this.
     */
    get asset() {
        return this._asset;
    }
    // Program global addresses that will remain constant.
    /**
     * Address of zeta group account.
     */
    get zetaGroupAddress() {
        return this._zetaGroupAddress;
    }
    /**
     * Address of greeks account.
     */
    get greeksAddress() {
        return this._greeksAddress;
    }
    /**
     * Returns the markets object.
     */
    get markets() {
        return this._markets;
    }
    /**
     * Account storing the queue which synchronises taker/maker perp funding payments.
     * You shouldn't need to read from this, it's mainly for our integration tests
     */
    get perpSyncQueue() {
        return this._perpSyncQueue;
    }
    get perpSyncQueueAddress() {
        return this._perpSyncQueueAddress;
    }
    get halted() {
        return exchange_1.exchange.state.haltStates[(0, assets_1.assetToIndex)(this._asset)].halted;
    }
    async initialize(asset) {
        if (this.isSetup) {
            throw Error("SubExchange already initialized.");
        }
        this._asset = asset;
        // Load zeta group.
        let underlyingMint = utils.getUnderlyingMint(asset);
        // Grab zetagroupaddress manually because Pricing acc isnt loaded yet at this point
        this._zetaGroupAddress = utils.getZetaGroup(exchange_1.exchange.programId, underlyingMint)[0];
        this._greeksAddress = utils.getGreeks(exchange_1.exchange.programId, this._zetaGroupAddress)[0];
        this._perpSyncQueueAddress = utils.getPerpSyncQueue(exchange_1.exchange.programId, this._zetaGroupAddress)[0];
        this._isSetup = true;
    }
    /**
     * Loads a fresh instance of the subExchange object using on chain state.
     * @param throttleMs    Whether to sleep on market loading for rate limit reasons.
     */
    async load(asset, opts, perpSyncQueue, decodedSrmMarket, bidAccInfo, askAccInfo, clockData) {
        console.info(`Loading ${(0, assets_1.assetToName)(asset)} subExchange.`);
        if (this.isInitialized) {
            throw Error("SubExchange already loaded.");
        }
        this._perpSyncQueue = perpSyncQueue;
        this._markets = await market_1.ZetaGroupMarkets.load(asset, opts, decodedSrmMarket, bidAccInfo, askAccInfo, clockData);
        exchange_1.exchange.riskCalculator.updateMarginRequirements(asset);
        // Set callbacks.
        this.subscribePerpSyncQueue();
        this._isInitialized = true;
        console.info(`${(0, assets_1.assetToName)(this.asset)} SubExchange loaded`);
        return;
    }
    /**
     * Refreshes serum markets cache
     */
    async updateSerumMarkets() {
        console.info(`Refreshing Serum markets for ${(0, assets_1.assetToName)(this._asset)} SubExchange.`);
        await this._markets.market.serumMarket.updateDecoded(exchange_1.exchange.connection);
        console.log(`${(0, assets_1.assetToName)(this.asset)} SubExchange Serum markets refreshed`);
    }
    /**
     * Checks only if the perp serum markets are stale and refreshes it if so
     */
    async updatePerpSerumMarketIfNeeded(epochDelay) {
        if (!exchange_1.exchange.isInitialized) {
            return;
        }
        if (exchange_1.exchange.isHalted(this._asset)) {
            return;
        }
        let m = this._markets.market;
        if (m.serumMarket.epochLength.toNumber() == 0 ||
            m.serumMarket.startEpochSeqNum.isZero() ||
            m.serumMarket.epochStartTs.toNumber() +
                m.serumMarket.epochLength.toNumber() +
                epochDelay >
                exchange_1.exchange.clockTimestamp) {
            return;
        }
        await m.serumMarket.updateDecoded(exchange_1.exchange.connection);
        // Can get spammy on non-mainnet if no one is placing orders
        // because TIF epochs automatically roll over on new orders
        if (exchange_1.exchange.network == network_1.Network.MAINNET) {
            console.log(`${(0, assets_1.assetToName)(this.asset)} SubExchange perp Serum market refreshed`);
        }
    }
    /**
     * Update the margin parameters for a zeta group.
     */
    async updateMarginParameters(args) {
        let tx = new web3_js_1.Transaction().add(instructions.updateMarginParametersIx(this.asset, args, exchange_1.exchange.provider.wallet.publicKey));
        await utils.processTransaction(exchange_1.exchange.provider, tx);
    }
    /**
     * Update the perp parameters for a zeta group.
     */
    async updatePerpParameters(args) {
        let tx = new web3_js_1.Transaction().add(instructions.updatePerpParametersIx(this.asset, args, exchange_1.exchange.provider.wallet.publicKey));
        await utils.processTransaction(exchange_1.exchange.provider, tx);
    }
    async initializeZetaMarketsTIFEpochCycle(cycleLengthSecs) {
        if (cycleLengthSecs > 65535) {
            throw Error("Can't initialize TIF epoch cycle > u16::MAX");
        }
        let ixs = [];
        ixs.push(instructions.initializeZetaMarketTIFEpochCyclesIx(this.asset, cycleLengthSecs));
        let txs = utils.splitIxsIntoTx(ixs, constants.MAX_INITIALIZE_MARKET_TIF_EPOCH_CYCLE_IXS_PER_TX);
        await Promise.all(txs.map(async (tx) => {
            await utils.processTransaction(exchange_1.exchange.provider, tx, [], utils.commitmentConfig(exchange_1.exchange.connection.commitment), exchange_1.exchange.useLedger);
        }));
        await this.updateSerumMarkets();
    }
    async initializePerpSyncQueue() {
        let tx = new web3_js_1.Transaction().add(await instructions.initializePerpSyncQueueIx(this.asset));
        await utils.processTransaction(exchange_1.exchange.provider, tx);
    }
    async initializeUnderlying(flexUnderlying) {
        let tx = new web3_js_1.Transaction().add(instructions.initializeUnderlyingIx(await utils.getUnderlyingMint(this._asset), flexUnderlying));
        await utils.processTransaction(exchange_1.exchange.provider, tx);
    }
    /**
     * Update pricing for an expiry index.
     */
    async updatePricing() {
        let tx = new web3_js_1.Transaction().add(instructions.updatePricingV2Ix(this.asset));
        await utils.processTransaction(exchange_1.exchange.provider, tx);
    }
    async updatePricingV3(price, timestamp) {
        let tx = new web3_js_1.Transaction().add(instructions.updatePricingV3Ix(this.asset, price, timestamp));
        await utils.processTransaction(exchange_1.exchange.provider, tx);
    }
    assertInitialized() {
        if (!this.isInitialized) {
            throw Error("SubExchange uninitialized");
        }
    }
    subscribePerpSyncQueue() {
        if (this._zetaGroupAddress === web3_js_1.PublicKey.default) {
            throw Error("Cannot subscribe perpSyncQueue. ZetaGroup is null.");
        }
        let eventEmitter = exchange_1.exchange.program.account.perpSyncQueue.subscribe(exchange_1.exchange.pricing.perpSyncQueues[(0, assets_1.assetToIndex)(this._asset)], exchange_1.exchange.provider.connection.commitment);
        // Purposely don't push out a callback here, users shouldn't care about
        // updates to perpSyncQueue
        eventEmitter.on("change", async (perpSyncQueue) => {
            this._perpSyncQueue = perpSyncQueue;
        });
        this._eventEmitters.push(eventEmitter);
    }
    /**
     * @param index   market index to get mark price.
     */
    getMarkPrice() {
        let price = exchange_1.exchange.pricing.markPrices[(0, assets_1.assetToIndex)(this._asset)];
        return utils.convertNativeBNToDecimal(price, constants.PLATFORM_PRECISION);
    }
    /**
     * Returns all perp & nonperk markets in a single list
     */
    getMarket() {
        return this._markets.market;
    }
    /**
     * @param user user pubkey to be whitelisted for uncapped deposit
     */
    async whitelistUserForDeposit(user) {
        let tx = new web3_js_1.Transaction().add(instructions.initializeWhitelistDepositAccountIx(this.asset, user, exchange_1.exchange.provider.wallet.publicKey));
        await utils.processTransaction(exchange_1.exchange.provider, tx);
    }
    /**
     * @param user user pubkey to be whitelisted for our insurance vault
     */
    async whitelistUserForInsuranceVault(user) {
        let tx = new web3_js_1.Transaction().add(instructions.initializeWhitelistInsuranceAccountIx(user, exchange_1.exchange.provider.wallet.publicKey));
        await utils.processTransaction(exchange_1.exchange.provider, tx);
    }
    /**
     * @param user user pubkey to be whitelisted for trading fees
     */
    async whitelistUserForTradingFees(user) {
        let tx = new web3_js_1.Transaction().add(instructions.initializeWhitelistTradingFeesAccountIx(user, exchange_1.exchange.provider.wallet.publicKey));
        await utils.processTransaction(exchange_1.exchange.provider, tx);
    }
    /**
     * Halt zeta group functionality.
     */
    assertHalted() {
        if (!exchange_1.exchange.state.haltStates[(0, assets_1.assetToIndex)(this.asset)].halted) {
            throw Error("Not halted.");
        }
    }
    async halt() {
        let tx = new web3_js_1.Transaction().add(instructions.haltIx(this.asset, exchange_1.exchange.provider.wallet.publicKey));
        await utils.processTransaction(exchange_1.exchange.provider, tx);
    }
    async unhalt() {
        let tx = new web3_js_1.Transaction().add(instructions.unhaltIx(this.asset, exchange_1.exchange.provider.wallet.publicKey));
        await utils.processTransaction(exchange_1.exchange.provider, tx);
    }
    async updateHaltState(timestamp, spotPrice) {
        let tx = new web3_js_1.Transaction().add(instructions.updateHaltStateIx({
            asset: (0, assets_1.toProgramAsset)(this.asset),
            spotPrice: spotPrice,
            timestamp: timestamp,
        }, exchange_1.exchange.provider.wallet.publicKey));
        await utils.processTransaction(exchange_1.exchange.provider, tx);
    }
    async settlePositionsHalted(marginAccounts) {
        let txs = instructions.settlePositionsHaltedTxs(this._asset, marginAccounts, exchange_1.exchange.state.pricingAdmin);
        await Promise.all(txs.map(async (tx) => {
            await utils.processTransaction(exchange_1.exchange.provider, tx);
        }));
    }
    async cancelAllOrdersHalted() {
        this.assertHalted();
        await this.getMarket().cancelAllOrdersHalted();
    }
    async cleanZetaMarketHalted() {
        this.assertHalted();
        await utils.cleanZetaMarketHalted(this._asset);
    }
    /**
     * Close the websockets.
     */
    async close() {
        this._isInitialized = false;
        this._isSetup = false;
        await exchange_1.exchange.program.account.perpSyncQueue.unsubscribe(exchange_1.exchange.pricing.perpSyncQueues[(0, assets_1.assetToIndex)(this._asset)]);
        await this.markets.market.unsubscribeOrderbook();
        for (var i = 0; i < this._eventEmitters.length; i++) {
            this._eventEmitters[i].removeListener("change");
        }
        this._eventEmitters = [];
    }
}
exports.SubExchange = SubExchange;
