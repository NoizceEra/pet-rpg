"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Market = exports.ZetaGroupMarkets = void 0;
const anchor = __importStar(require("@zetamarkets/anchor"));
const market_1 = require("./serum/market");
const exchange_1 = require("./exchange");
const constants = __importStar(require("./constants"));
const utils_1 = require("./utils");
const types = __importStar(require("./types"));
const events_1 = require("./events");
const assets_1 = require("./assets");
class ZetaGroupMarkets {
    constructor(asset) {
        this._pollInterval = constants.DEFAULT_MARKET_POLL_INTERVAL;
        this._asset = asset;
        this._lastPollTimestamp = 0;
    }
    /**
     * The underlying asset this set of markets belong to.
     */
    get asset() {
        return this._asset;
    }
    /**
     * The list of markets in the same ordering as the zeta group account
     * They are in sorted order by market address.
     */
    get market() {
        return this._market;
    }
    set pollInterval(interval) {
        if (interval < 0) {
            throw Error("Invalid poll interval");
        }
        this._pollInterval = interval;
    }
    get pollInterval() {
        return this._pollInterval;
    }
    /**
     * Will load a new instance of ZetaGroupMarkets
     * Should not be called outside of SubExchange.
     */
    static async load(asset, opts, decodedSrmMarket, bidAccInfo, askAccInfo, clockData) {
        let instance = new ZetaGroupMarkets(asset);
        let subExchange = exchange_1.exchange.getSubExchange(asset);
        // Perps product/market is separate
        let marketAddr = exchange_1.exchange.pricing.products[(0, assets_1.assetToIndex)(asset)].market;
        let serumMarket;
        serumMarket = market_1.Market.loadFromDecoded(decodedSrmMarket, {
            commitment: opts.commitment,
            skipPreflight: opts.skipPreflight,
        }, constants.DEX_PID[exchange_1.exchange.network]);
        let [baseVaultAddr, _baseVaultNonce] = (0, utils_1.getZetaVault)(exchange_1.exchange.programId, serumMarket.baseMintAddress);
        let [quoteVaultAddr, _quoteVaultNonce] = (0, utils_1.getZetaVault)(exchange_1.exchange.programId, serumMarket.quoteMintAddress);
        instance._market = new Market(asset, marketAddr, subExchange.zetaGroupAddress, quoteVaultAddr, baseVaultAddr, serumMarket);
        let book = undefined;
        if (bidAccInfo && askAccInfo) {
            book = serumMarket.loadBidsAndAsksFromData(clockData, bidAccInfo, askAccInfo);
        }
        else {
            book = await serumMarket.loadBidsAndAsks(exchange_1.exchange.provider.connection);
        }
        instance._market.bids = book.bids;
        instance._market.asks = book.asks;
        instance._market.updateOrderbook();
        return instance;
    }
    /**
     * Returns the market object for a given index.
     */
    getMarket() {
        return this._market;
    }
    /**
     * Returns the market index for a given market address.
     */
    getMarketIndex(market) {
        let compare = (a, b) => a.toBuffer().compare(b.toBuffer());
        let sub = exchange_1.exchange.getSubExchange(this.asset);
        if (compare(market, sub.markets.market.address) == 0) {
            return constants.PERP_INDEX;
        }
        else {
            throw Error("Cannot get market index of non perp market on perp only market!");
        }
    }
}
exports.ZetaGroupMarkets = ZetaGroupMarkets;
/**
 * Wrapper class for a zeta market on serum.
 */
class Market {
    constructor(asset, address, zetaGroup, quoteVault, baseVault, serumMarket) {
        this._asset = asset;
        this._address = address;
        this._zetaGroup = zetaGroup;
        this._quoteVault = quoteVault;
        this._baseVault = baseVault;
        this._serumMarket = serumMarket;
        this._strike = 0;
        this._orderbook = { bids: [], asks: [] };
        this._bidsSlot = 0;
        this._asksSlot = 0;
        this._TIFBufferSeconds = 0;
    }
    /**
     * The underlying asset this set of markets belong to.
     */
    get asset() {
        return this._asset;
    }
    /**
     * The serum market address.
     */
    get address() {
        return this._address;
    }
    /**
     * The zeta group this market belongs to.
     * TODO currently there exists only one zeta group.
     */
    get zetaGroup() {
        return this._zetaGroup;
    }
    /**
     * The zeta vault for the quote mint.
     */
    get quoteVault() {
        return this._quoteVault;
    }
    /**
     * The zeta vault for the base mint.
     */
    get baseVault() {
        return this._baseVault;
    }
    /**
     * The serum Market object from @project-serum/ts
     */
    get serumMarket() {
        return this._serumMarket;
    }
    set bids(bids) {
        this._bids = bids;
    }
    set asks(asks) {
        this._asks = asks;
    }
    get bidsSlot() {
        return this._bidsSlot;
    }
    get asksSlot() {
        return this._asksSlot;
    }
    /**
     * Returns the best N levels for bids and asks
     */
    get orderbook() {
        return this._orderbook;
    }
    /**
     * The strike of this option, modified on new expiry.
     */
    get strike() {
        return this._strike;
    }
    set TIFBufferSeconds(buffer) {
        this._TIFBufferSeconds = buffer;
    }
    get TIFBufferSeconds() {
        return this._TIFBufferSeconds;
    }
    updateStrike() {
        let strike = exchange_1.exchange.pricing.products[(0, assets_1.assetToIndex)(this._asset)].strike;
        if (!strike.isSet) {
            this._strike = null;
        }
        else {
            this._strike = (0, utils_1.convertNativeBNToDecimal)(strike.value);
        }
    }
    subscribeOrderbook(callback) {
        let connection = exchange_1.exchange.orderbookConnection
            ? exchange_1.exchange.orderbookConnection
            : exchange_1.exchange.provider.connection;
        this._bidsSubscriptionId = connection.onAccountChange(this.serumMarket.decoded.bids, async (accountInfo, context) => {
            let decodedMarket = market_1.Orderbook.decode(this.serumMarket, (0, market_1.throwIfNull)(accountInfo).data);
            this._bids = decodedMarket;
            this._bidsSlot = context.slot;
            this.updateOrderbook();
            if (callback !== undefined) {
                callback(this.asset, events_1.EventType.ORDERBOOK, context.slot, null);
            }
        }, connection.commitment);
        this._asksSubscriptionId = connection.onAccountChange(this.serumMarket.decoded.asks, async (accountInfo, context) => {
            let decodedMarket = market_1.Orderbook.decode(this.serumMarket, (0, market_1.throwIfNull)(accountInfo).data);
            this._asks = decodedMarket;
            this._asksSlot = context.slot;
            this.updateOrderbook();
            if (callback !== undefined) {
                callback(this.asset, events_1.EventType.ORDERBOOK, context.slot, null);
            }
        }, connection.commitment);
    }
    async unsubscribeOrderbook(wipeState = false) {
        let connection = exchange_1.exchange.orderbookConnection
            ? exchange_1.exchange.orderbookConnection
            : exchange_1.exchange.provider.connection;
        if (this._bidsSubscriptionId !== undefined) {
            await connection.removeAccountChangeListener(this._bidsSubscriptionId);
            this._bidsSubscriptionId = undefined;
        }
        if (this._asksSubscriptionId !== undefined) {
            await connection.removeAccountChangeListener(this._asksSubscriptionId);
            this._asksSubscriptionId = undefined;
        }
        // Only after we're definitely no longer updating
        if (wipeState) {
            this._bids = undefined;
            this._asks = undefined;
            this._bidsSlot = 0;
            this._asksSlot = 0;
            this.updateOrderbook();
        }
    }
    async forceFetchOrderbook() {
        let orderbook = await this.serumMarket.loadBidsAndAsks(exchange_1.exchange.connection);
        this._bids = orderbook.bids;
        this._asks = orderbook.asks;
        this.updateOrderbook();
    }
    updateOrderbook() {
        // On a fresh subscription if there isn't data yet
        if (this._bids == undefined || this._asks == undefined) {
            this._orderbook = { bids: [], asks: [] };
            return;
        }
        [this._bids, this._asks].map((orderbookSide) => {
            const descending = orderbookSide.isBids ? true : false;
            const levels = []; // (price, size, tifOffset, owners)
            for (const { key, quantity, tifOffset, owner, } of orderbookSide.slab.items(descending)) {
                let seqNum = (0, utils_1.getSeqNumFromSerumOrderKey)(key, orderbookSide.isBids);
                if ((0, utils_1.isOrderExpired)(tifOffset.toNumber(), seqNum, this._serumMarket.epochStartTs.toNumber(), this._serumMarket.startEpochSeqNum, this._TIFBufferSeconds)) {
                    continue;
                }
                const price = (0, utils_1.getPriceFromSerumOrderKey)(key);
                if (levels.length > 0 && levels[levels.length - 1][0].eq(price)) {
                    levels[levels.length - 1][1].iadd(quantity);
                    levels[levels.length - 1][2].add(owner.toString());
                }
                else {
                    levels.push([
                        price,
                        new anchor.BN(quantity.toNumber()),
                        new Set([owner.toString()]),
                    ]);
                }
            }
            this._orderbook[orderbookSide.isBids ? "bids" : "asks"] = levels.map(([priceLots, sizeLots, owners]) => {
                return {
                    price: this._serumMarket.priceLotsToNumber(priceLots),
                    size: (0, utils_1.convertNativeLotSizeToDecimal)(this._serumMarket.baseSizeLotsToNumber(sizeLots)),
                    owners: owners,
                };
            });
        });
    }
    getTopLevel() {
        let topLevel = { bid: null, ask: null };
        if (this._orderbook.bids.length != 0) {
            topLevel.bid = this._orderbook.bids[0];
        }
        if (this._orderbook.asks.length != 0) {
            topLevel.ask = this._orderbook.asks[0];
        }
        return topLevel;
    }
    static convertOrder(market, order) {
        return {
            marketIndex: constants.PERP_INDEX,
            market: market.address,
            price: order.price,
            size: (0, utils_1.convertNativeLotSizeToDecimal)(order.size),
            side: order.side == "buy" ? types.Side.BID : types.Side.ASK,
            orderId: order.orderId,
            owner: order.openOrdersAddress,
            clientOrderId: order.clientId,
            tifOffset: order.tifOffset,
            asset: market.asset,
        };
    }
    getOrdersForAccount(openOrdersAddress) {
        let orders = [...this._bids, ...this._asks].filter((order) => order.openOrdersAddress.equals(openOrdersAddress));
        return orders.map((order) => {
            return Market.convertOrder(this, order);
        });
    }
    getMarketOrders() {
        return [...this._bids, ...this._asks].map((order) => {
            return Market.convertOrder(this, order);
        });
    }
    getBidOrders() {
        return [...this._bids].map((order) => {
            return Market.convertOrder(this, order);
        });
    }
    getAskOrders() {
        return [...this._asks].map((order) => {
            return Market.convertOrder(this, order);
        });
    }
    async cancelAllOrdersHalted() {
        exchange_1.exchange.getSubExchange(this.asset).assertHalted();
        this.updateOrderbook();
        let orders = this.getMarketOrders();
        let ixs = await (0, utils_1.getCancelAllIxs)(this.asset, orders, false);
        let txs = (0, utils_1.splitIxsIntoTx)(ixs, constants.MAX_CANCELS_PER_TX);
        await Promise.all(txs.map(async (tx) => {
            await (0, utils_1.processTransaction)(exchange_1.exchange.provider, tx);
        }));
    }
}
exports.Market = Market;
