/* eslint-disable @typescript-eslint/no-non-null-asserted-optional-chain */ /* eslint-disable @typescript-eslint/no-non-null-assertion */ /* eslint-disable @typescript-eslint/prefer-nullish-coalescing */ import { PublicKey, SystemProgram } from "@solana/web3.js";
import bs58 from "bs58";
import { Bundle } from "jito-ts/dist/sdk/block-engine/types";
import { dummyLogger } from "ts-log";
export const TIP_ACCOUNTS = [
    "HFqU5x63VTqvQss8hp11i4wVV8bD44PvwucfZ2bU7gRe",
    "Cw8CFyM9FkoMi7K7Crf6HNQqf4uEMzpKw6QNghXLvLkY",
    "DfXygSm4jCyNCybVYYK6DwvWqjKee8pbDmJGcLWNDXjh",
    "ADaUMid9yfUytqMBgopwjb2DTLSokTSzL1zt6iGPaS49",
    "3AVi9Tg9Uo68tJfuvoKvqKNWKkC5wPdSSdeBnizKZ6jT",
    "DttWaMuVvTiduZRnguLF7jNxTgiMBZ1hyAumKUiL2KRL",
    "96gYZGLnJYVFmbjzopPSU6QiEV5fGqZNyN9nmNhvrZU5",
    "ADuUkR4vqLUMWXxW9gh6D6L8pMSawimctcNZ5pGwDcEt"
];
export function getRandomTipAccount() {
    const randomInt = Math.floor(Math.random() * TIP_ACCOUNTS.length);
    return new PublicKey(TIP_ACCOUNTS[randomInt] ?? "");
}
export function buildJitoTipInstruction(payer, lamports) {
    return SystemProgram.transfer({
        fromPubkey: payer,
        toPubkey: getRandomTipAccount(),
        lamports
    });
}
export async function sendTransactionsJito(transactions, searcherClients, wallet, options = {}, logger = dummyLogger) {
    const clients = Array.isArray(searcherClients) ? searcherClients : [
        searcherClients
    ];
    if (clients.length === 0) {
        throw new Error("No searcher clients provided");
    }
    const maxRetryTimeMs = options.maxRetryTimeMs || 60_000; // Default to 60 seconds
    const delayBetweenCyclesMs = options.delayBetweenCyclesMs || 1000; // Default to 1 second
    const startTime = Date.now();
    const signedTransactions = [];
    for (const transaction of transactions){
        const signers = transaction.signers;
        let tx = transaction.tx;
        if (signers) {
            tx.sign(signers);
        }
        tx = await wallet.signTransaction(tx);
        signedTransactions.push(tx);
    }
    const firstTransactionSignature = bs58.encode(signedTransactions[0]?.signatures[0]);
    const bundle = new Bundle(signedTransactions, 2);
    let lastError;
    let totalAttempts = 0;
    while(Date.now() - startTime < maxRetryTimeMs){
        // Try all clients in this cycle
        for (const [i, currentClient] of clients.entries()){
            totalAttempts++;
            try {
                await currentClient.sendBundle(bundle);
                logger.info({
                    clientIndex: i,
                    totalAttempts
                }, `Successfully sent bundle to Jito client after ${totalAttempts.toString()} attempts`);
                return firstTransactionSignature;
            } catch (error) {
                lastError = error;
                logger.error({
                    clientIndex: i,
                    totalAttempts,
                    err: lastError.message
                }, `Attempt ${totalAttempts.toString()}: Error sending bundle to Jito client ${i.toString()}`);
            }
            // Check if we've run out of time
            if (Date.now() - startTime >= maxRetryTimeMs) {
                break;
            }
        }
        // If we've tried all clients and still have time, wait before next cycle
        const timeRemaining = maxRetryTimeMs - (Date.now() - startTime);
        if (timeRemaining > delayBetweenCyclesMs) {
            await new Promise((resolve)=>setTimeout(resolve, delayBetweenCyclesMs));
        }
    }
    const totalTimeMs = Date.now() - startTime;
    const errorMsg = `Failed to send transactions via JITO after ${totalAttempts.toString()} attempts over ${totalTimeMs.toString()}ms (max: ${maxRetryTimeMs.toString()}ms)`;
    logger.error({
        totalAttempts,
        totalTimeMs,
        maxRetryTimeMs,
        lastError: lastError?.message
    }, errorMsg);
    throw lastError || new Error(errorMsg);
}
