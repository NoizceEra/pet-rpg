/* eslint-disable no-console */ /* eslint-disable unicorn/no-null */ /* eslint-disable @typescript-eslint/prefer-nullish-coalescing */ /* eslint-disable @typescript-eslint/no-non-null-assertion */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get DEFAULT_COMPUTE_BUDGET_UNITS () {
        return DEFAULT_COMPUTE_BUDGET_UNITS;
    },
    get DEFAULT_PRIORITY_FEE_CONFIG () {
        return DEFAULT_PRIORITY_FEE_CONFIG;
    },
    get JITO_BUNDLE_SIZE () {
        return JITO_BUNDLE_SIZE;
    },
    get PACKET_DATA_SIZE_WITH_ROOM_FOR_COMPUTE_BUDGET () {
        return PACKET_DATA_SIZE_WITH_ROOM_FOR_COMPUTE_BUDGET;
    },
    get TransactionBuilder () {
        return TransactionBuilder;
    },
    get getSizeOfCompressedU16 () {
        return getSizeOfCompressedU16;
    },
    get getSizeOfTransaction () {
        return getSizeOfTransaction;
    },
    get isVersionedTransaction () {
        return isVersionedTransaction;
    },
    get sendTransactions () {
        return sendTransactions;
    }
});
const _web3 = require("@solana/web3.js");
const _bs58 = /*#__PURE__*/ _interop_require_default(require("bs58"));
const _jito = require("./jito.cjs");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const DEFAULT_COMPUTE_BUDGET_UNITS = 200_000;
const PACKET_DATA_SIZE_WITH_ROOM_FOR_COMPUTE_BUDGET = _web3.PACKET_DATA_SIZE - 52;
const JITO_BUNDLE_SIZE = 5;
const DEFAULT_PRIORITY_FEE_CONFIG = {
    computeUnitPriceMicroLamports: 50_000
};
function getSizeOfTransaction(instructions, versionedTransaction = true, addressLookupTable) {
    const programs = new Set();
    const signers = new Set();
    let accounts = new Set();
    instructions.map((ix)=>{
        programs.add(ix.programId.toBase58());
        accounts.add(ix.programId.toBase58());
        ix.keys.map((key)=>{
            if (key.isSigner) {
                signers.add(key.pubkey.toBase58());
            }
            accounts.add(key.pubkey.toBase58());
        });
    });
    const instruction_sizes = instructions.map((ix)=>1 + getSizeOfCompressedU16(ix.keys.length) + ix.keys.length + getSizeOfCompressedU16(ix.data.length) + ix.data.length).reduce((a, b)=>a + b, 0);
    let numberOfAddressLookups = 0;
    if (addressLookupTable) {
        const lookupTableAddresses = new Set(addressLookupTable.state.addresses.map((address)=>address.toBase58()));
        const totalNumberOfAccounts = accounts.size;
        accounts = new Set([
            ...accounts
        ].filter((account)=>!lookupTableAddresses.has(account)));
        accounts = new Set([
            ...accounts,
            ...programs,
            ...signers
        ]);
        numberOfAddressLookups = totalNumberOfAccounts - accounts.size; // This number is equal to the number of accounts that are in the lookup table and are neither signers nor programs
    }
    return getSizeOfCompressedU16(signers.size) + signers.size * 64 + // array of signatures
    3 + getSizeOfCompressedU16(accounts.size) + 32 * accounts.size + // array of account addresses
    32 + // recent blockhash
    getSizeOfCompressedU16(instructions.length) + instruction_sizes + // array of instructions
    (versionedTransaction ? 1 + getSizeOfCompressedU16(0) : 0) + // transaction version and number of address lookup tables
    (versionedTransaction && addressLookupTable ? 32 : 0) + // address lookup table address (we only support 1 address lookup table)
    (versionedTransaction && addressLookupTable ? 2 : 0) + // number of address lookup indexes
    numberOfAddressLookups // address lookup indexes
    ;
}
function getSizeOfCompressedU16(n) {
    return 1 + Number(n >= 128) + Number(n >= 16_384);
}
class TransactionBuilder {
    transactionInstructions = [];
    payer;
    connection;
    addressLookupTable;
    /** Make a new `TransactionBuilder`. It requires a `payer` to populate the `payerKey` field and a connection to populate `recentBlockhash` in the versioned transactions. */ constructor(payer, connection, addressLookupTable){
        this.payer = payer;
        this.connection = connection;
        this.addressLookupTable = addressLookupTable;
    }
    /**
   * Add an `InstructionWithEphemeralSigners` to the builder.
   */ addInstruction(args) {
        const { instruction, signers, computeUnits } = args;
        if (this.transactionInstructions.length === 0) {
            this.transactionInstructions.push({
                instructions: [
                    instruction
                ],
                signers: signers,
                computeUnits: computeUnits ?? 0
            });
        } else {
            const sizeWithComputeUnits = getSizeOfTransaction([
                ...this.transactionInstructions.at(-1)?.instructions ?? [],
                instruction,
                this.transactionInstructions.length % JITO_BUNDLE_SIZE === 0 // This transaction may be the first of a Jito bundle, so we leave room for a Jito tip transfer.
                 ? (0, _jito.buildJitoTipInstruction)(this.payer, 1) : _web3.ComputeBudgetProgram.setComputeUnitPrice({
                    microLamports: 1
                }),
                _web3.ComputeBudgetProgram.setComputeUnitLimit({
                    units: 1
                })
            ], true, this.addressLookupTable);
            if (sizeWithComputeUnits <= _web3.PACKET_DATA_SIZE) {
                this.transactionInstructions.at(-1)?.instructions.push(instruction);
                this.transactionInstructions.at(-1)?.signers.push(...signers);
                this.transactionInstructions.at(-1).computeUnits += computeUnits ?? 0;
            } else this.transactionInstructions.push({
                instructions: [
                    instruction
                ],
                signers: signers,
                computeUnits: computeUnits ?? 0
            });
        }
    }
    /**
   * Add multiple `InstructionWithEphemeralSigners` to the builder.
   */ addInstructions(instructions) {
        for (const { instruction, signers, computeUnits } of instructions){
            this.addInstruction({
                instruction,
                signers,
                computeUnits
            });
        }
    }
    /**
   * Returns all the added instructions batched into versioned transactions, plus for each transaction the ephemeral signers that need to sign it
   */ async buildVersionedTransactions(args) {
        const { blockhash } = await this.connection.getLatestBlockhash({
            commitment: "confirmed"
        });
        return this.transactionInstructions.map(({ instructions, signers, computeUnits }, index)=>{
            const instructionsWithComputeBudget = [
                ...instructions
            ];
            if (computeUnits > DEFAULT_COMPUTE_BUDGET_UNITS * instructions.length || args.tightComputeBudget) {
                instructionsWithComputeBudget.push(_web3.ComputeBudgetProgram.setComputeUnitLimit({
                    units: computeUnits
                }));
            }
            if (args.computeUnitPriceMicroLamports) {
                instructionsWithComputeBudget.push(_web3.ComputeBudgetProgram.setComputeUnitPrice({
                    microLamports: args.computeUnitPriceMicroLamports
                }));
            }
            if (args.jitoTipLamports && index % JITO_BUNDLE_SIZE === 0) {
                instructionsWithComputeBudget.push((0, _jito.buildJitoTipInstruction)(this.payer, args.jitoTipLamports));
            }
            // This handles an edge case where a single instruction is too big and therefore needs to be by itself without any compute budget instructions or jito tips
            const instructionsToSend = [];
            for (const instruction of instructionsWithComputeBudget){
                const sizeWithInstruction = getSizeOfTransaction([
                    ...instructionsToSend,
                    instruction
                ], true, this.addressLookupTable);
                if (sizeWithInstruction > _web3.PACKET_DATA_SIZE) {
                    break;
                }
                instructionsToSend.push(instruction);
            }
            return {
                tx: new _web3.VersionedTransaction(new _web3.TransactionMessage({
                    recentBlockhash: blockhash,
                    instructions: instructionsToSend,
                    payerKey: this.payer
                }).compileToV0Message(this.addressLookupTable ? [
                    this.addressLookupTable
                ] : [])),
                signers: signers
            };
        });
    }
    /**
   * Returns all the added instructions batched into transactions, plus for each transaction the ephemeral signers that need to sign it
   */ buildLegacyTransactions(args) {
        return this.transactionInstructions.map(({ instructions, signers, computeUnits }, index)=>{
            const instructionsWithComputeBudget = [
                ...instructions
            ];
            if (computeUnits > DEFAULT_COMPUTE_BUDGET_UNITS * instructions.length || args.tightComputeBudget) {
                instructionsWithComputeBudget.push(_web3.ComputeBudgetProgram.setComputeUnitLimit({
                    units: computeUnits
                }));
            }
            if (args.computeUnitPriceMicroLamports) {
                instructionsWithComputeBudget.push(_web3.ComputeBudgetProgram.setComputeUnitPrice({
                    microLamports: args.computeUnitPriceMicroLamports
                }));
            }
            if (args.jitoTipLamports && index % JITO_BUNDLE_SIZE === 0) {
                instructionsWithComputeBudget.push((0, _jito.buildJitoTipInstruction)(this.payer, args.jitoTipLamports));
            }
            // This handles an edge case where a single instruction is too big and therefore needs to be by itself without any compute budget instructions or jito tips
            const instructionsToSend = [];
            for (const instruction of instructionsWithComputeBudget){
                const sizeWithInstruction = getSizeOfTransaction([
                    ...instructionsToSend,
                    instruction
                ], false);
                if (sizeWithInstruction > _web3.PACKET_DATA_SIZE) {
                    if (instructionsToSend.length === 0) {
                        throw new Error(`An instruction is too big to be sent in a transaction (${sizeWithInstruction.toString()} > ${_web3.PACKET_DATA_SIZE.toString()} bytes)`);
                    }
                    break;
                }
                instructionsToSend.push(instruction);
            }
            return {
                tx: new _web3.Transaction().add(...instructionsToSend),
                signers: signers
            };
        });
    }
    /**
   * Returns a set of transactions that contain the provided instructions in the same order and with efficient batching
   */ static batchIntoLegacyTransactions(instructions, priorityFeeConfig) {
        const transactionBuilder = new TransactionBuilder(_web3.PublicKey.unique(), new _web3.Connection("http://placeholder.placeholder")); // We only need wallet and connection for `VersionedTransaction` so we can put placeholders here
        for (const instruction of instructions){
            transactionBuilder.addInstruction({
                instruction,
                signers: []
            });
        }
        return transactionBuilder.buildLegacyTransactions(priorityFeeConfig).map(({ tx })=>{
            return tx;
        });
    }
    /**
   * Returns a set of versioned transactions that contain the provided instructions in the same order and with efficient batching
   */ static async batchIntoVersionedTransactions(payer, connection, instructions, priorityFeeConfig, addressLookupTable) {
        const transactionBuilder = new TransactionBuilder(payer, connection, addressLookupTable);
        transactionBuilder.addInstructions(instructions);
        return transactionBuilder.buildVersionedTransactions(priorityFeeConfig);
    }
    /**
   * Add a priority fee to a legacy transaction
   */ static addPriorityFee(transaction, priorityFeeConfig) {
        if (priorityFeeConfig.computeUnitPriceMicroLamports) {
            transaction.add(_web3.ComputeBudgetProgram.setComputeUnitPrice({
                microLamports: priorityFeeConfig.computeUnitPriceMicroLamports
            }));
        }
    }
}
const isVersionedTransaction = (tx)=>{
    return "version" in tx;
};
const TX_RETRY_INTERVAL = 500;
async function sendTransactions(transactions, connection, wallet, maxRetries) {
    const blockhashResult = await connection.getLatestBlockhashAndContext({
        commitment: "confirmed"
    });
    const signatures = [];
    // Signing logic for versioned transactions is different from legacy transactions
    for (const [index, transaction] of transactions.entries()){
        const signers = transaction.signers;
        let tx = transaction.tx;
        if (isVersionedTransaction(tx)) {
            if (signers) {
                tx.sign(signers);
            }
        } else {
            tx.feePayer = tx.feePayer ?? wallet.publicKey;
            tx.recentBlockhash = blockhashResult.value.blockhash;
            if (signers) {
                for (const signer of signers){
                    tx.partialSign(signer);
                }
            }
        }
        tx = await wallet.signTransaction(tx);
        // In the following section, we wait and constantly check for the transaction to be confirmed
        // and resend the transaction if it is not confirmed within a certain time interval
        // thus handling tx retries on the client side rather than relying on the RPC
        let confirmedTx;
        let retryCount = 0;
        // Get the signature of the transaction with different logic for versioned transactions
        const txSignature = _bs58.default.encode(isVersionedTransaction(tx) ? tx.signatures[0] || new Uint8Array() : tx.signature ?? new Uint8Array());
        const confirmTransactionPromise = connection.confirmTransaction({
            signature: txSignature,
            blockhash: blockhashResult.value.blockhash,
            lastValidBlockHeight: blockhashResult.value.lastValidBlockHeight
        }, "confirmed");
        confirmedTx = undefined;
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        while(!confirmedTx){
            confirmedTx = await Promise.race([
                new Promise((resolve)=>{
                    void confirmTransactionPromise.then((result)=>{
                        resolve(result.value);
                    });
                }),
                new Promise((resolve)=>setTimeout(()=>{
                        resolve(null);
                    }, TX_RETRY_INTERVAL))
            ]);
            if (confirmedTx) {
                break;
            }
            if (maxRetries && maxRetries < retryCount) {
                break;
            }
            console.log("Retrying transaction", index, "of", transactions.length - 1, "with signature:", txSignature, "Retry count:", retryCount);
            retryCount++;
            await connection.sendRawTransaction(tx.serialize(), {
                // Skipping preflight i.e. tx simulation by RPC as we simulated the tx above
                // This allows Triton RPCs to send the transaction through multiple pathways for the fastest delivery
                skipPreflight: true,
                // Setting max retries to 0 as we are handling retries manually
                // Set this manually so that the default is skipped
                maxRetries: 0,
                preflightCommitment: "confirmed"
            });
        }
        if (confirmedTx?.err) {
            throw new Error(`Transaction ${txSignature} has failed with error: ${JSON.stringify(confirmedTx.err)}`);
        }
        if (!confirmedTx) {
            throw new Error("Failed to land the transaction");
        }
        signatures.push(txSignature);
    }
    return signatures;
}
