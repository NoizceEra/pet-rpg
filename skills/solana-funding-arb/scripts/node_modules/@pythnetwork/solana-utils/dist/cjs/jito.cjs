/* eslint-disable @typescript-eslint/no-non-null-asserted-optional-chain */ /* eslint-disable @typescript-eslint/no-non-null-assertion */ /* eslint-disable @typescript-eslint/prefer-nullish-coalescing */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get TIP_ACCOUNTS () {
        return TIP_ACCOUNTS;
    },
    get buildJitoTipInstruction () {
        return buildJitoTipInstruction;
    },
    get getRandomTipAccount () {
        return getRandomTipAccount;
    },
    get sendTransactionsJito () {
        return sendTransactionsJito;
    }
});
const _web3 = require("@solana/web3.js");
const _bs58 = /*#__PURE__*/ _interop_require_default(require("bs58"));
const _types = require("jito-ts/dist/sdk/block-engine/types");
const _tslog = require("ts-log");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const TIP_ACCOUNTS = [
    "HFqU5x63VTqvQss8hp11i4wVV8bD44PvwucfZ2bU7gRe",
    "Cw8CFyM9FkoMi7K7Crf6HNQqf4uEMzpKw6QNghXLvLkY",
    "DfXygSm4jCyNCybVYYK6DwvWqjKee8pbDmJGcLWNDXjh",
    "ADaUMid9yfUytqMBgopwjb2DTLSokTSzL1zt6iGPaS49",
    "3AVi9Tg9Uo68tJfuvoKvqKNWKkC5wPdSSdeBnizKZ6jT",
    "DttWaMuVvTiduZRnguLF7jNxTgiMBZ1hyAumKUiL2KRL",
    "96gYZGLnJYVFmbjzopPSU6QiEV5fGqZNyN9nmNhvrZU5",
    "ADuUkR4vqLUMWXxW9gh6D6L8pMSawimctcNZ5pGwDcEt"
];
function getRandomTipAccount() {
    const randomInt = Math.floor(Math.random() * TIP_ACCOUNTS.length);
    return new _web3.PublicKey(TIP_ACCOUNTS[randomInt] ?? "");
}
function buildJitoTipInstruction(payer, lamports) {
    return _web3.SystemProgram.transfer({
        fromPubkey: payer,
        toPubkey: getRandomTipAccount(),
        lamports
    });
}
async function sendTransactionsJito(transactions, searcherClients, wallet, options = {}, logger = _tslog.dummyLogger) {
    const clients = Array.isArray(searcherClients) ? searcherClients : [
        searcherClients
    ];
    if (clients.length === 0) {
        throw new Error("No searcher clients provided");
    }
    const maxRetryTimeMs = options.maxRetryTimeMs || 60_000; // Default to 60 seconds
    const delayBetweenCyclesMs = options.delayBetweenCyclesMs || 1000; // Default to 1 second
    const startTime = Date.now();
    const signedTransactions = [];
    for (const transaction of transactions){
        const signers = transaction.signers;
        let tx = transaction.tx;
        if (signers) {
            tx.sign(signers);
        }
        tx = await wallet.signTransaction(tx);
        signedTransactions.push(tx);
    }
    const firstTransactionSignature = _bs58.default.encode(signedTransactions[0]?.signatures[0]);
    const bundle = new _types.Bundle(signedTransactions, 2);
    let lastError;
    let totalAttempts = 0;
    while(Date.now() - startTime < maxRetryTimeMs){
        // Try all clients in this cycle
        for (const [i, currentClient] of clients.entries()){
            totalAttempts++;
            try {
                await currentClient.sendBundle(bundle);
                logger.info({
                    clientIndex: i,
                    totalAttempts
                }, `Successfully sent bundle to Jito client after ${totalAttempts.toString()} attempts`);
                return firstTransactionSignature;
            } catch (error) {
                lastError = error;
                logger.error({
                    clientIndex: i,
                    totalAttempts,
                    err: lastError.message
                }, `Attempt ${totalAttempts.toString()}: Error sending bundle to Jito client ${i.toString()}`);
            }
            // Check if we've run out of time
            if (Date.now() - startTime >= maxRetryTimeMs) {
                break;
            }
        }
        // If we've tried all clients and still have time, wait before next cycle
        const timeRemaining = maxRetryTimeMs - (Date.now() - startTime);
        if (timeRemaining > delayBetweenCyclesMs) {
            await new Promise((resolve)=>setTimeout(resolve, delayBetweenCyclesMs));
        }
    }
    const totalTimeMs = Date.now() - startTime;
    const errorMsg = `Failed to send transactions via JITO after ${totalAttempts.toString()} attempts over ${totalTimeMs.toString()}ms (max: ${maxRetryTimeMs.toString()}ms)`;
    logger.error({
        totalAttempts,
        totalTimeMs,
        maxRetryTimeMs,
        lastError: lastError?.message
    }, errorMsg);
    throw lastError || new Error(errorMsg);
}
